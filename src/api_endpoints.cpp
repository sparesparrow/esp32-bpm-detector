#include "api_endpoints.h"
#include "wifi_handler.h"
#include "bpm_detector.h"
#include "bpm_flatbuffers.h"
#include "bpm_monitor_manager.h"
#include "config.h"
#include <WebServer.h>
#include <flatbuffers/flatbuffers.h>
#include <WiFi.h>
#include <ArduinoJson.h>

// Internal state for dependency injection (no legacy globals - using smart pointers)
static WebServer* g_server = nullptr;
static BPMDetector* g_bpmDetector = nullptr;
static sparetools::bpm::BPMMonitorManager* g_monitorManager = nullptr;

/**
 * API Endpoints Implementation
 *
 * Generated by MCP-Prompts `/esp32-bpm-api-endpoint`
 * Configuration:
 * - endpoint_path: /api/v1/bpm
 * - data_format: flatbuffers
 * - update_rate: 10 Hz
 */

// BPM Current Status Endpoint
void handleBpmCurrent() {
    BPMDetector* detector = g_bpmDetector;
    WebServer* srv = g_server;
    
    if (detector == nullptr || srv == nullptr) {
        if (srv) {
            srv->send(500, "application/json", "{\"error\":\"BPM detector not initialized\"}");
        }
        return;
    }

    // Create FlatBuffers BPM update
    flatbuffers::FlatBufferBuilder builder(1024);

    // Get current BPM data
    auto bpmData = detector->detect();
    auto bpmUpdateOffset = BPMFlatBuffers::createBPMUpdate(
        bpmData.bpm,
        bpmData.confidence,
        bpmData.signal_level,
        sparetools::bpm::DetectionStatus_DETECTING,
        millis(), "esp32-s3", "1.1.0",
        builder
    );

    auto binaryData = BPMFlatBuffers::serializeBPMUpdate(bpmUpdateOffset, builder);

    // Send as JSON response (WebServer has limited binary support)
    // TODO: Implement proper binary streaming when WebSocket is added
    String json = "{";
    json += "\"bpm\":" + String(bpmData.bpm, 1) + ",";
    json += "\"confidence\":" + String(bpmData.confidence, 2) + ",";
    json += "\"signal_level\":" + String(bpmData.signal_level, 2) + ",";
    json += "\"status\":\"" + String(bpmData.status) + "\",";
    json += "\"timestamp\":" + String(bpmData.timestamp);
    json += "}";

    srv->send(200, "application/json", json);
}

// BPM Spectrum Analysis Endpoint
void handleBpmSpectrum() {
    WebServer* srv = g_server;
    if (srv) {
        srv->send(200, "application/json", "{\"spectrum\":\"not_implemented\"}");
    }
}

// System Status Endpoint
void handleSystemStatus() {
    // Create FlatBuffers status update
    flatbuffers::FlatBufferBuilder builder(1024);

    // Send as JSON response for compatibility
    String json = "{";
    json += "\"uptime_seconds\":" + String(millis() / 1000) + ",";
    json += "\"free_heap_bytes\":" + String(ESP.getFreeHeap()) + ",";
    json += "\"cpu_usage_percent\":25,";
    json += "\"wifi_rssi\":" + String(WiFi.status() == WL_CONNECTED ? WiFi.RSSI() : -100);
    json += "}";

    WebServer* srv = g_server;
    if (srv) {
        srv->send(200, "application/json", json);
    }
}

// Configuration Endpoint
void handleConfiguration() {
    String json = "{";
    json += "\"sample_rate\":" + String(SAMPLE_RATE) + ",";
    json += "\"fft_size\":" + String(FFT_SIZE) + ",";
    json += "\"min_bpm\":" + String(MIN_BPM) + ",";
    json += "\"max_bpm\":" + String(MAX_BPM) + ",";
    json += "\"detection_threshold\":" + String(DETECTION_THRESHOLD) + ",";
    json += "\"confidence_threshold\":" + String(CONFIDENCE_THRESHOLD);
    json += "}";

    WebServer* srv = g_server;
    if (srv) {
        srv->send(200, "application/json", json);
    }
}

// Health Check Endpoint
void handleHealth() {
    String json = "{";
    json += "\"status\":\"ok\",";
    json += "\"uptime\":" + String(millis()) + ",";
    json += "\"heap\":" + String(ESP.getFreeHeap()) + ",";
    json += "\"wifi_connected\":" + String(WiFi.status() == WL_CONNECTED ? "true" : "false");
    json += "}";

    WebServer* srv = g_server;
    if (srv) {
        srv->send(200, "application/json", json);
    }
}

// WebSocket Handler (placeholder for real-time streaming)
void handleWebSocket() {
    WebServer* srv = g_server;
    if (srv) {
        srv->send(200, "application/json", "{\"websocket\":\"not_implemented\"}");
    }
}

// Monitor Management Endpoints
// Generated from ESP32-BPM monitor spawning prompt template

// List all monitors
void handleMonitorsList() {
    WebServer* srv = g_server;
    if (!srv) return;
    
    if (!g_monitorManager) {
        srv->send(500, "application/json", "{\"error\":\"Monitor manager not initialized\"}");
        return;
    }
    
    String json = "[";
    auto monitorIds = g_monitorManager->getMonitorIds();
    bool first = true;
    
    for (uint32_t id : monitorIds) {
        if (!first) json += ",";
        first = false;
        
        auto data = g_monitorManager->getMonitorData(id);
        String name = g_monitorManager->getMonitorName(id);
        bool active = g_monitorManager->isMonitorActive(id);
        
        json += "{";
        json += "\"id\":" + String(id) + ",";
        json += "\"name\":\"" + name + "\",";
        json += "\"active\":" + String(active ? "true" : "false") + ",";
        json += "\"bpm\":" + String(data.bpm, 1) + ",";
        json += "\"confidence\":" + String(data.confidence, 2) + ",";
        json += "\"status\":\"" + String(data.status) + "\"";
        json += "}";
    }
    
    json += "]";
    srv->send(200, "application/json", json);
}

// Get specific monitor data
void handleMonitorGet() {
    WebServer* srv = g_server;
    if (!srv) return;
    
    if (!g_monitorManager) {
        srv->send(500, "application/json", "{\"error\":\"Monitor manager not initialized\"}");
        return;
    }
    
    // Get monitor ID from query parameter
    String monitorIdStr = srv->arg("id");
    if (monitorIdStr.length() == 0) {
        srv->send(400, "application/json", "{\"error\":\"Missing monitor ID parameter\"}");
        return;
    }
    
    uint32_t monitorId = monitorIdStr.toInt();
    if (monitorId == 0) {
        srv->send(400, "application/json", "{\"error\":\"Invalid monitor ID\"}");
        return;
    }
    
    auto data = g_monitorManager->getMonitorData(monitorId);
    if (data.status == "not_found") {
        srv->send(404, "application/json", "{\"error\":\"Monitor not found\"}");
        return;
    }
    
    String name = g_monitorManager->getMonitorName(monitorId);
    bool active = g_monitorManager->isMonitorActive(monitorId);
    
    String json = "{";
    json += "\"id\":" + String(monitorId) + ",";
    json += "\"name\":\"" + name + "\",";
    json += "\"active\":" + String(active ? "true" : "false") + ",";
    json += "\"bpm\":" + String(data.bpm, 1) + ",";
    json += "\"confidence\":" + String(data.confidence, 2) + ",";
    json += "\"signal_level\":" + String(data.signal_level, 2) + ",";
    json += "\"status\":\"" + String(data.status) + "\",";
    json += "\"timestamp\":" + String(data.timestamp);
    json += "}";
    
    srv->send(200, "application/json", json);
}

// Spawn new monitor
void handleMonitorSpawn() {
    WebServer* srv = g_server;
    if (!srv) return;
    
    if (!g_monitorManager) {
        srv->send(500, "application/json", "{\"error\":\"Monitor manager not initialized\"}");
        return;
    }
    
    // Get name from request body or query parameter
    String name = srv->arg("name");
    if (name.length() == 0 && srv->hasArg("plain")) {
        // Try to parse JSON body
        String body = srv->arg("plain");
        // Simple JSON parsing for name field
        int nameStart = body.indexOf("\"name\"");
        if (nameStart >= 0) {
            int colonPos = body.indexOf(':', nameStart);
            int quoteStart = body.indexOf('"', colonPos);
            if (quoteStart >= 0) {
                int quoteEnd = body.indexOf('"', quoteStart + 1);
                if (quoteEnd > quoteStart) {
                    name = body.substring(quoteStart + 1, quoteEnd);
                }
            }
        }
    }
    
    uint32_t monitorId = g_monitorManager->spawnMonitor(name);
    if (monitorId == 0) {
        srv->send(500, "application/json", "{\"error\":\"Failed to spawn monitor\"}");
        return;
    }
    
    String json = "{";
    json += "\"id\":" + String(monitorId) + ",";
    json += "\"name\":\"" + g_monitorManager->getMonitorName(monitorId) + "\",";
    json += "\"status\":\"spawned\"";
    json += "}";
    
    srv->send(201, "application/json", json);
}

// Remove monitor
void handleMonitorRemove() {
    WebServer* srv = g_server;
    if (!srv) return;
    
    if (!g_monitorManager) {
        srv->send(500, "application/json", "{\"error\":\"Monitor manager not initialized\"}");
        return;
    }
    
    String monitorIdStr = srv->arg("id");
    if (monitorIdStr.length() == 0) {
        srv->send(400, "application/json", "{\"error\":\"Missing monitor ID parameter\"}");
        return;
    }
    
    uint32_t monitorId = monitorIdStr.toInt();
    if (monitorId == 0) {
        srv->send(400, "application/json", "{\"error\":\"Invalid monitor ID\"}");
        return;
    }
    
    bool removed = g_monitorManager->removeMonitor(monitorId);
    if (!removed) {
        srv->send(404, "application/json", "{\"error\":\"Monitor not found\"}");
        return;
    }
    
    srv->send(200, "application/json", "{\"status\":\"removed\",\"id\":" + String(monitorId) + "}");
}

// Update monitor (activate/deactivate)
void handleMonitorUpdate() {
    WebServer* srv = g_server;
    if (!srv) return;
    
    if (!g_monitorManager) {
        srv->send(500, "application/json", "{\"error\":\"Monitor manager not initialized\"}");
        return;
    }
    
    String monitorIdStr = srv->arg("id");
    if (monitorIdStr.length() == 0) {
        srv->send(400, "application/json", "{\"error\":\"Missing monitor ID parameter\"}");
        return;
    }
    
    uint32_t monitorId = monitorIdStr.toInt();
    if (monitorId == 0) {
        srv->send(400, "application/json", "{\"error\":\"Invalid monitor ID\"}");
        return;
    }
    
    // Get active status from query or body
    String activeStr = srv->arg("active");
    bool active = (activeStr == "true" || activeStr == "1");
    
    // Get name if provided
    String name = srv->arg("name");
    
    bool success = true;
    if (name.length() > 0) {
        success = g_monitorManager->setMonitorName(monitorId, name) && success;
    }
    success = g_monitorManager->setMonitorActive(monitorId, active) && success;
    
    if (!success) {
        srv->send(404, "application/json", "{\"error\":\"Monitor not found or update failed\"}");
        return;
    }
    
    String json = "{";
    json += "\"id\":" + String(monitorId) + ",";
    json += "\"active\":" + String(active ? "true" : "false") + ",";
    json += "\"status\":\"updated\"";
    json += "}";
    
    srv->send(200, "application/json", json);
}

/**
 * Initialize API Endpoints with dependency injection
 *
 * Sets up all REST endpoints for BPM data access
 */
void setupApiEndpoints(WebServer* server_instance, BPMDetector* detector) {
    setupApiEndpoints(server_instance, detector, nullptr);
}

/**
 * Initialize API Endpoints with monitor manager support
 *
 * Sets up all REST endpoints for BPM data access and monitor management
 * Generated from ESP32-BPM Android integration and monitor spawning prompts
 */
void setupApiEndpoints(WebServer* server_instance, BPMDetector* detector, sparetools::bpm::BPMMonitorManager* monitorManager) {
    if (server_instance == nullptr) {
        DEBUG_PRINTLN("[API] Error: WebServer instance is null");
        return;
    }
    
    // Store references for handlers
    g_server = server_instance;
    g_bpmDetector = detector;
    g_monitorManager = monitorManager;
    
    // BPM endpoints
    server_instance->on("/api/v1/bpm/current", HTTP_GET, handleBpmCurrent);
    server_instance->on("/api/v1/bpm/spectrum", HTTP_GET, handleBpmSpectrum);

    // System endpoints
    server_instance->on("/api/v1/system/status", HTTP_GET, handleSystemStatus);
    server_instance->on("/api/v1/system/config", HTTP_GET, handleConfiguration);
    server_instance->on("/api/v1/system/health", HTTP_GET, handleHealth);

    // Monitor management endpoints (if monitor manager is available)
    if (monitorManager) {
        server_instance->on("/api/v1/monitors", HTTP_GET, handleMonitorsList);
        server_instance->on("/api/v1/monitors/spawn", HTTP_POST, handleMonitorSpawn);
        server_instance->on("/api/v1/monitors/get", HTTP_GET, handleMonitorGet);
        server_instance->on("/api/v1/monitors/remove", HTTP_DELETE, handleMonitorRemove);
        server_instance->on("/api/v1/monitors/update", HTTP_PUT, handleMonitorUpdate);
    }

    // WebSocket endpoint (future)
    server_instance->on("/ws", HTTP_GET, handleWebSocket);

    DEBUG_PRINTLN("API endpoints initialized:");
    DEBUG_PRINTLN("  GET /api/v1/bpm/current - Current BPM data (FlatBuffers)");
    DEBUG_PRINTLN("  GET /api/v1/bpm/spectrum - Audio spectrum analysis");
    DEBUG_PRINTLN("  GET /api/v1/system/status - System status (FlatBuffers)");
    DEBUG_PRINTLN("  GET /api/v1/system/config - System configuration");
    DEBUG_PRINTLN("  GET /api/v1/system/health - Health check");
    if (monitorManager) {
        DEBUG_PRINTLN("  GET /api/v1/monitors - List all monitors");
        DEBUG_PRINTLN("  POST /api/v1/monitors/spawn - Spawn new monitor");
        DEBUG_PRINTLN("  GET /api/v1/monitors/get?id=X - Get monitor data");
        DEBUG_PRINTLN("  DELETE /api/v1/monitors/remove?id=X - Remove monitor");
        DEBUG_PRINTLN("  PUT /api/v1/monitors/update?id=X&active=true - Update monitor");
    }
}

/**
 * Legacy initialization (deprecated - requires dependency injection)
 * @deprecated Use setupApiEndpoints(WebServer*, BPMDetector*) instead
 */
void setupApiEndpoints() {
    DEBUG_PRINTLN("[API] Error: Legacy setupApiEndpoints() called - use dependency injection version");
    DEBUG_PRINTLN("[API] Call setupApiEndpoints(WebServer*, BPMDetector*) instead");
}
