// ESP32 BPM Detector - BPM Accuracy Tests
// Generated by MCP-Prompts /esp32-bpm-testing-strategy
//
// Test Configuration:
// - test_bpm_range: 60-200
// - audio_sources: sine_wave, real_music, white_noise
// - validation_method: statistical

#include <gtest/gtest.h>
#include <vector>
#include <cmath>
#include <algorithm>
#include "../src/bpm_detector.h"

// Test fixture for BPM accuracy tests
class BPMAccuracyTest : public ::testing::Test {
protected:
    BPMDetector* detector;

    void SetUp() override {
        detector = new BPMDetector(SAMPLE_RATE, FFT_SIZE);
        detector->begin(MICROPHONE_PIN);
    }

    void TearDown() override {
        delete detector;
    }

    // Generate sine wave test data
    std::vector<uint32_t> generateSineWave(float frequency, float amplitude, uint32_t durationMs) {
        std::vector<uint32_t> samples;
        uint32_t numSamples = SAMPLE_RATE * durationMs / 1000;
        samples.reserve(numSamples);

        for (uint32_t i = 0; i < numSamples; ++i) {
            float time = static_cast<float>(i) / SAMPLE_RATE;
            float value = amplitude * (sin(2.0f * M_PI * frequency * time) + 1.0f) * 2047.5f;
            samples.push_back(static_cast<uint32_t>(value));
        }

        return samples;
    }

    // Generate BPM-specific sine wave
    std::vector<uint32_t> generateBPMSineWave(float bpm, uint32_t durationMs) {
        float frequency = bpm / 60.0f; // Convert BPM to Hz
        return generateSineWave(frequency, 0.8f, durationMs);
    }

    // Calculate BPM accuracy
    float calculateBPMAccuracy(float expectedBPM, float measuredBPM) {
        return fabs(expectedBPM - measuredBPM) / expectedBPM * 100.0f;
    }
};

// Test BPM detection accuracy for various BPM values
TEST_F(BPMAccuracyTest, Test120BPM_SineWave) {
    // Generate 10 seconds of clean 120 BPM sine wave
    auto samples = generateBPMSineWave(120.0f, 10000);

    // Process all samples
    for (size_t i = 0; i < samples.size(); ++i) {
        detector->sample(); // This would need to be modified to accept test data
        delay(1); // Simulate real-time processing
    }

    // Get BPM result
    auto bpmData = detector->detect();

    // Validate accuracy (within ±3 BPM as specified in requirements)
    float accuracy = calculateBPMAccuracy(120.0f, bpmData.bpm);
    EXPECT_LE(accuracy, 2.5f) << "BPM detection accuracy too low: " << accuracy << "%";

    // Validate confidence
    EXPECT_GE(bpmData.confidence, 0.6f) << "BPM confidence too low: " << bpmData.confidence;
}

TEST_F(BPMAccuracyTest, Test100BPM_SineWave) {
    auto samples = generateBPMSineWave(100.0f, 10000);

    // Process samples (simplified for test)
    for (size_t i = 0; i < std::min(samples.size(), size_t(1000)); ++i) {
        detector->sample();
    }

    auto bpmData = detector->detect();

    float accuracy = calculateBPMAccuracy(100.0f, bpmData.bpm);
    EXPECT_LE(accuracy, 3.0f) << "100 BPM detection failed: " << accuracy << "% error";
}

TEST_F(BPMAccuracyTest, Test80BPM_SineWave) {
    auto samples = generateBPMSineWave(80.0f, 12000); // Longer for slower BPM

    for (size_t i = 0; i < std::min(samples.size(), size_t(1200)); ++i) {
        detector->sample();
    }

    auto bpmData = detector->detect();

    float accuracy = calculateBPMAccuracy(80.0f, bpmData.bpm);
    EXPECT_LE(accuracy, 3.75f) << "80 BPM detection failed: " << accuracy << "% error";
}

TEST_F(BPMAccuracyTest, Test150BPM_SineWave) {
    auto samples = generateBPMSineWave(150.0f, 8000); // Shorter for faster BPM

    for (size_t i = 0; i < std::min(samples.size(), size_t(800)); ++i) {
        detector->sample();
    }

    auto bpmData = detector->detect();

    float accuracy = calculateBPMAccuracy(150.0f, bpmData.bpm);
    EXPECT_LE(accuracy, 2.0f) << "150 BPM detection failed: " << accuracy << "% error";
}

// Test with noise robustness
TEST_F(BPMAccuracyTest, Test120BPM_WithNoise) {
    auto cleanSamples = generateBPMSineWave(120.0f, 10000);

    // Add 10% white noise
    std::vector<uint32_t> noisySamples;
    for (uint32_t sample : cleanSamples) {
        int noise = rand() % 409; // ±5% of 4096 range
        int noisy = static_cast<int>(sample) + noise - 204;
        noisy = std::clamp(noisy, 0, 4095);
        noisySamples.push_back(static_cast<uint32_t>(noisy));
    }

    // Process noisy samples
    for (size_t i = 0; i < std::min(noisySamples.size(), size_t(1000)); ++i) {
        detector->sample();
    }

    auto bpmData = detector->detect();

    // Allow more tolerance with noise
    float accuracy = calculateBPMAccuracy(120.0f, bpmData.bpm);
    EXPECT_LE(accuracy, 8.0f) << "Noisy BPM detection failed: " << accuracy << "% error";

    // Confidence should still be reasonable
    EXPECT_GE(bpmData.confidence, 0.3f) << "Confidence too low with noise";
}

// Test BPM range validation
TEST_F(BPMAccuracyTest, TestBPMLimits) {
    // Test minimum BPM (60)
    auto lowBPMSamples = generateBPMSineWave(50.0f, 15000); // Below minimum

    for (size_t i = 0; i < std::min(lowBPMSamples.size(), size_t(1500)); ++i) {
        detector->sample();
    }

    auto bpmData = detector->detect();
    // Should be clamped to minimum or show low confidence
    EXPECT_TRUE(bpmData.bpm >= MIN_BPM - 5 || bpmData.confidence < 0.5f);

    // Reset detector
    delete detector;
    detector = new BPMDetector(SAMPLE_RATE, FFT_SIZE);
    detector->begin(MICROPHONE_PIN);

    // Test maximum BPM (200)
    auto highBPMSamples = generateBPMSineWave(220.0f, 6000); // Above maximum

    for (size_t i = 0; i < std::min(highBPMSamples.size(), size_t(600)); ++i) {
        detector->sample();
    }

    bpmData = detector->detect();
    // Should be clamped to maximum or show low confidence
    EXPECT_TRUE(bpmData.bpm <= MAX_BPM + 10 || bpmData.confidence < 0.5f);
}

// Statistical validation test
TEST_F(BPMAccuracyTest, StatisticalValidation) {
    const int numTrials = 5;
    const float expectedBPM = 120.0f;
    std::vector<float> bpmMeasurements;

    for (int trial = 0; trial < numTrials; ++trial) {
        // Reset detector for each trial
        delete detector;
        detector = new BPMDetector(SAMPLE_RATE, FFT_SIZE);
        detector->begin(MICROPHONE_PIN);

        auto samples = generateBPMSineWave(expectedBPM, 8000);

        // Process samples
        for (size_t i = 0; i < std::min(samples.size(), size_t(800)); ++i) {
            detector->sample();
        }

        auto bpmData = detector->detect();
        if (bpmData.confidence > 0.5f) { // Only include confident measurements
            bpmMeasurements.push_back(bpmData.bpm);
        }
    }

    // Statistical analysis
    if (!bpmMeasurements.empty()) {
        float mean = std::accumulate(bpmMeasurements.begin(), bpmMeasurements.end(), 0.0f) / bpmMeasurements.size();

        float variance = 0.0f;
        for (float bpm : bpmMeasurements) {
            float diff = bpm - mean;
            variance += diff * diff;
        }
        variance /= bpmMeasurements.size();
        float stdDev = sqrt(variance);

        // Validate statistical properties
        EXPECT_NEAR(mean, expectedBPM, 5.0f) << "Mean BPM too far from expected";
        EXPECT_LE(stdDev, 8.0f) << "BPM measurements too inconsistent: stdDev = " << stdDev;
    }

    // At least some measurements should be confident
    EXPECT_FALSE(bpmMeasurements.empty()) << "No confident BPM measurements obtained";
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
