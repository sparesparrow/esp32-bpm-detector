import glob
import logging
import os
import re
import sys
from datetime import datetime, timezone
from pathlib import Path

from conan import ConanFile
from conan.tools.cmake import CMakeToolchain, CMakeDeps, CMake
from conan.tools.layout import basic_layout
from conan.tools.files import copy

FLATBUFFERS_DEC = """// automatically generated by extracting enums from BPM generated files

#pragma once

#include <cstdint>"""

ENUM_REGEX = r"\n+enum [A-Za-z_][A-Za-z_0-9 :{\n=,]*};"
NAMESPACE_REGEX = r"\nnamespace [a-zA-Z_][a-zA-Z_0-9]* {"
BPM_INCLUDE_REGEX = r"\n#include \"Bpm([\w]+)_generated\.h\""
BPM_INCLUDE_SUB_REGEX = "\n#include \"Bpm\\g<1>_extracted.h\""


class Esp32BpmDetectorConan(ConanFile):
    name = "sparetools-bpm-detector"
    version = "0.1.0"
    url = 'https://github.com/sparesparrow/esp32-bpm-detector'
    description = 'ESP32 BPM detector firmware with FlatBuffers protocol support'
    topics = ("esp32", "bpm", "detector", "embedded", "firmware")
    license = "Apache-2.0"

    # Use foundation packages from SpareTools ecosystem
    requires = [
        "flatbuffers/24.3.25",
    ]

    # Build tools - use system Python as fallback
    # Note: sparetools-cpython can be enabled via Cloudsmith remote if needed
    tool_requires = []

    # Export source files and schemas for protocol generation
    exports_sources = "schemas/*", "src/*", "include/*", "lib/*", "platformio.ini"

    # Options for different build configurations
    options = {
        "with_display": [True, False],
        "with_networking": [True, False],
        "with_websocket": [True, False],
        "with_audio_calibration": [True, False],
        "target_board": ["esp32", "esp32s2", "esp32s3", "esp32c3"],
    }

    default_options = {
        "with_display": True,
        "with_networking": True,
        "with_websocket": True,
        "with_audio_calibration": True,
        "target_board": "esp32s3",
    }

    fbs_files = Path('schemas')
    cpp_header_files = Path('include')

    @staticmethod
    def extract_header(file_path_str, header_file_name_str):
        file_path = Path(file_path_str)
        header_file_name = Path(header_file_name_str)

        with open(file_path, 'r') as file:
            content = file.read()

        bpm_header_matches = re.finditer(BPM_INCLUDE_REGEX, content)
        namespace_matches = re.finditer(NAMESPACE_REGEX, content)
        enum_matches = re.finditer(ENUM_REGEX, content)

        extracted_content = FLATBUFFERS_DEC + '\n'

        # Replace includes
        for match in bpm_header_matches:
            include = match.group()
            include = re.sub(BPM_INCLUDE_REGEX, BPM_INCLUDE_SUB_REGEX, include, 0, re.MULTILINE)
            extracted_content += include + '\n'

        extracted_content += '\n'

        # Add namespaces
        for namespace_matches_count, match in enumerate(namespace_matches, start=1):
            extracted_content += match.group() + '\n'

        extracted_content += '\nnamespace ExtEnum {\n'

        # Add enums
        for enum_matches_count, match in enumerate(enum_matches, start=1):
            extracted_content += match.group() + '\n'

        extracted_content += '\n}\n' * (namespace_matches_count + 1)

        header_file_name.parent.mkdir(parents=True, exist_ok=True)
        with open(header_file_name, 'w') as header_file:
            header_file.write(extracted_content)

    def layout(self):
        basic_layout(self)

    def generate(self):
        # Generate FlatBuffers headers for ESP32-specific protocols
        self.generate_cpp_headers()

        # Generate CMake toolchain (ESP32 uses PlatformIO, not CMake)
        tc = CMakeToolchain(self)
        tc.generate()

        # Note: CMakeDeps not needed for header-only packages

    def generate_cpp_headers(self):
        import subprocess

        print("Starting FlatBuffers header generation for ESP32 BPM detector...")

        # Find flatc executable
        flatc_paths = ['flatc', 'flatc.exe', '/usr/local/bin/flatc', '/usr/bin/flatc']
        flatc_cmd = None
        for path in flatc_paths:
            try:
                result = subprocess.run([path, '--version'], capture_output=True, text=True)
                if result.returncode == 0:
                    flatc_cmd = path
                    break
            except (FileNotFoundError, subprocess.SubprocessError):
                continue

        if not flatc_cmd:
            raise RuntimeError("Could not find flatc executable. Please install FlatBuffers compiler.")

        print(f"Found flatc at: {flatc_cmd}")

        # Ensure output directory exists
        self.cpp_header_files.mkdir(parents=True, exist_ok=True)
        print(f"Output directory: {self.cpp_header_files}")

        # Generate C++ headers for all .fbs files individually
        fbs_path = Path(self.source_folder) / self.fbs_files
        print(f"FBS path: {fbs_path}")
        print(f"FBS path exists: {fbs_path.exists()}")

        if not fbs_path.exists():
            # Try alternative paths for Conan 2.x
            alt_fbs_path = Path(self.build_folder) / self.fbs_files
            print(f"Trying alternative FBS path: {alt_fbs_path}")
            if alt_fbs_path.exists():
                fbs_path = alt_fbs_path

        fbs_files = list(fbs_path.glob('Bpm*.fbs'))
        print(f"Found {len(fbs_files)} FBS files: {[str(f) for f in fbs_files]}")

        for fbs_file in fbs_files:
            print(f"Processing {fbs_file}")
            cmd = [
                flatc_cmd,
                '--cpp',
                '-o', str(self.cpp_header_files),
                str(fbs_file)
            ]
            result = subprocess.run(cmd, cwd=Path('.'), capture_output=True, text=True)
            if result.returncode != 0:
                print(f"Error generating header for {fbs_file}: {result.stderr}")
                # Continue with other files even if one fails
                continue
            else:
                print(f"Successfully generated header for {fbs_file}")

        # Extract enums from each generated header
        generated_headers = list(self.cpp_header_files.glob('*_generated.h'))
        print(f"Found {len(generated_headers)} generated headers")

        for generated_cpp_header in generated_headers:
            extracted_name = generated_cpp_header.name.replace('_generated.h', '_extracted.h')
            extracted_path = self.cpp_header_files / extracted_name
            print(f"Extracting enums from {generated_cpp_header} to {extracted_path}")
            try:
                self.extract_header(str(generated_cpp_header), str(extracted_path))
                print(f"Successfully extracted enums to {extracted_path}")
            except Exception as e:
                print(f"Failed to extract enums from {generated_cpp_header}: {e}")

        print("FlatBuffers header generation completed.")

    def build(self):
        # Headers are generated in generate() step
        # For ESP32, actual building is done via PlatformIO, not CMake
        pass

    def package(self):
        # Copy generated headers to package
        conan_include = os.path.join(self.build_folder, "conan", "include")
        if os.path.exists(conan_include):
            copy(self, "*.h", src=conan_include, dst=os.path.join(self.package_folder, "include"))
        else:
            # Copy from the generated include directory
            if self.cpp_header_files.exists():
                copy(self, "*.h", src=str(self.cpp_header_files), dst=os.path.join(self.package_folder, "include"))

    def package_info(self):
        # ESP32 firmware provides generated headers
        self.cpp_info.libs = []
        self.cpp_info.includedirs = ["include"]

        # Set up environment for ESP32 development
        self.runenv_info.define("ESP32_BPM_DETECTOR_VERSION", self.version)
        self.runenv_info.define("ESP32_TARGET_BOARD", str(self.options.target_board))
