import glob
import logging
import os
import re
import sys
from datetime import datetime, timezone
from pathlib import Path

from conan import ConanFile
from conan.tools.cmake import CMakeToolchain, CMakeDeps, CMake
from conan.tools.layout import basic_layout
from conan.tools.files import copy

FLATBUFFERS_DEC = """// automatically generated by extracting enums from BPM generated files

#pragma once

#include <cstdint>"""

ENUM_REGEX = r"\n+enum [A-Za-z_][A-Za-z_0-9 :{\n=,]*};"
NAMESPACE_REGEX = r"\nnamespace [a-zA-Z_][a-zA-Z_0-9]* {"
BPM_INCLUDE_REGEX = r"\n#include \"Bpm([\w]+)_generated\.h\""
BPM_INCLUDE_SUB_REGEX = "\n#include \"Bpm\\g<1>_extracted.h\""


class BpmProtocolConan(ConanFile):
    name = "bpm-protocol"
    version = "0.1.0"
    url = 'https://github.com/sparrowsystems/esp32-bpm-detector'
    description = 'Conan package wrapping BPM detector FlatBuffers protocol'
    topics = ("flatbuffers", "bpm", "detector", "protocol")

    # Dependencies are described here.
    tool_requires = [
        "flatbuffers/24.3.25",
    ]

    requires = [
    ]

    # Export source files
    exports_sources = "schemas/*", "include/*"

    def layout(self):
        basic_layout(self)

    def generate(self):
        # Generate FlatBuffers headers
        self.generate_cpp_headers()

    fbs_files = Path('schemas')
    cpp_header_files = Path('include')

    @staticmethod
    def extract_header(file_path_str, header_file_name_str):
        file_path = Path(file_path_str)
        header_file_name = Path(header_file_name_str)

        with open(file_path, 'r') as file:
            content = file.read()

        bpm_header_matches = re.finditer(BPM_INCLUDE_REGEX, content)
        namespace_matches = re.finditer(NAMESPACE_REGEX, content)
        enum_matches = re.finditer(ENUM_REGEX, content)

        extracted_content = FLATBUFFERS_DEC + '\n'

        # Replace includes
        for match in bpm_header_matches:
            include = match.group()
            include = re.sub(BPM_INCLUDE_REGEX, BPM_INCLUDE_SUB_REGEX, include, 0, re.MULTILINE)
            extracted_content += include + '\n'

        extracted_content += '\n'

        # Add namespaces
        for namespace_matches_count, match in enumerate(namespace_matches, start=1):
            extracted_content += match.group() + '\n'

        extracted_content += '\nnamespace ExtEnum {\n'

        # Add enums
        for enum_matches_count, match in enumerate(enum_matches, start=1):
            extracted_content += match.group() + '\n'

        extracted_content += '\n}\n' * (namespace_matches_count + 1)

        header_file_name.parent.mkdir(parents=True, exist_ok=True)
        with open(header_file_name, 'w') as header_file:
            header_file.write(extracted_content)

    def generate_cpp_headers(self):
        import subprocess

        print("Starting FlatBuffers header generation...")

        # Find flatc executable
        flatc_paths = ['flatc', 'flatc.exe', '/usr/local/bin/flatc', '/usr/bin/flatc']
        flatc_cmd = None
        for path in flatc_paths:
            try:
                result = subprocess.run([path, '--version'], capture_output=True, text=True)
                if result.returncode == 0:
                    flatc_cmd = path
                    break
            except (FileNotFoundError, subprocess.SubprocessError):
                continue

        if not flatc_cmd:
            raise RuntimeError("Could not find flatc executable. Please install FlatBuffers compiler.")

        print(f"Found flatc at: {flatc_cmd}")

        # Ensure output directory exists
        self.cpp_header_files.mkdir(parents=True, exist_ok=True)
        print(f"Output directory: {self.cpp_header_files}")

        # Generate C++ headers for all .fbs files individually
        fbs_path = Path(self.source_folder) / self.fbs_files
        print(f"FBS path: {fbs_path}")
        print(f"FBS path exists: {fbs_path.exists()}")

        if not fbs_path.exists():
            # Try alternative paths for Conan 2.x
            alt_fbs_path = Path(self.build_folder) / self.fbs_files
            print(f"Trying alternative FBS path: {alt_fbs_path}")
            if alt_fbs_path.exists():
                fbs_path = alt_fbs_path

        fbs_files = list(fbs_path.glob('Bpm*.fbs'))
        print(f"Found {len(fbs_files)} FBS files: {[str(f) for f in fbs_files]}")

        for fbs_file in fbs_files:
            print(f"Processing {fbs_file}")
            cmd = [
                flatc_cmd,
                '--cpp',
                '-o', str(self.cpp_header_files),
                str(fbs_file)
            ]
            result = subprocess.run(cmd, cwd=Path('.'), capture_output=True, text=True)
            if result.returncode != 0:
                print(f"Error generating header for {fbs_file}: {result.stderr}")
                # Continue with other files even if one fails
                continue
            else:
                print(f"Successfully generated header for {fbs_file}")

        # Extract enums from each generated header
        generated_headers = list(self.cpp_header_files.glob('*_generated.h'))
        print(f"Found {len(generated_headers)} generated headers")

        for generated_cpp_header in generated_headers:
            extracted_name = generated_cpp_header.name.replace('_generated.h', '_extracted.h')
            extracted_path = self.cpp_header_files / extracted_name
            print(f"Extracting enums from {generated_cpp_header} to {extracted_path}")
            try:
                self.extract_header(str(generated_cpp_header), str(extracted_path))
                print(f"Successfully extracted enums to {extracted_path}")
            except Exception as e:
                print(f"Failed to extract enums from {generated_cpp_header}: {e}")

        print("FlatBuffers header generation completed.")

    def build(self):
        # Headers are generated in generate() step
        pass

    def package(self):
        import os
        # Copy generated headers to package - they are in the build/conan folder
        conan_include = os.path.join(self.build_folder, "conan", "include")
        if os.path.exists(conan_include):
            copy(self, "*.h", src=conan_include, dst=os.path.join(self.package_folder, "include"))
        else:
            # Fallback: look in the generators list
            for gen_path in self.generators:
                gen_include = os.path.join(gen_path, "include")
                if os.path.exists(gen_include):
                    copy(self, "*.h", src=gen_include, dst=os.path.join(self.package_folder, "include"))
                    break

    def package_info(self):
        self.cpp_info.libs = []
        self.cpp_info.includedirs = ["include"]
