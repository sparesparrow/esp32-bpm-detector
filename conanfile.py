import glob
import logging
import os
import re
import sys
from datetime import datetime, timezone
from pathlib import Path

from conan import ConanFile
from conan.tools.cmake import CMakeToolchain, CMakeDeps, CMake
from conan.tools.layout import basic_layout
from conan.tools.files import copy

FLATBUFFERS_DEC = """// automatically generated by extracting enums from BPM generated files

#pragma once

#include <cstdint>"""

ENUM_REGEX = r"\n+enum [A-Za-z_][A-Za-z_0-9 :{\n=,]*};"
NAMESPACE_REGEX = r"\nnamespace [a-zA-Z_][a-zA-Z_0-9]* {"
BPM_INCLUDE_REGEX = r"\n#include \"Bpm([\w]+)_generated\.h\""
BPM_INCLUDE_SUB_REGEX = "\n#include \"Bpm\\g<1>_extracted.h\""


class Esp32BpmDetectorConan(ConanFile):
    name = "sparetools-bpm-detector"
    version = "0.1.1"
    url = 'https://github.com/sparesparrow/esp32-bpm-detector'
    description = 'ESP32 BPM detector firmware with FlatBuffers protocol support'
    topics = ("esp32", "bpm", "detector", "embedded", "firmware")
    license = "Apache-2.0"

    # SpareTools ecosystem integration
    python_requires = "sparetools-base/2.0.3"

    # Runtime dependencies - use SpareTools packages
    requires = [
        "sparetools-flatbuffers/24.3.25",      # FlatBuffers runtime library
        "sparetools-mcp-core/1.0.1",          # MCP framework
        "sparetools-embedded/1.0.0",          # Embedded development tools
        "sparetools-hal-sunton/1.0.0",        # HAL for Sunton ESP32
        "sparetools-lvgl/8.3.11",             # LVGL graphics library
        "sparetools-protocols/1.0.0",         # Protocol definitions
    ]

    # Build-time tools - use SpareTools packages
    tool_requires = [
        "sparetools-cpython/3.12.7",           # Python interpreter for build scripts
        "sparetools-flatbuffers/24.3.25",      # FlatBuffers compiler
    ]

    # Export source files and schemas for protocol generation
    exports_sources = "schemas/*", "src/*", "include/*", "lib/*", "platformio.ini"

    # Options for different build configurations
    options = {
        "with_display": [True, False],
        "with_networking": [True, False],
        "with_websocket": [True, False],
        "with_audio_calibration": [True, False],
        "target_board": ["esp32", "esp32s2", "esp32s3", "esp32c3", "arduino_uno"],
    }

    default_options = {
        "with_display": True,
        "with_networking": True,
        "with_websocket": True,
        "with_audio_calibration": True,
        "target_board": "esp32s3",
    }

    fbs_files = Path('schemas')
    cpp_header_files = Path('include')

    @staticmethod
    def extract_header(file_path_str, header_file_name_str):
        file_path = Path(file_path_str)
        header_file_name = Path(header_file_name_str)

        with open(file_path, 'r') as file:
            content = file.read()

        bpm_header_matches = re.finditer(BPM_INCLUDE_REGEX, content)
        namespace_matches = re.finditer(NAMESPACE_REGEX, content)
        enum_matches = re.finditer(ENUM_REGEX, content)

        extracted_content = FLATBUFFERS_DEC + '\n'

        # Replace includes
        for match in bpm_header_matches:
            include = match.group()
            include = re.sub(BPM_INCLUDE_REGEX, BPM_INCLUDE_SUB_REGEX, include, 0, re.MULTILINE)
            extracted_content += include + '\n'

        extracted_content += '\n'

        # Add namespaces
        for namespace_matches_count, match in enumerate(namespace_matches, start=1):
            extracted_content += match.group() + '\n'

        extracted_content += '\nnamespace ExtEnum {\n'

        # Add enums
        for enum_matches_count, match in enumerate(enum_matches, start=1):
            extracted_content += match.group() + '\n'

        extracted_content += '\n}\n' * (namespace_matches_count + 1)

        header_file_name.parent.mkdir(parents=True, exist_ok=True)
        with open(header_file_name, 'w') as header_file:
            header_file.write(extracted_content)

    def layout(self):
        basic_layout(self)

    def generate(self):
        # Skip FlatBuffers for Arduino Uno (memory constraints)
        # Arduino Uno has only 32KB flash and 2KB RAM
        if str(self.options.target_board) != "arduino_uno":
            self.generate_cpp_headers()
        else:
            print("Skipping FlatBuffers generation for Arduino Uno (memory constraints)")

        # Generate CMake toolchain (ESP32 uses PlatformIO, not CMake)
        tc = CMakeToolchain(self)
        tc.generate()

        # Note: CMakeDeps not needed for header-only packages

    def generate_cpp_headers(self):
        import subprocess

        print("Starting FlatBuffers header generation for ESP32 BPM detector...")

        # Use SpareTools flatc (guaranteed to be in PATH via tool_requires)
        flatc_cmd = "flatc"

        # Verify SpareTools flatc is available
        try:
            result = subprocess.run([flatc_cmd, '--version'], capture_output=True, text=True, check=True)
            print(f"Using SpareTools flatc: {result.stdout.strip()}")
        except (subprocess.SubprocessError, FileNotFoundError) as e:
            raise RuntimeError(f"SpareTools flatc not found. Ensure sparetools-flatbuffers is properly installed: {e}")

        # Ensure output directory exists
        self.cpp_header_files.mkdir(parents=True, exist_ok=True)
        print(f"Output directory: {self.cpp_header_files}")

        # Generate C++ headers for all .fbs files individually
        fbs_path = Path(self.source_folder) / self.fbs_files
        print(f"FBS path: {fbs_path}")
        print(f"FBS path exists: {fbs_path.exists()}")

        if not fbs_path.exists():
            # Try alternative paths for Conan 2.x
            alt_fbs_path = Path(self.build_folder) / self.fbs_files
            print(f"Trying alternative FBS path: {alt_fbs_path}")
            if alt_fbs_path.exists():
                fbs_path = alt_fbs_path

        fbs_files = list(fbs_path.glob('Bpm*.fbs'))
        print(f"Found {len(fbs_files)} FBS files: {[str(f) for f in fbs_files]}")

        for fbs_file in fbs_files:
            print(f"Processing {fbs_file}")
            cmd = [
                flatc_cmd,
                '--cpp',
                '-o', str(self.cpp_header_files),
                str(fbs_file)
            ]
            result = subprocess.run(cmd, cwd=Path('.'), capture_output=True, text=True)
            if result.returncode != 0:
                print(f"Error generating header for {fbs_file}: {result.stderr}")
                # Continue with other files even if one fails
                continue
            else:
                print(f"Successfully generated header for {fbs_file}")

        # Extract enums from each generated header
        generated_headers = list(self.cpp_header_files.glob('*_generated.h'))
        print(f"Found {len(generated_headers)} generated headers")

        for generated_cpp_header in generated_headers:
            extracted_name = generated_cpp_header.name.replace('_generated.h', '_extracted.h')
            extracted_path = self.cpp_header_files / extracted_name
            print(f"Extracting enums from {generated_cpp_header} to {extracted_path}")
            try:
                self.extract_header(str(generated_cpp_header), str(extracted_path))
                print(f"Successfully extracted enums to {extracted_path}")
            except Exception as e:
                print(f"Failed to extract enums from {generated_cpp_header}: {e}")

        print("FlatBuffers header generation completed.")

    def build(self):
        # Headers are generated in generate() step
        # For ESP32, actual building is done via PlatformIO, not CMake
        pass

    def package(self):
        # Copy generated headers to package
        conan_include = os.path.join(self.build_folder, "conan", "include")
        if os.path.exists(conan_include):
            copy(self, "*.h", src=conan_include, dst=os.path.join(self.package_folder, "include"))
        else:
            # Copy from the generated include directory
            if self.cpp_header_files.exists():
                copy(self, "*.h", src=str(self.cpp_header_files), dst=os.path.join(self.package_folder, "include"))

    def package_info(self):
        # ESP32 firmware provides generated headers
        self.cpp_info.libs = []
        self.cpp_info.includedirs = ["include"]

        # Set up environment for ESP32 development
        self.runenv_info.define("ESP32_BPM_DETECTOR_VERSION", self.version)
        self.runenv_info.define("ESP32_TARGET_BOARD", str(self.options.target_board))
