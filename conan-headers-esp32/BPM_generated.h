// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BPM_SPARESPARROW_BPM_H_
#define FLATBUFFERS_GENERATED_BPM_SPARESPARROW_BPM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "common_generated.h"

namespace sparesparrow {
namespace bpm {

struct Header;
struct HeaderBuilder;

struct GetStatusRequest;
struct GetStatusRequestBuilder;

struct GetConfigRequest;
struct GetConfigRequestBuilder;

struct SetConfigRequest;
struct SetConfigRequestBuilder;

struct ResetDeviceRequest;
struct ResetDeviceRequestBuilder;

struct CalibrateAudioRequest;
struct CalibrateAudioRequestBuilder;

struct StartStreamingRequest;
struct StartStreamingRequestBuilder;

struct StopStreamingRequest;
struct StopStreamingRequestBuilder;

struct GetDiagnosticsRequest;
struct GetDiagnosticsRequestBuilder;

struct Request;
struct RequestBuilder;

struct GetStatusResponse;
struct GetStatusResponseBuilder;

struct GetConfigResponse;
struct GetConfigResponseBuilder;

struct SetConfigResponse;
struct SetConfigResponseBuilder;

struct ResetDeviceResponse;
struct ResetDeviceResponseBuilder;

struct CalibrateAudioResponse;
struct CalibrateAudioResponseBuilder;

struct StartStreamingResponse;
struct StartStreamingResponseBuilder;

struct StopStreamingResponse;
struct StopStreamingResponseBuilder;

struct GetDiagnosticsResponse;
struct GetDiagnosticsResponseBuilder;

struct Status;
struct StatusBuilder;

struct Response;
struct ResponseBuilder;

struct BPMUpdate;
struct BPMUpdateBuilder;

struct StatusUpdate;
struct StatusUpdateBuilder;

struct ErrorReport;
struct ErrorReportBuilder;

struct BPMAnalysis;
struct BPMAnalysisBuilder;

struct BPMQuality;
struct BPMQualityBuilder;

struct AudioStatus;
struct AudioStatusBuilder;

struct AudioCalibrationData;
struct AudioCalibrationDataBuilder;

struct ConfigUpdate;
struct ConfigUpdateBuilder;

struct BPMConfig;
struct BPMConfigBuilder;

struct AudioConfig;
struct AudioConfigBuilder;

struct NetworkConfig;
struct NetworkConfigBuilder;

struct DisplayConfig;
struct DisplayConfigBuilder;

struct DiagnosticsData;
struct DiagnosticsDataBuilder;

struct SystemInfo;
struct SystemInfoBuilder;

struct AudioDiagnostics;
struct AudioDiagnosticsBuilder;

struct NetworkDiagnostics;
struct NetworkDiagnosticsBuilder;

struct PerformanceMetrics;
struct PerformanceMetricsBuilder;

enum class DetectionStatus : int8_t {
  INITIALIZING = 0,
  DETECTING = 1,
  LOW_SIGNAL = 2,
  NO_SIGNAL = 3,
  ERROR = 4,
  CALIBRATING = 5,
  MIN = INITIALIZING,
  MAX = CALIBRATING
};

inline const DetectionStatus (&EnumValuesDetectionStatus())[6] {
  static const DetectionStatus values[] = {
    DetectionStatus::INITIALIZING,
    DetectionStatus::DETECTING,
    DetectionStatus::LOW_SIGNAL,
    DetectionStatus::NO_SIGNAL,
    DetectionStatus::ERROR,
    DetectionStatus::CALIBRATING
  };
  return values;
}

inline const char * const *EnumNamesDetectionStatus() {
  static const char * const names[7] = {
    "INITIALIZING",
    "DETECTING",
    "LOW_SIGNAL",
    "NO_SIGNAL",
    "ERROR",
    "CALIBRATING",
    nullptr
  };
  return names;
}

inline const char *EnumNameDetectionStatus(DetectionStatus e) {
  if (::flatbuffers::IsOutRange(e, DetectionStatus::INITIALIZING, DetectionStatus::CALIBRATING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDetectionStatus()[index];
}

enum class DisplayType : int8_t {
  NONE = 0,
  OLED_SSD1306 = 1,
  TM1637_7SEGMENT = 2,
  BOTH = 3,
  MIN = NONE,
  MAX = BOTH
};

inline const DisplayType (&EnumValuesDisplayType())[4] {
  static const DisplayType values[] = {
    DisplayType::NONE,
    DisplayType::OLED_SSD1306,
    DisplayType::TM1637_7SEGMENT,
    DisplayType::BOTH
  };
  return values;
}

inline const char * const *EnumNamesDisplayType() {
  static const char * const names[5] = {
    "NONE",
    "OLED_SSD1306",
    "TM1637_7SEGMENT",
    "BOTH",
    nullptr
  };
  return names;
}

inline const char *EnumNameDisplayType(DisplayType e) {
  if (::flatbuffers::IsOutRange(e, DisplayType::NONE, DisplayType::BOTH)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDisplayType()[index];
}

enum class ErrorCode : uint16_t {
  UNKNOWN_ERROR = 0,
  AUDIO_INIT_FAILED = 100,
  AUDIO_BUFFER_OVERFLOW = 101,
  AUDIO_BUFFER_UNDERFLOW = 102,
  MICROPHONE_NOT_FOUND = 103,
  BPM_DETECTION_FAILED = 200,
  LOW_SIGNAL_QUALITY = 201,
  BPM_OUT_OF_RANGE = 202,
  WIFI_CONNECTION_FAILED = 300,
  WEBSERVER_INIT_FAILED = 301,
  WEBSOCKET_ERROR = 302,
  DISPLAY_INIT_FAILED = 400,
  DISPLAY_COMM_ERROR = 401,
  MEMORY_ALLOCATION_FAILED = 500,
  WATCHDOG_RESET = 501,
  POWER_SUPPLY_ERROR = 502,
  INVALID_CONFIG = 600,
  CONFIG_SAVE_FAILED = 601,
  MIN = UNKNOWN_ERROR,
  MAX = CONFIG_SAVE_FAILED
};

inline const ErrorCode (&EnumValuesErrorCode())[18] {
  static const ErrorCode values[] = {
    ErrorCode::UNKNOWN_ERROR,
    ErrorCode::AUDIO_INIT_FAILED,
    ErrorCode::AUDIO_BUFFER_OVERFLOW,
    ErrorCode::AUDIO_BUFFER_UNDERFLOW,
    ErrorCode::MICROPHONE_NOT_FOUND,
    ErrorCode::BPM_DETECTION_FAILED,
    ErrorCode::LOW_SIGNAL_QUALITY,
    ErrorCode::BPM_OUT_OF_RANGE,
    ErrorCode::WIFI_CONNECTION_FAILED,
    ErrorCode::WEBSERVER_INIT_FAILED,
    ErrorCode::WEBSOCKET_ERROR,
    ErrorCode::DISPLAY_INIT_FAILED,
    ErrorCode::DISPLAY_COMM_ERROR,
    ErrorCode::MEMORY_ALLOCATION_FAILED,
    ErrorCode::WATCHDOG_RESET,
    ErrorCode::POWER_SUPPLY_ERROR,
    ErrorCode::INVALID_CONFIG,
    ErrorCode::CONFIG_SAVE_FAILED
  };
  return values;
}

inline const char *EnumNameErrorCode(ErrorCode e) {
  switch (e) {
    case ErrorCode::UNKNOWN_ERROR: return "UNKNOWN_ERROR";
    case ErrorCode::AUDIO_INIT_FAILED: return "AUDIO_INIT_FAILED";
    case ErrorCode::AUDIO_BUFFER_OVERFLOW: return "AUDIO_BUFFER_OVERFLOW";
    case ErrorCode::AUDIO_BUFFER_UNDERFLOW: return "AUDIO_BUFFER_UNDERFLOW";
    case ErrorCode::MICROPHONE_NOT_FOUND: return "MICROPHONE_NOT_FOUND";
    case ErrorCode::BPM_DETECTION_FAILED: return "BPM_DETECTION_FAILED";
    case ErrorCode::LOW_SIGNAL_QUALITY: return "LOW_SIGNAL_QUALITY";
    case ErrorCode::BPM_OUT_OF_RANGE: return "BPM_OUT_OF_RANGE";
    case ErrorCode::WIFI_CONNECTION_FAILED: return "WIFI_CONNECTION_FAILED";
    case ErrorCode::WEBSERVER_INIT_FAILED: return "WEBSERVER_INIT_FAILED";
    case ErrorCode::WEBSOCKET_ERROR: return "WEBSOCKET_ERROR";
    case ErrorCode::DISPLAY_INIT_FAILED: return "DISPLAY_INIT_FAILED";
    case ErrorCode::DISPLAY_COMM_ERROR: return "DISPLAY_COMM_ERROR";
    case ErrorCode::MEMORY_ALLOCATION_FAILED: return "MEMORY_ALLOCATION_FAILED";
    case ErrorCode::WATCHDOG_RESET: return "WATCHDOG_RESET";
    case ErrorCode::POWER_SUPPLY_ERROR: return "POWER_SUPPLY_ERROR";
    case ErrorCode::INVALID_CONFIG: return "INVALID_CONFIG";
    case ErrorCode::CONFIG_SAVE_FAILED: return "CONFIG_SAVE_FAILED";
    default: return "";
  }
}

enum class ErrorSeverity : int8_t {
  INFO = 0,
  WARNING = 1,
  ERROR = 2,
  CRITICAL = 3,
  MIN = INFO,
  MAX = CRITICAL
};

inline const ErrorSeverity (&EnumValuesErrorSeverity())[4] {
  static const ErrorSeverity values[] = {
    ErrorSeverity::INFO,
    ErrorSeverity::WARNING,
    ErrorSeverity::ERROR,
    ErrorSeverity::CRITICAL
  };
  return values;
}

inline const char * const *EnumNamesErrorSeverity() {
  static const char * const names[5] = {
    "INFO",
    "WARNING",
    "ERROR",
    "CRITICAL",
    nullptr
  };
  return names;
}

inline const char *EnumNameErrorSeverity(ErrorSeverity e) {
  if (::flatbuffers::IsOutRange(e, ErrorSeverity::INFO, ErrorSeverity::CRITICAL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesErrorSeverity()[index];
}

enum class RequestType : int8_t {
  GET_STATUS = 0,
  GET_CONFIG = 1,
  SET_CONFIG = 2,
  RESET_DEVICE = 3,
  CALIBRATE_AUDIO = 4,
  START_STREAMING = 5,
  STOP_STREAMING = 6,
  GET_DIAGNOSTICS = 7,
  MIN = GET_STATUS,
  MAX = GET_DIAGNOSTICS
};

inline const RequestType (&EnumValuesRequestType())[8] {
  static const RequestType values[] = {
    RequestType::GET_STATUS,
    RequestType::GET_CONFIG,
    RequestType::SET_CONFIG,
    RequestType::RESET_DEVICE,
    RequestType::CALIBRATE_AUDIO,
    RequestType::START_STREAMING,
    RequestType::STOP_STREAMING,
    RequestType::GET_DIAGNOSTICS
  };
  return values;
}

inline const char * const *EnumNamesRequestType() {
  static const char * const names[9] = {
    "GET_STATUS",
    "GET_CONFIG",
    "SET_CONFIG",
    "RESET_DEVICE",
    "CALIBRATE_AUDIO",
    "START_STREAMING",
    "STOP_STREAMING",
    "GET_DIAGNOSTICS",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestType(RequestType e) {
  if (::flatbuffers::IsOutRange(e, RequestType::GET_STATUS, RequestType::GET_DIAGNOSTICS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestType()[index];
}

enum class StatusEnum : int32_t {
  Success = 0,
  InvalidRequest = 1,
  MalformedMessage = 2,
  InvalidConfig = 3,
  DeviceBusy = 4,
  NotSupported = 5,
  MIN = Success,
  MAX = NotSupported
};

inline const StatusEnum (&EnumValuesStatusEnum())[6] {
  static const StatusEnum values[] = {
    StatusEnum::Success,
    StatusEnum::InvalidRequest,
    StatusEnum::MalformedMessage,
    StatusEnum::InvalidConfig,
    StatusEnum::DeviceBusy,
    StatusEnum::NotSupported
  };
  return values;
}

inline const char * const *EnumNamesStatusEnum() {
  static const char * const names[7] = {
    "Success",
    "InvalidRequest",
    "MalformedMessage",
    "InvalidConfig",
    "DeviceBusy",
    "NotSupported",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatusEnum(StatusEnum e) {
  if (::flatbuffers::IsOutRange(e, StatusEnum::Success, StatusEnum::NotSupported)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatusEnum()[index];
}

enum class StreamType : int8_t {
  WEBSOCKET = 0,
  UDP_MULTICAST = 1,
  TCP_UNICAST = 2,
  MIN = WEBSOCKET,
  MAX = TCP_UNICAST
};

inline const StreamType (&EnumValuesStreamType())[3] {
  static const StreamType values[] = {
    StreamType::WEBSOCKET,
    StreamType::UDP_MULTICAST,
    StreamType::TCP_UNICAST
  };
  return values;
}

inline const char * const *EnumNamesStreamType() {
  static const char * const names[4] = {
    "WEBSOCKET",
    "UDP_MULTICAST",
    "TCP_UNICAST",
    nullptr
  };
  return names;
}

inline const char *EnumNameStreamType(StreamType e) {
  if (::flatbuffers::IsOutRange(e, StreamType::WEBSOCKET, StreamType::TCP_UNICAST)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStreamType()[index];
}

enum class RequestPayload : uint8_t {
  NONE = 0,
  GetStatusRequest = 1,
  GetConfigRequest = 2,
  SetConfigRequest = 3,
  ResetDeviceRequest = 4,
  CalibrateAudioRequest = 5,
  StartStreamingRequest = 6,
  StopStreamingRequest = 7,
  GetDiagnosticsRequest = 8,
  MIN = NONE,
  MAX = GetDiagnosticsRequest
};

inline const RequestPayload (&EnumValuesRequestPayload())[9] {
  static const RequestPayload values[] = {
    RequestPayload::NONE,
    RequestPayload::GetStatusRequest,
    RequestPayload::GetConfigRequest,
    RequestPayload::SetConfigRequest,
    RequestPayload::ResetDeviceRequest,
    RequestPayload::CalibrateAudioRequest,
    RequestPayload::StartStreamingRequest,
    RequestPayload::StopStreamingRequest,
    RequestPayload::GetDiagnosticsRequest
  };
  return values;
}

inline const char * const *EnumNamesRequestPayload() {
  static const char * const names[10] = {
    "NONE",
    "GetStatusRequest",
    "GetConfigRequest",
    "SetConfigRequest",
    "ResetDeviceRequest",
    "CalibrateAudioRequest",
    "StartStreamingRequest",
    "StopStreamingRequest",
    "GetDiagnosticsRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestPayload(RequestPayload e) {
  if (::flatbuffers::IsOutRange(e, RequestPayload::NONE, RequestPayload::GetDiagnosticsRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestPayload()[index];
}

template<typename T> struct RequestPayloadTraits {
  static const RequestPayload enum_value = RequestPayload::NONE;
};

template<> struct RequestPayloadTraits<sparesparrow::bpm::GetStatusRequest> {
  static const RequestPayload enum_value = RequestPayload::GetStatusRequest;
};

template<> struct RequestPayloadTraits<sparesparrow::bpm::GetConfigRequest> {
  static const RequestPayload enum_value = RequestPayload::GetConfigRequest;
};

template<> struct RequestPayloadTraits<sparesparrow::bpm::SetConfigRequest> {
  static const RequestPayload enum_value = RequestPayload::SetConfigRequest;
};

template<> struct RequestPayloadTraits<sparesparrow::bpm::ResetDeviceRequest> {
  static const RequestPayload enum_value = RequestPayload::ResetDeviceRequest;
};

template<> struct RequestPayloadTraits<sparesparrow::bpm::CalibrateAudioRequest> {
  static const RequestPayload enum_value = RequestPayload::CalibrateAudioRequest;
};

template<> struct RequestPayloadTraits<sparesparrow::bpm::StartStreamingRequest> {
  static const RequestPayload enum_value = RequestPayload::StartStreamingRequest;
};

template<> struct RequestPayloadTraits<sparesparrow::bpm::StopStreamingRequest> {
  static const RequestPayload enum_value = RequestPayload::StopStreamingRequest;
};

template<> struct RequestPayloadTraits<sparesparrow::bpm::GetDiagnosticsRequest> {
  static const RequestPayload enum_value = RequestPayload::GetDiagnosticsRequest;
};

bool VerifyRequestPayload(::flatbuffers::Verifier &verifier, const void *obj, RequestPayload type);
bool VerifyRequestPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<RequestPayload> *types);

enum class ResponsePayload : uint8_t {
  NONE = 0,
  GetStatusResponse = 1,
  GetConfigResponse = 2,
  SetConfigResponse = 3,
  ResetDeviceResponse = 4,
  CalibrateAudioResponse = 5,
  StartStreamingResponse = 6,
  StopStreamingResponse = 7,
  GetDiagnosticsResponse = 8,
  MIN = NONE,
  MAX = GetDiagnosticsResponse
};

inline const ResponsePayload (&EnumValuesResponsePayload())[9] {
  static const ResponsePayload values[] = {
    ResponsePayload::NONE,
    ResponsePayload::GetStatusResponse,
    ResponsePayload::GetConfigResponse,
    ResponsePayload::SetConfigResponse,
    ResponsePayload::ResetDeviceResponse,
    ResponsePayload::CalibrateAudioResponse,
    ResponsePayload::StartStreamingResponse,
    ResponsePayload::StopStreamingResponse,
    ResponsePayload::GetDiagnosticsResponse
  };
  return values;
}

inline const char * const *EnumNamesResponsePayload() {
  static const char * const names[10] = {
    "NONE",
    "GetStatusResponse",
    "GetConfigResponse",
    "SetConfigResponse",
    "ResetDeviceResponse",
    "CalibrateAudioResponse",
    "StartStreamingResponse",
    "StopStreamingResponse",
    "GetDiagnosticsResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameResponsePayload(ResponsePayload e) {
  if (::flatbuffers::IsOutRange(e, ResponsePayload::NONE, ResponsePayload::GetDiagnosticsResponse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResponsePayload()[index];
}

template<typename T> struct ResponsePayloadTraits {
  static const ResponsePayload enum_value = ResponsePayload::NONE;
};

template<> struct ResponsePayloadTraits<sparesparrow::bpm::GetStatusResponse> {
  static const ResponsePayload enum_value = ResponsePayload::GetStatusResponse;
};

template<> struct ResponsePayloadTraits<sparesparrow::bpm::GetConfigResponse> {
  static const ResponsePayload enum_value = ResponsePayload::GetConfigResponse;
};

template<> struct ResponsePayloadTraits<sparesparrow::bpm::SetConfigResponse> {
  static const ResponsePayload enum_value = ResponsePayload::SetConfigResponse;
};

template<> struct ResponsePayloadTraits<sparesparrow::bpm::ResetDeviceResponse> {
  static const ResponsePayload enum_value = ResponsePayload::ResetDeviceResponse;
};

template<> struct ResponsePayloadTraits<sparesparrow::bpm::CalibrateAudioResponse> {
  static const ResponsePayload enum_value = ResponsePayload::CalibrateAudioResponse;
};

template<> struct ResponsePayloadTraits<sparesparrow::bpm::StartStreamingResponse> {
  static const ResponsePayload enum_value = ResponsePayload::StartStreamingResponse;
};

template<> struct ResponsePayloadTraits<sparesparrow::bpm::StopStreamingResponse> {
  static const ResponsePayload enum_value = ResponsePayload::StopStreamingResponse;
};

template<> struct ResponsePayloadTraits<sparesparrow::bpm::GetDiagnosticsResponse> {
  static const ResponsePayload enum_value = ResponsePayload::GetDiagnosticsResponse;
};

bool VerifyResponsePayload(::flatbuffers::Verifier &verifier, const void *obj, ResponsePayload type);
bool VerifyResponsePayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ResponsePayload> *types);

struct Header FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4
  };
  int32_t version() const {
    return GetField<int32_t>(VT_VERSION, 1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VERSION, 4) &&
           verifier.EndTable();
  }
};

struct HeaderBuilder {
  typedef Header Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(Header::VT_VERSION, version, 1);
  }
  explicit HeaderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Header> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Header>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Header> CreateHeader(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t version = 1) {
  HeaderBuilder builder_(_fbb);
  builder_.add_version(version);
  return builder_.Finish();
}

struct GetStatusRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetStatusRequestBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GetStatusRequestBuilder {
  typedef GetStatusRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit GetStatusRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetStatusRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetStatusRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetStatusRequest> CreateGetStatusRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  GetStatusRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GetConfigRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetConfigRequestBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GetConfigRequestBuilder {
  typedef GetConfigRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit GetConfigRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetConfigRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetConfigRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetConfigRequest> CreateGetConfigRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  GetConfigRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SetConfigRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetConfigRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONFIG = 4
  };
  const sparesparrow::bpm::ConfigUpdate *config() const {
    return GetPointer<const sparesparrow::bpm::ConfigUpdate *>(VT_CONFIG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           verifier.VerifyTable(config()) &&
           verifier.EndTable();
  }
};

struct SetConfigRequestBuilder {
  typedef SetConfigRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_config(::flatbuffers::Offset<sparesparrow::bpm::ConfigUpdate> config) {
    fbb_.AddOffset(SetConfigRequest::VT_CONFIG, config);
  }
  explicit SetConfigRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetConfigRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetConfigRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetConfigRequest> CreateSetConfigRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<sparesparrow::bpm::ConfigUpdate> config = 0) {
  SetConfigRequestBuilder builder_(_fbb);
  builder_.add_config(config);
  return builder_.Finish();
}

struct ResetDeviceRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResetDeviceRequestBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ResetDeviceRequestBuilder {
  typedef ResetDeviceRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ResetDeviceRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResetDeviceRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResetDeviceRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResetDeviceRequest> CreateResetDeviceRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ResetDeviceRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CalibrateAudioRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CalibrateAudioRequestBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CalibrateAudioRequestBuilder {
  typedef CalibrateAudioRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit CalibrateAudioRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CalibrateAudioRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CalibrateAudioRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CalibrateAudioRequest> CreateCalibrateAudioRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  CalibrateAudioRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct StartStreamingRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StartStreamingRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_TYPE = 4,
    VT_CLIENT_ID = 6,
    VT_DESTINATION = 8
  };
  sparesparrow::bpm::StreamType stream_type() const {
    return static_cast<sparesparrow::bpm::StreamType>(GetField<int8_t>(VT_STREAM_TYPE, 0));
  }
  const ::flatbuffers::String *client_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLIENT_ID);
  }
  const ::flatbuffers::String *destination() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESTINATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STREAM_TYPE, 1) &&
           VerifyOffset(verifier, VT_CLIENT_ID) &&
           verifier.VerifyString(client_id()) &&
           VerifyOffset(verifier, VT_DESTINATION) &&
           verifier.VerifyString(destination()) &&
           verifier.EndTable();
  }
};

struct StartStreamingRequestBuilder {
  typedef StartStreamingRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_stream_type(sparesparrow::bpm::StreamType stream_type) {
    fbb_.AddElement<int8_t>(StartStreamingRequest::VT_STREAM_TYPE, static_cast<int8_t>(stream_type), 0);
  }
  void add_client_id(::flatbuffers::Offset<::flatbuffers::String> client_id) {
    fbb_.AddOffset(StartStreamingRequest::VT_CLIENT_ID, client_id);
  }
  void add_destination(::flatbuffers::Offset<::flatbuffers::String> destination) {
    fbb_.AddOffset(StartStreamingRequest::VT_DESTINATION, destination);
  }
  explicit StartStreamingRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StartStreamingRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StartStreamingRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StartStreamingRequest> CreateStartStreamingRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    sparesparrow::bpm::StreamType stream_type = sparesparrow::bpm::StreamType::WEBSOCKET,
    ::flatbuffers::Offset<::flatbuffers::String> client_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> destination = 0) {
  StartStreamingRequestBuilder builder_(_fbb);
  builder_.add_destination(destination);
  builder_.add_client_id(client_id);
  builder_.add_stream_type(stream_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StartStreamingRequest> CreateStartStreamingRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    sparesparrow::bpm::StreamType stream_type = sparesparrow::bpm::StreamType::WEBSOCKET,
    const char *client_id = nullptr,
    const char *destination = nullptr) {
  auto client_id__ = client_id ? _fbb.CreateString(client_id) : 0;
  auto destination__ = destination ? _fbb.CreateString(destination) : 0;
  return sparesparrow::bpm::CreateStartStreamingRequest(
      _fbb,
      stream_type,
      client_id__,
      destination__);
}

struct StopStreamingRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StopStreamingRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENT_ID = 4
  };
  const ::flatbuffers::String *client_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLIENT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLIENT_ID) &&
           verifier.VerifyString(client_id()) &&
           verifier.EndTable();
  }
};

struct StopStreamingRequestBuilder {
  typedef StopStreamingRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_client_id(::flatbuffers::Offset<::flatbuffers::String> client_id) {
    fbb_.AddOffset(StopStreamingRequest::VT_CLIENT_ID, client_id);
  }
  explicit StopStreamingRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StopStreamingRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StopStreamingRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StopStreamingRequest> CreateStopStreamingRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> client_id = 0) {
  StopStreamingRequestBuilder builder_(_fbb);
  builder_.add_client_id(client_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StopStreamingRequest> CreateStopStreamingRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *client_id = nullptr) {
  auto client_id__ = client_id ? _fbb.CreateString(client_id) : 0;
  return sparesparrow::bpm::CreateStopStreamingRequest(
      _fbb,
      client_id__);
}

struct GetDiagnosticsRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetDiagnosticsRequestBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GetDiagnosticsRequestBuilder {
  typedef GetDiagnosticsRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit GetDiagnosticsRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetDiagnosticsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetDiagnosticsRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetDiagnosticsRequest> CreateGetDiagnosticsRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  GetDiagnosticsRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Request FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_REQUEST_TYPE = 6,
    VT_DATA_TYPE = 8,
    VT_DATA = 10
  };
  const sparesparrow::bpm::Header *header() const {
    return GetPointer<const sparesparrow::bpm::Header *>(VT_HEADER);
  }
  sparesparrow::bpm::RequestType request_type() const {
    return static_cast<sparesparrow::bpm::RequestType>(GetField<int8_t>(VT_REQUEST_TYPE, 0));
  }
  sparesparrow::bpm::RequestPayload data_type() const {
    return static_cast<sparesparrow::bpm::RequestPayload>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const sparesparrow::bpm::GetStatusRequest *data_as_GetStatusRequest() const {
    return data_type() == sparesparrow::bpm::RequestPayload::GetStatusRequest ? static_cast<const sparesparrow::bpm::GetStatusRequest *>(data()) : nullptr;
  }
  const sparesparrow::bpm::GetConfigRequest *data_as_GetConfigRequest() const {
    return data_type() == sparesparrow::bpm::RequestPayload::GetConfigRequest ? static_cast<const sparesparrow::bpm::GetConfigRequest *>(data()) : nullptr;
  }
  const sparesparrow::bpm::SetConfigRequest *data_as_SetConfigRequest() const {
    return data_type() == sparesparrow::bpm::RequestPayload::SetConfigRequest ? static_cast<const sparesparrow::bpm::SetConfigRequest *>(data()) : nullptr;
  }
  const sparesparrow::bpm::ResetDeviceRequest *data_as_ResetDeviceRequest() const {
    return data_type() == sparesparrow::bpm::RequestPayload::ResetDeviceRequest ? static_cast<const sparesparrow::bpm::ResetDeviceRequest *>(data()) : nullptr;
  }
  const sparesparrow::bpm::CalibrateAudioRequest *data_as_CalibrateAudioRequest() const {
    return data_type() == sparesparrow::bpm::RequestPayload::CalibrateAudioRequest ? static_cast<const sparesparrow::bpm::CalibrateAudioRequest *>(data()) : nullptr;
  }
  const sparesparrow::bpm::StartStreamingRequest *data_as_StartStreamingRequest() const {
    return data_type() == sparesparrow::bpm::RequestPayload::StartStreamingRequest ? static_cast<const sparesparrow::bpm::StartStreamingRequest *>(data()) : nullptr;
  }
  const sparesparrow::bpm::StopStreamingRequest *data_as_StopStreamingRequest() const {
    return data_type() == sparesparrow::bpm::RequestPayload::StopStreamingRequest ? static_cast<const sparesparrow::bpm::StopStreamingRequest *>(data()) : nullptr;
  }
  const sparesparrow::bpm::GetDiagnosticsRequest *data_as_GetDiagnosticsRequest() const {
    return data_type() == sparesparrow::bpm::RequestPayload::GetDiagnosticsRequest ? static_cast<const sparesparrow::bpm::GetDiagnosticsRequest *>(data()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<int8_t>(verifier, VT_REQUEST_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyRequestPayload(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const sparesparrow::bpm::GetStatusRequest *Request::data_as<sparesparrow::bpm::GetStatusRequest>() const {
  return data_as_GetStatusRequest();
}

template<> inline const sparesparrow::bpm::GetConfigRequest *Request::data_as<sparesparrow::bpm::GetConfigRequest>() const {
  return data_as_GetConfigRequest();
}

template<> inline const sparesparrow::bpm::SetConfigRequest *Request::data_as<sparesparrow::bpm::SetConfigRequest>() const {
  return data_as_SetConfigRequest();
}

template<> inline const sparesparrow::bpm::ResetDeviceRequest *Request::data_as<sparesparrow::bpm::ResetDeviceRequest>() const {
  return data_as_ResetDeviceRequest();
}

template<> inline const sparesparrow::bpm::CalibrateAudioRequest *Request::data_as<sparesparrow::bpm::CalibrateAudioRequest>() const {
  return data_as_CalibrateAudioRequest();
}

template<> inline const sparesparrow::bpm::StartStreamingRequest *Request::data_as<sparesparrow::bpm::StartStreamingRequest>() const {
  return data_as_StartStreamingRequest();
}

template<> inline const sparesparrow::bpm::StopStreamingRequest *Request::data_as<sparesparrow::bpm::StopStreamingRequest>() const {
  return data_as_StopStreamingRequest();
}

template<> inline const sparesparrow::bpm::GetDiagnosticsRequest *Request::data_as<sparesparrow::bpm::GetDiagnosticsRequest>() const {
  return data_as_GetDiagnosticsRequest();
}

struct RequestBuilder {
  typedef Request Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_header(::flatbuffers::Offset<sparesparrow::bpm::Header> header) {
    fbb_.AddOffset(Request::VT_HEADER, header);
  }
  void add_request_type(sparesparrow::bpm::RequestType request_type) {
    fbb_.AddElement<int8_t>(Request::VT_REQUEST_TYPE, static_cast<int8_t>(request_type), 0);
  }
  void add_data_type(sparesparrow::bpm::RequestPayload data_type) {
    fbb_.AddElement<uint8_t>(Request::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(::flatbuffers::Offset<void> data) {
    fbb_.AddOffset(Request::VT_DATA, data);
  }
  explicit RequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request> CreateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<sparesparrow::bpm::Header> header = 0,
    sparesparrow::bpm::RequestType request_type = sparesparrow::bpm::RequestType::GET_STATUS,
    sparesparrow::bpm::RequestPayload data_type = sparesparrow::bpm::RequestPayload::NONE,
    ::flatbuffers::Offset<void> data = 0) {
  RequestBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_header(header);
  builder_.add_data_type(data_type);
  builder_.add_request_type(request_type);
  return builder_.Finish();
}

struct GetStatusResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetStatusResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4
  };
  const sparesparrow::bpm::StatusUpdate *status() const {
    return GetPointer<const sparesparrow::bpm::StatusUpdate *>(VT_STATUS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           verifier.EndTable();
  }
};

struct GetStatusResponseBuilder {
  typedef GetStatusResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_status(::flatbuffers::Offset<sparesparrow::bpm::StatusUpdate> status) {
    fbb_.AddOffset(GetStatusResponse::VT_STATUS, status);
  }
  explicit GetStatusResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetStatusResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetStatusResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetStatusResponse> CreateGetStatusResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<sparesparrow::bpm::StatusUpdate> status = 0) {
  GetStatusResponseBuilder builder_(_fbb);
  builder_.add_status(status);
  return builder_.Finish();
}

struct GetConfigResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetConfigResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONFIG = 4
  };
  const sparesparrow::bpm::ConfigUpdate *config() const {
    return GetPointer<const sparesparrow::bpm::ConfigUpdate *>(VT_CONFIG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           verifier.VerifyTable(config()) &&
           verifier.EndTable();
  }
};

struct GetConfigResponseBuilder {
  typedef GetConfigResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_config(::flatbuffers::Offset<sparesparrow::bpm::ConfigUpdate> config) {
    fbb_.AddOffset(GetConfigResponse::VT_CONFIG, config);
  }
  explicit GetConfigResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetConfigResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetConfigResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetConfigResponse> CreateGetConfigResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<sparesparrow::bpm::ConfigUpdate> config = 0) {
  GetConfigResponseBuilder builder_(_fbb);
  builder_.add_config(config);
  return builder_.Finish();
}

struct SetConfigResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetConfigResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APPLIED = 4,
    VT_ERROR_MESSAGE = 6
  };
  bool applied() const {
    return GetField<uint8_t>(VT_APPLIED, 0) != 0;
  }
  const ::flatbuffers::String *error_message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_APPLIED, 1) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           verifier.EndTable();
  }
};

struct SetConfigResponseBuilder {
  typedef SetConfigResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_applied(bool applied) {
    fbb_.AddElement<uint8_t>(SetConfigResponse::VT_APPLIED, static_cast<uint8_t>(applied), 0);
  }
  void add_error_message(::flatbuffers::Offset<::flatbuffers::String> error_message) {
    fbb_.AddOffset(SetConfigResponse::VT_ERROR_MESSAGE, error_message);
  }
  explicit SetConfigResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetConfigResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetConfigResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetConfigResponse> CreateSetConfigResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool applied = false,
    ::flatbuffers::Offset<::flatbuffers::String> error_message = 0) {
  SetConfigResponseBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  builder_.add_applied(applied);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SetConfigResponse> CreateSetConfigResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool applied = false,
    const char *error_message = nullptr) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return sparesparrow::bpm::CreateSetConfigResponse(
      _fbb,
      applied,
      error_message__);
}

struct ResetDeviceResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResetDeviceResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESET_INITIATED = 4
  };
  bool reset_initiated() const {
    return GetField<uint8_t>(VT_RESET_INITIATED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESET_INITIATED, 1) &&
           verifier.EndTable();
  }
};

struct ResetDeviceResponseBuilder {
  typedef ResetDeviceResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_reset_initiated(bool reset_initiated) {
    fbb_.AddElement<uint8_t>(ResetDeviceResponse::VT_RESET_INITIATED, static_cast<uint8_t>(reset_initiated), 0);
  }
  explicit ResetDeviceResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResetDeviceResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResetDeviceResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResetDeviceResponse> CreateResetDeviceResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool reset_initiated = false) {
  ResetDeviceResponseBuilder builder_(_fbb);
  builder_.add_reset_initiated(reset_initiated);
  return builder_.Finish();
}

struct CalibrateAudioResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CalibrateAudioResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CALIBRATION_COMPLETE = 4,
    VT_CALIBRATION_DATA = 6
  };
  bool calibration_complete() const {
    return GetField<uint8_t>(VT_CALIBRATION_COMPLETE, 0) != 0;
  }
  const sparesparrow::bpm::AudioCalibrationData *calibration_data() const {
    return GetPointer<const sparesparrow::bpm::AudioCalibrationData *>(VT_CALIBRATION_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CALIBRATION_COMPLETE, 1) &&
           VerifyOffset(verifier, VT_CALIBRATION_DATA) &&
           verifier.VerifyTable(calibration_data()) &&
           verifier.EndTable();
  }
};

struct CalibrateAudioResponseBuilder {
  typedef CalibrateAudioResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_calibration_complete(bool calibration_complete) {
    fbb_.AddElement<uint8_t>(CalibrateAudioResponse::VT_CALIBRATION_COMPLETE, static_cast<uint8_t>(calibration_complete), 0);
  }
  void add_calibration_data(::flatbuffers::Offset<sparesparrow::bpm::AudioCalibrationData> calibration_data) {
    fbb_.AddOffset(CalibrateAudioResponse::VT_CALIBRATION_DATA, calibration_data);
  }
  explicit CalibrateAudioResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CalibrateAudioResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CalibrateAudioResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CalibrateAudioResponse> CreateCalibrateAudioResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool calibration_complete = false,
    ::flatbuffers::Offset<sparesparrow::bpm::AudioCalibrationData> calibration_data = 0) {
  CalibrateAudioResponseBuilder builder_(_fbb);
  builder_.add_calibration_data(calibration_data);
  builder_.add_calibration_complete(calibration_complete);
  return builder_.Finish();
}

struct StartStreamingResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StartStreamingResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ACTIVE = 4,
    VT_STREAM_ID = 6
  };
  bool stream_active() const {
    return GetField<uint8_t>(VT_STREAM_ACTIVE, 0) != 0;
  }
  const ::flatbuffers::String *stream_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STREAM_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STREAM_ACTIVE, 1) &&
           VerifyOffset(verifier, VT_STREAM_ID) &&
           verifier.VerifyString(stream_id()) &&
           verifier.EndTable();
  }
};

struct StartStreamingResponseBuilder {
  typedef StartStreamingResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_stream_active(bool stream_active) {
    fbb_.AddElement<uint8_t>(StartStreamingResponse::VT_STREAM_ACTIVE, static_cast<uint8_t>(stream_active), 0);
  }
  void add_stream_id(::flatbuffers::Offset<::flatbuffers::String> stream_id) {
    fbb_.AddOffset(StartStreamingResponse::VT_STREAM_ID, stream_id);
  }
  explicit StartStreamingResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StartStreamingResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StartStreamingResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StartStreamingResponse> CreateStartStreamingResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool stream_active = false,
    ::flatbuffers::Offset<::flatbuffers::String> stream_id = 0) {
  StartStreamingResponseBuilder builder_(_fbb);
  builder_.add_stream_id(stream_id);
  builder_.add_stream_active(stream_active);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StartStreamingResponse> CreateStartStreamingResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool stream_active = false,
    const char *stream_id = nullptr) {
  auto stream_id__ = stream_id ? _fbb.CreateString(stream_id) : 0;
  return sparesparrow::bpm::CreateStartStreamingResponse(
      _fbb,
      stream_active,
      stream_id__);
}

struct StopStreamingResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StopStreamingResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_STOPPED = 4
  };
  bool stream_stopped() const {
    return GetField<uint8_t>(VT_STREAM_STOPPED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STREAM_STOPPED, 1) &&
           verifier.EndTable();
  }
};

struct StopStreamingResponseBuilder {
  typedef StopStreamingResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_stream_stopped(bool stream_stopped) {
    fbb_.AddElement<uint8_t>(StopStreamingResponse::VT_STREAM_STOPPED, static_cast<uint8_t>(stream_stopped), 0);
  }
  explicit StopStreamingResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StopStreamingResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StopStreamingResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StopStreamingResponse> CreateStopStreamingResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool stream_stopped = false) {
  StopStreamingResponseBuilder builder_(_fbb);
  builder_.add_stream_stopped(stream_stopped);
  return builder_.Finish();
}

struct GetDiagnosticsResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetDiagnosticsResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIAGNOSTICS = 4
  };
  const sparesparrow::bpm::DiagnosticsData *diagnostics() const {
    return GetPointer<const sparesparrow::bpm::DiagnosticsData *>(VT_DIAGNOSTICS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIAGNOSTICS) &&
           verifier.VerifyTable(diagnostics()) &&
           verifier.EndTable();
  }
};

struct GetDiagnosticsResponseBuilder {
  typedef GetDiagnosticsResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_diagnostics(::flatbuffers::Offset<sparesparrow::bpm::DiagnosticsData> diagnostics) {
    fbb_.AddOffset(GetDiagnosticsResponse::VT_DIAGNOSTICS, diagnostics);
  }
  explicit GetDiagnosticsResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetDiagnosticsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetDiagnosticsResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetDiagnosticsResponse> CreateGetDiagnosticsResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<sparesparrow::bpm::DiagnosticsData> diagnostics = 0) {
  GetDiagnosticsResponseBuilder builder_(_fbb);
  builder_.add_diagnostics(diagnostics);
  return builder_.Finish();
}

struct Status FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_DESCRIPTION = 6
  };
  sparesparrow::bpm::StatusEnum status() const {
    return static_cast<sparesparrow::bpm::StatusEnum>(GetField<int32_t>(VT_STATUS, 0));
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STATUS, 4) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           verifier.EndTable();
  }
};

struct StatusBuilder {
  typedef Status Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_status(sparesparrow::bpm::StatusEnum status) {
    fbb_.AddElement<int32_t>(Status::VT_STATUS, static_cast<int32_t>(status), 0);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(Status::VT_DESCRIPTION, description);
  }
  explicit StatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Status> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Status>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Status> CreateStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    sparesparrow::bpm::StatusEnum status = sparesparrow::bpm::StatusEnum::Success,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0) {
  StatusBuilder builder_(_fbb);
  builder_.add_description(description);
  builder_.add_status(status);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Status> CreateStatusDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    sparesparrow::bpm::StatusEnum status = sparesparrow::bpm::StatusEnum::Success,
    const char *description = nullptr) {
  auto description__ = description ? _fbb.CreateString(description) : 0;
  return sparesparrow::bpm::CreateStatus(
      _fbb,
      status,
      description__);
}

struct Response FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_STATUS = 6,
    VT_DATA_TYPE = 8,
    VT_DATA = 10
  };
  const sparesparrow::bpm::Header *header() const {
    return GetPointer<const sparesparrow::bpm::Header *>(VT_HEADER);
  }
  const sparesparrow::bpm::Status *status() const {
    return GetPointer<const sparesparrow::bpm::Status *>(VT_STATUS);
  }
  sparesparrow::bpm::ResponsePayload data_type() const {
    return static_cast<sparesparrow::bpm::ResponsePayload>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const sparesparrow::bpm::GetStatusResponse *data_as_GetStatusResponse() const {
    return data_type() == sparesparrow::bpm::ResponsePayload::GetStatusResponse ? static_cast<const sparesparrow::bpm::GetStatusResponse *>(data()) : nullptr;
  }
  const sparesparrow::bpm::GetConfigResponse *data_as_GetConfigResponse() const {
    return data_type() == sparesparrow::bpm::ResponsePayload::GetConfigResponse ? static_cast<const sparesparrow::bpm::GetConfigResponse *>(data()) : nullptr;
  }
  const sparesparrow::bpm::SetConfigResponse *data_as_SetConfigResponse() const {
    return data_type() == sparesparrow::bpm::ResponsePayload::SetConfigResponse ? static_cast<const sparesparrow::bpm::SetConfigResponse *>(data()) : nullptr;
  }
  const sparesparrow::bpm::ResetDeviceResponse *data_as_ResetDeviceResponse() const {
    return data_type() == sparesparrow::bpm::ResponsePayload::ResetDeviceResponse ? static_cast<const sparesparrow::bpm::ResetDeviceResponse *>(data()) : nullptr;
  }
  const sparesparrow::bpm::CalibrateAudioResponse *data_as_CalibrateAudioResponse() const {
    return data_type() == sparesparrow::bpm::ResponsePayload::CalibrateAudioResponse ? static_cast<const sparesparrow::bpm::CalibrateAudioResponse *>(data()) : nullptr;
  }
  const sparesparrow::bpm::StartStreamingResponse *data_as_StartStreamingResponse() const {
    return data_type() == sparesparrow::bpm::ResponsePayload::StartStreamingResponse ? static_cast<const sparesparrow::bpm::StartStreamingResponse *>(data()) : nullptr;
  }
  const sparesparrow::bpm::StopStreamingResponse *data_as_StopStreamingResponse() const {
    return data_type() == sparesparrow::bpm::ResponsePayload::StopStreamingResponse ? static_cast<const sparesparrow::bpm::StopStreamingResponse *>(data()) : nullptr;
  }
  const sparesparrow::bpm::GetDiagnosticsResponse *data_as_GetDiagnosticsResponse() const {
    return data_type() == sparesparrow::bpm::ResponsePayload::GetDiagnosticsResponse ? static_cast<const sparesparrow::bpm::GetDiagnosticsResponse *>(data()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyResponsePayload(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const sparesparrow::bpm::GetStatusResponse *Response::data_as<sparesparrow::bpm::GetStatusResponse>() const {
  return data_as_GetStatusResponse();
}

template<> inline const sparesparrow::bpm::GetConfigResponse *Response::data_as<sparesparrow::bpm::GetConfigResponse>() const {
  return data_as_GetConfigResponse();
}

template<> inline const sparesparrow::bpm::SetConfigResponse *Response::data_as<sparesparrow::bpm::SetConfigResponse>() const {
  return data_as_SetConfigResponse();
}

template<> inline const sparesparrow::bpm::ResetDeviceResponse *Response::data_as<sparesparrow::bpm::ResetDeviceResponse>() const {
  return data_as_ResetDeviceResponse();
}

template<> inline const sparesparrow::bpm::CalibrateAudioResponse *Response::data_as<sparesparrow::bpm::CalibrateAudioResponse>() const {
  return data_as_CalibrateAudioResponse();
}

template<> inline const sparesparrow::bpm::StartStreamingResponse *Response::data_as<sparesparrow::bpm::StartStreamingResponse>() const {
  return data_as_StartStreamingResponse();
}

template<> inline const sparesparrow::bpm::StopStreamingResponse *Response::data_as<sparesparrow::bpm::StopStreamingResponse>() const {
  return data_as_StopStreamingResponse();
}

template<> inline const sparesparrow::bpm::GetDiagnosticsResponse *Response::data_as<sparesparrow::bpm::GetDiagnosticsResponse>() const {
  return data_as_GetDiagnosticsResponse();
}

struct ResponseBuilder {
  typedef Response Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_header(::flatbuffers::Offset<sparesparrow::bpm::Header> header) {
    fbb_.AddOffset(Response::VT_HEADER, header);
  }
  void add_status(::flatbuffers::Offset<sparesparrow::bpm::Status> status) {
    fbb_.AddOffset(Response::VT_STATUS, status);
  }
  void add_data_type(sparesparrow::bpm::ResponsePayload data_type) {
    fbb_.AddElement<uint8_t>(Response::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(::flatbuffers::Offset<void> data) {
    fbb_.AddOffset(Response::VT_DATA, data);
  }
  explicit ResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response> CreateResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<sparesparrow::bpm::Header> header = 0,
    ::flatbuffers::Offset<sparesparrow::bpm::Status> status = 0,
    sparesparrow::bpm::ResponsePayload data_type = sparesparrow::bpm::ResponsePayload::NONE,
    ::flatbuffers::Offset<void> data = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_status(status);
  builder_.add_header(header);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

struct BPMUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BPMUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BPM = 4,
    VT_CONFIDENCE = 6,
    VT_SIGNAL_LEVEL = 8,
    VT_STATUS = 10,
    VT_ANALYSIS = 12,
    VT_QUALITY = 14,
    VT_TIMESTAMP = 16
  };
  float bpm() const {
    return GetField<float>(VT_BPM, 0.0f);
  }
  float confidence() const {
    return GetField<float>(VT_CONFIDENCE, 0.0f);
  }
  float signal_level() const {
    return GetField<float>(VT_SIGNAL_LEVEL, 0.0f);
  }
  sparesparrow::bpm::DetectionStatus status() const {
    return static_cast<sparesparrow::bpm::DetectionStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  const sparesparrow::bpm::BPMAnalysis *analysis() const {
    return GetPointer<const sparesparrow::bpm::BPMAnalysis *>(VT_ANALYSIS);
  }
  const sparesparrow::bpm::BPMQuality *quality() const {
    return GetPointer<const sparesparrow::bpm::BPMQuality *>(VT_QUALITY);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BPM, 4) &&
           VerifyField<float>(verifier, VT_CONFIDENCE, 4) &&
           VerifyField<float>(verifier, VT_SIGNAL_LEVEL, 4) &&
           VerifyField<int8_t>(verifier, VT_STATUS, 1) &&
           VerifyOffset(verifier, VT_ANALYSIS) &&
           verifier.VerifyTable(analysis()) &&
           VerifyOffset(verifier, VT_QUALITY) &&
           verifier.VerifyTable(quality()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct BPMUpdateBuilder {
  typedef BPMUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_bpm(float bpm) {
    fbb_.AddElement<float>(BPMUpdate::VT_BPM, bpm, 0.0f);
  }
  void add_confidence(float confidence) {
    fbb_.AddElement<float>(BPMUpdate::VT_CONFIDENCE, confidence, 0.0f);
  }
  void add_signal_level(float signal_level) {
    fbb_.AddElement<float>(BPMUpdate::VT_SIGNAL_LEVEL, signal_level, 0.0f);
  }
  void add_status(sparesparrow::bpm::DetectionStatus status) {
    fbb_.AddElement<int8_t>(BPMUpdate::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_analysis(::flatbuffers::Offset<sparesparrow::bpm::BPMAnalysis> analysis) {
    fbb_.AddOffset(BPMUpdate::VT_ANALYSIS, analysis);
  }
  void add_quality(::flatbuffers::Offset<sparesparrow::bpm::BPMQuality> quality) {
    fbb_.AddOffset(BPMUpdate::VT_QUALITY, quality);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(BPMUpdate::VT_TIMESTAMP, timestamp, 0);
  }
  explicit BPMUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BPMUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BPMUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BPMUpdate> CreateBPMUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float bpm = 0.0f,
    float confidence = 0.0f,
    float signal_level = 0.0f,
    sparesparrow::bpm::DetectionStatus status = sparesparrow::bpm::DetectionStatus::INITIALIZING,
    ::flatbuffers::Offset<sparesparrow::bpm::BPMAnalysis> analysis = 0,
    ::flatbuffers::Offset<sparesparrow::bpm::BPMQuality> quality = 0,
    uint64_t timestamp = 0) {
  BPMUpdateBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_quality(quality);
  builder_.add_analysis(analysis);
  builder_.add_signal_level(signal_level);
  builder_.add_confidence(confidence);
  builder_.add_bpm(bpm);
  builder_.add_status(status);
  return builder_.Finish();
}

struct StatusUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StatusUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPTIME_SECONDS = 4,
    VT_FREE_HEAP_BYTES = 6,
    VT_MIN_FREE_HEAP_BYTES = 8,
    VT_CPU_USAGE_PERCENT = 10,
    VT_WIFI_RSSI = 12,
    VT_AUDIO_STATUS = 14,
    VT_TEMPERATURE_CELSIUS = 16,
    VT_BATTERY_LEVEL_PERCENT = 18
  };
  uint64_t uptime_seconds() const {
    return GetField<uint64_t>(VT_UPTIME_SECONDS, 0);
  }
  uint32_t free_heap_bytes() const {
    return GetField<uint32_t>(VT_FREE_HEAP_BYTES, 0);
  }
  uint32_t min_free_heap_bytes() const {
    return GetField<uint32_t>(VT_MIN_FREE_HEAP_BYTES, 0);
  }
  uint8_t cpu_usage_percent() const {
    return GetField<uint8_t>(VT_CPU_USAGE_PERCENT, 0);
  }
  int8_t wifi_rssi() const {
    return GetField<int8_t>(VT_WIFI_RSSI, 0);
  }
  const sparesparrow::bpm::AudioStatus *audio_status() const {
    return GetPointer<const sparesparrow::bpm::AudioStatus *>(VT_AUDIO_STATUS);
  }
  float temperature_celsius() const {
    return GetField<float>(VT_TEMPERATURE_CELSIUS, 0.0f);
  }
  uint8_t battery_level_percent() const {
    return GetField<uint8_t>(VT_BATTERY_LEVEL_PERCENT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_UPTIME_SECONDS, 8) &&
           VerifyField<uint32_t>(verifier, VT_FREE_HEAP_BYTES, 4) &&
           VerifyField<uint32_t>(verifier, VT_MIN_FREE_HEAP_BYTES, 4) &&
           VerifyField<uint8_t>(verifier, VT_CPU_USAGE_PERCENT, 1) &&
           VerifyField<int8_t>(verifier, VT_WIFI_RSSI, 1) &&
           VerifyOffset(verifier, VT_AUDIO_STATUS) &&
           verifier.VerifyTable(audio_status()) &&
           VerifyField<float>(verifier, VT_TEMPERATURE_CELSIUS, 4) &&
           VerifyField<uint8_t>(verifier, VT_BATTERY_LEVEL_PERCENT, 1) &&
           verifier.EndTable();
  }
};

struct StatusUpdateBuilder {
  typedef StatusUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uptime_seconds(uint64_t uptime_seconds) {
    fbb_.AddElement<uint64_t>(StatusUpdate::VT_UPTIME_SECONDS, uptime_seconds, 0);
  }
  void add_free_heap_bytes(uint32_t free_heap_bytes) {
    fbb_.AddElement<uint32_t>(StatusUpdate::VT_FREE_HEAP_BYTES, free_heap_bytes, 0);
  }
  void add_min_free_heap_bytes(uint32_t min_free_heap_bytes) {
    fbb_.AddElement<uint32_t>(StatusUpdate::VT_MIN_FREE_HEAP_BYTES, min_free_heap_bytes, 0);
  }
  void add_cpu_usage_percent(uint8_t cpu_usage_percent) {
    fbb_.AddElement<uint8_t>(StatusUpdate::VT_CPU_USAGE_PERCENT, cpu_usage_percent, 0);
  }
  void add_wifi_rssi(int8_t wifi_rssi) {
    fbb_.AddElement<int8_t>(StatusUpdate::VT_WIFI_RSSI, wifi_rssi, 0);
  }
  void add_audio_status(::flatbuffers::Offset<sparesparrow::bpm::AudioStatus> audio_status) {
    fbb_.AddOffset(StatusUpdate::VT_AUDIO_STATUS, audio_status);
  }
  void add_temperature_celsius(float temperature_celsius) {
    fbb_.AddElement<float>(StatusUpdate::VT_TEMPERATURE_CELSIUS, temperature_celsius, 0.0f);
  }
  void add_battery_level_percent(uint8_t battery_level_percent) {
    fbb_.AddElement<uint8_t>(StatusUpdate::VT_BATTERY_LEVEL_PERCENT, battery_level_percent, 0);
  }
  explicit StatusUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StatusUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StatusUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StatusUpdate> CreateStatusUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t uptime_seconds = 0,
    uint32_t free_heap_bytes = 0,
    uint32_t min_free_heap_bytes = 0,
    uint8_t cpu_usage_percent = 0,
    int8_t wifi_rssi = 0,
    ::flatbuffers::Offset<sparesparrow::bpm::AudioStatus> audio_status = 0,
    float temperature_celsius = 0.0f,
    uint8_t battery_level_percent = 0) {
  StatusUpdateBuilder builder_(_fbb);
  builder_.add_uptime_seconds(uptime_seconds);
  builder_.add_temperature_celsius(temperature_celsius);
  builder_.add_audio_status(audio_status);
  builder_.add_min_free_heap_bytes(min_free_heap_bytes);
  builder_.add_free_heap_bytes(free_heap_bytes);
  builder_.add_battery_level_percent(battery_level_percent);
  builder_.add_wifi_rssi(wifi_rssi);
  builder_.add_cpu_usage_percent(cpu_usage_percent);
  return builder_.Finish();
}

struct ErrorReport FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ErrorReportBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_MESSAGE = 6,
    VT_SEVERITY = 8,
    VT_CONTEXT = 10,
    VT_ERROR_TIMESTAMP = 12,
    VT_RECOVERY_ACTION = 14
  };
  sparesparrow::bpm::ErrorCode error_code() const {
    return static_cast<sparesparrow::bpm::ErrorCode>(GetField<uint16_t>(VT_ERROR_CODE, 0));
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  sparesparrow::bpm::ErrorSeverity severity() const {
    return static_cast<sparesparrow::bpm::ErrorSeverity>(GetField<int8_t>(VT_SEVERITY, 0));
  }
  const ::flatbuffers::String *context() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTEXT);
  }
  uint64_t error_timestamp() const {
    return GetField<uint64_t>(VT_ERROR_TIMESTAMP, 0);
  }
  const ::flatbuffers::String *recovery_action() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RECOVERY_ACTION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE, 2) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyField<int8_t>(verifier, VT_SEVERITY, 1) &&
           VerifyOffset(verifier, VT_CONTEXT) &&
           verifier.VerifyString(context()) &&
           VerifyField<uint64_t>(verifier, VT_ERROR_TIMESTAMP, 8) &&
           VerifyOffset(verifier, VT_RECOVERY_ACTION) &&
           verifier.VerifyString(recovery_action()) &&
           verifier.EndTable();
  }
};

struct ErrorReportBuilder {
  typedef ErrorReport Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error_code(sparesparrow::bpm::ErrorCode error_code) {
    fbb_.AddElement<uint16_t>(ErrorReport::VT_ERROR_CODE, static_cast<uint16_t>(error_code), 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(ErrorReport::VT_MESSAGE, message);
  }
  void add_severity(sparesparrow::bpm::ErrorSeverity severity) {
    fbb_.AddElement<int8_t>(ErrorReport::VT_SEVERITY, static_cast<int8_t>(severity), 0);
  }
  void add_context(::flatbuffers::Offset<::flatbuffers::String> context) {
    fbb_.AddOffset(ErrorReport::VT_CONTEXT, context);
  }
  void add_error_timestamp(uint64_t error_timestamp) {
    fbb_.AddElement<uint64_t>(ErrorReport::VT_ERROR_TIMESTAMP, error_timestamp, 0);
  }
  void add_recovery_action(::flatbuffers::Offset<::flatbuffers::String> recovery_action) {
    fbb_.AddOffset(ErrorReport::VT_RECOVERY_ACTION, recovery_action);
  }
  explicit ErrorReportBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ErrorReport> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ErrorReport>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ErrorReport> CreateErrorReport(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    sparesparrow::bpm::ErrorCode error_code = sparesparrow::bpm::ErrorCode::UNKNOWN_ERROR,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0,
    sparesparrow::bpm::ErrorSeverity severity = sparesparrow::bpm::ErrorSeverity::INFO,
    ::flatbuffers::Offset<::flatbuffers::String> context = 0,
    uint64_t error_timestamp = 0,
    ::flatbuffers::Offset<::flatbuffers::String> recovery_action = 0) {
  ErrorReportBuilder builder_(_fbb);
  builder_.add_error_timestamp(error_timestamp);
  builder_.add_recovery_action(recovery_action);
  builder_.add_context(context);
  builder_.add_message(message);
  builder_.add_error_code(error_code);
  builder_.add_severity(severity);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ErrorReport> CreateErrorReportDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    sparesparrow::bpm::ErrorCode error_code = sparesparrow::bpm::ErrorCode::UNKNOWN_ERROR,
    const char *message = nullptr,
    sparesparrow::bpm::ErrorSeverity severity = sparesparrow::bpm::ErrorSeverity::INFO,
    const char *context = nullptr,
    uint64_t error_timestamp = 0,
    const char *recovery_action = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  auto context__ = context ? _fbb.CreateString(context) : 0;
  auto recovery_action__ = recovery_action ? _fbb.CreateString(recovery_action) : 0;
  return sparesparrow::bpm::CreateErrorReport(
      _fbb,
      error_code,
      message__,
      severity,
      context__,
      error_timestamp,
      recovery_action__);
}

struct BPMAnalysis FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BPMAnalysisBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STABILITY = 4,
    VT_REGULARITY = 6,
    VT_DOMINANT_FREQUENCY = 8,
    VT_SPECTRAL_CENTROID = 10,
    VT_BEAT_POSITION = 12,
    VT_TEMPO_CONSISTENCY = 14
  };
  float stability() const {
    return GetField<float>(VT_STABILITY, 0.0f);
  }
  float regularity() const {
    return GetField<float>(VT_REGULARITY, 0.0f);
  }
  float dominant_frequency() const {
    return GetField<float>(VT_DOMINANT_FREQUENCY, 0.0f);
  }
  float spectral_centroid() const {
    return GetField<float>(VT_SPECTRAL_CENTROID, 0.0f);
  }
  float beat_position() const {
    return GetField<float>(VT_BEAT_POSITION, 0.0f);
  }
  float tempo_consistency() const {
    return GetField<float>(VT_TEMPO_CONSISTENCY, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_STABILITY, 4) &&
           VerifyField<float>(verifier, VT_REGULARITY, 4) &&
           VerifyField<float>(verifier, VT_DOMINANT_FREQUENCY, 4) &&
           VerifyField<float>(verifier, VT_SPECTRAL_CENTROID, 4) &&
           VerifyField<float>(verifier, VT_BEAT_POSITION, 4) &&
           VerifyField<float>(verifier, VT_TEMPO_CONSISTENCY, 4) &&
           verifier.EndTable();
  }
};

struct BPMAnalysisBuilder {
  typedef BPMAnalysis Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_stability(float stability) {
    fbb_.AddElement<float>(BPMAnalysis::VT_STABILITY, stability, 0.0f);
  }
  void add_regularity(float regularity) {
    fbb_.AddElement<float>(BPMAnalysis::VT_REGULARITY, regularity, 0.0f);
  }
  void add_dominant_frequency(float dominant_frequency) {
    fbb_.AddElement<float>(BPMAnalysis::VT_DOMINANT_FREQUENCY, dominant_frequency, 0.0f);
  }
  void add_spectral_centroid(float spectral_centroid) {
    fbb_.AddElement<float>(BPMAnalysis::VT_SPECTRAL_CENTROID, spectral_centroid, 0.0f);
  }
  void add_beat_position(float beat_position) {
    fbb_.AddElement<float>(BPMAnalysis::VT_BEAT_POSITION, beat_position, 0.0f);
  }
  void add_tempo_consistency(float tempo_consistency) {
    fbb_.AddElement<float>(BPMAnalysis::VT_TEMPO_CONSISTENCY, tempo_consistency, 0.0f);
  }
  explicit BPMAnalysisBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BPMAnalysis> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BPMAnalysis>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BPMAnalysis> CreateBPMAnalysis(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float stability = 0.0f,
    float regularity = 0.0f,
    float dominant_frequency = 0.0f,
    float spectral_centroid = 0.0f,
    float beat_position = 0.0f,
    float tempo_consistency = 0.0f) {
  BPMAnalysisBuilder builder_(_fbb);
  builder_.add_tempo_consistency(tempo_consistency);
  builder_.add_beat_position(beat_position);
  builder_.add_spectral_centroid(spectral_centroid);
  builder_.add_dominant_frequency(dominant_frequency);
  builder_.add_regularity(regularity);
  builder_.add_stability(stability);
  return builder_.Finish();
}

struct BPMQuality FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BPMQualityBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SNR_DB = 4,
    VT_CONSECUTIVE_DETECTIONS = 6,
    VT_RELIABILITY_SCORE = 8,
    VT_FALSE_POSITIVE_RATE = 10,
    VT_ALGORITHM_CONFIDENCE = 12
  };
  float snr_db() const {
    return GetField<float>(VT_SNR_DB, 0.0f);
  }
  uint16_t consecutive_detections() const {
    return GetField<uint16_t>(VT_CONSECUTIVE_DETECTIONS, 0);
  }
  float reliability_score() const {
    return GetField<float>(VT_RELIABILITY_SCORE, 0.0f);
  }
  float false_positive_rate() const {
    return GetField<float>(VT_FALSE_POSITIVE_RATE, 0.0f);
  }
  float algorithm_confidence() const {
    return GetField<float>(VT_ALGORITHM_CONFIDENCE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SNR_DB, 4) &&
           VerifyField<uint16_t>(verifier, VT_CONSECUTIVE_DETECTIONS, 2) &&
           VerifyField<float>(verifier, VT_RELIABILITY_SCORE, 4) &&
           VerifyField<float>(verifier, VT_FALSE_POSITIVE_RATE, 4) &&
           VerifyField<float>(verifier, VT_ALGORITHM_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct BPMQualityBuilder {
  typedef BPMQuality Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_snr_db(float snr_db) {
    fbb_.AddElement<float>(BPMQuality::VT_SNR_DB, snr_db, 0.0f);
  }
  void add_consecutive_detections(uint16_t consecutive_detections) {
    fbb_.AddElement<uint16_t>(BPMQuality::VT_CONSECUTIVE_DETECTIONS, consecutive_detections, 0);
  }
  void add_reliability_score(float reliability_score) {
    fbb_.AddElement<float>(BPMQuality::VT_RELIABILITY_SCORE, reliability_score, 0.0f);
  }
  void add_false_positive_rate(float false_positive_rate) {
    fbb_.AddElement<float>(BPMQuality::VT_FALSE_POSITIVE_RATE, false_positive_rate, 0.0f);
  }
  void add_algorithm_confidence(float algorithm_confidence) {
    fbb_.AddElement<float>(BPMQuality::VT_ALGORITHM_CONFIDENCE, algorithm_confidence, 0.0f);
  }
  explicit BPMQualityBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BPMQuality> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BPMQuality>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BPMQuality> CreateBPMQuality(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float snr_db = 0.0f,
    uint16_t consecutive_detections = 0,
    float reliability_score = 0.0f,
    float false_positive_rate = 0.0f,
    float algorithm_confidence = 0.0f) {
  BPMQualityBuilder builder_(_fbb);
  builder_.add_algorithm_confidence(algorithm_confidence);
  builder_.add_false_positive_rate(false_positive_rate);
  builder_.add_reliability_score(reliability_score);
  builder_.add_snr_db(snr_db);
  builder_.add_consecutive_detections(consecutive_detections);
  return builder_.Finish();
}

struct AudioStatus FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AudioStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT_ACTIVE = 4,
    VT_SAMPLE_RATE = 6,
    VT_BUFFER_UTILIZATION = 8,
    VT_AUDIO_DROPOUTS = 10,
    VT_LATENCY_MS = 12,
    VT_MICROPHONE_GAIN = 14
  };
  bool input_active() const {
    return GetField<uint8_t>(VT_INPUT_ACTIVE, 0) != 0;
  }
  uint32_t sample_rate() const {
    return GetField<uint32_t>(VT_SAMPLE_RATE, 0);
  }
  float buffer_utilization() const {
    return GetField<float>(VT_BUFFER_UTILIZATION, 0.0f);
  }
  uint32_t audio_dropouts() const {
    return GetField<uint32_t>(VT_AUDIO_DROPOUTS, 0);
  }
  uint16_t latency_ms() const {
    return GetField<uint16_t>(VT_LATENCY_MS, 0);
  }
  float microphone_gain() const {
    return GetField<float>(VT_MICROPHONE_GAIN, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_INPUT_ACTIVE, 1) &&
           VerifyField<uint32_t>(verifier, VT_SAMPLE_RATE, 4) &&
           VerifyField<float>(verifier, VT_BUFFER_UTILIZATION, 4) &&
           VerifyField<uint32_t>(verifier, VT_AUDIO_DROPOUTS, 4) &&
           VerifyField<uint16_t>(verifier, VT_LATENCY_MS, 2) &&
           VerifyField<float>(verifier, VT_MICROPHONE_GAIN, 4) &&
           verifier.EndTable();
  }
};

struct AudioStatusBuilder {
  typedef AudioStatus Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_input_active(bool input_active) {
    fbb_.AddElement<uint8_t>(AudioStatus::VT_INPUT_ACTIVE, static_cast<uint8_t>(input_active), 0);
  }
  void add_sample_rate(uint32_t sample_rate) {
    fbb_.AddElement<uint32_t>(AudioStatus::VT_SAMPLE_RATE, sample_rate, 0);
  }
  void add_buffer_utilization(float buffer_utilization) {
    fbb_.AddElement<float>(AudioStatus::VT_BUFFER_UTILIZATION, buffer_utilization, 0.0f);
  }
  void add_audio_dropouts(uint32_t audio_dropouts) {
    fbb_.AddElement<uint32_t>(AudioStatus::VT_AUDIO_DROPOUTS, audio_dropouts, 0);
  }
  void add_latency_ms(uint16_t latency_ms) {
    fbb_.AddElement<uint16_t>(AudioStatus::VT_LATENCY_MS, latency_ms, 0);
  }
  void add_microphone_gain(float microphone_gain) {
    fbb_.AddElement<float>(AudioStatus::VT_MICROPHONE_GAIN, microphone_gain, 0.0f);
  }
  explicit AudioStatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AudioStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AudioStatus>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AudioStatus> CreateAudioStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool input_active = false,
    uint32_t sample_rate = 0,
    float buffer_utilization = 0.0f,
    uint32_t audio_dropouts = 0,
    uint16_t latency_ms = 0,
    float microphone_gain = 0.0f) {
  AudioStatusBuilder builder_(_fbb);
  builder_.add_microphone_gain(microphone_gain);
  builder_.add_audio_dropouts(audio_dropouts);
  builder_.add_buffer_utilization(buffer_utilization);
  builder_.add_sample_rate(sample_rate);
  builder_.add_latency_ms(latency_ms);
  builder_.add_input_active(input_active);
  return builder_.Finish();
}

struct AudioCalibrationData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AudioCalibrationDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CALIBRATED_GAIN = 4,
    VT_NOISE_FLOOR = 6,
    VT_OPTIMAL_RANGE_MIN = 8,
    VT_OPTIMAL_RANGE_MAX = 10
  };
  float calibrated_gain() const {
    return GetField<float>(VT_CALIBRATED_GAIN, 0.0f);
  }
  float noise_floor() const {
    return GetField<float>(VT_NOISE_FLOOR, 0.0f);
  }
  float optimal_range_min() const {
    return GetField<float>(VT_OPTIMAL_RANGE_MIN, 0.0f);
  }
  float optimal_range_max() const {
    return GetField<float>(VT_OPTIMAL_RANGE_MAX, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_CALIBRATED_GAIN, 4) &&
           VerifyField<float>(verifier, VT_NOISE_FLOOR, 4) &&
           VerifyField<float>(verifier, VT_OPTIMAL_RANGE_MIN, 4) &&
           VerifyField<float>(verifier, VT_OPTIMAL_RANGE_MAX, 4) &&
           verifier.EndTable();
  }
};

struct AudioCalibrationDataBuilder {
  typedef AudioCalibrationData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_calibrated_gain(float calibrated_gain) {
    fbb_.AddElement<float>(AudioCalibrationData::VT_CALIBRATED_GAIN, calibrated_gain, 0.0f);
  }
  void add_noise_floor(float noise_floor) {
    fbb_.AddElement<float>(AudioCalibrationData::VT_NOISE_FLOOR, noise_floor, 0.0f);
  }
  void add_optimal_range_min(float optimal_range_min) {
    fbb_.AddElement<float>(AudioCalibrationData::VT_OPTIMAL_RANGE_MIN, optimal_range_min, 0.0f);
  }
  void add_optimal_range_max(float optimal_range_max) {
    fbb_.AddElement<float>(AudioCalibrationData::VT_OPTIMAL_RANGE_MAX, optimal_range_max, 0.0f);
  }
  explicit AudioCalibrationDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AudioCalibrationData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AudioCalibrationData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AudioCalibrationData> CreateAudioCalibrationData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float calibrated_gain = 0.0f,
    float noise_floor = 0.0f,
    float optimal_range_min = 0.0f,
    float optimal_range_max = 0.0f) {
  AudioCalibrationDataBuilder builder_(_fbb);
  builder_.add_optimal_range_max(optimal_range_max);
  builder_.add_optimal_range_min(optimal_range_min);
  builder_.add_noise_floor(noise_floor);
  builder_.add_calibrated_gain(calibrated_gain);
  return builder_.Finish();
}

struct ConfigUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConfigUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BPM_CONFIG = 4,
    VT_AUDIO_CONFIG = 6,
    VT_NETWORK_CONFIG = 8,
    VT_DISPLAY_CONFIG = 10
  };
  const sparesparrow::bpm::BPMConfig *bpm_config() const {
    return GetPointer<const sparesparrow::bpm::BPMConfig *>(VT_BPM_CONFIG);
  }
  const sparesparrow::bpm::AudioConfig *audio_config() const {
    return GetPointer<const sparesparrow::bpm::AudioConfig *>(VT_AUDIO_CONFIG);
  }
  const sparesparrow::bpm::NetworkConfig *network_config() const {
    return GetPointer<const sparesparrow::bpm::NetworkConfig *>(VT_NETWORK_CONFIG);
  }
  const sparesparrow::bpm::DisplayConfig *display_config() const {
    return GetPointer<const sparesparrow::bpm::DisplayConfig *>(VT_DISPLAY_CONFIG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BPM_CONFIG) &&
           verifier.VerifyTable(bpm_config()) &&
           VerifyOffset(verifier, VT_AUDIO_CONFIG) &&
           verifier.VerifyTable(audio_config()) &&
           VerifyOffset(verifier, VT_NETWORK_CONFIG) &&
           verifier.VerifyTable(network_config()) &&
           VerifyOffset(verifier, VT_DISPLAY_CONFIG) &&
           verifier.VerifyTable(display_config()) &&
           verifier.EndTable();
  }
};

struct ConfigUpdateBuilder {
  typedef ConfigUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_bpm_config(::flatbuffers::Offset<sparesparrow::bpm::BPMConfig> bpm_config) {
    fbb_.AddOffset(ConfigUpdate::VT_BPM_CONFIG, bpm_config);
  }
  void add_audio_config(::flatbuffers::Offset<sparesparrow::bpm::AudioConfig> audio_config) {
    fbb_.AddOffset(ConfigUpdate::VT_AUDIO_CONFIG, audio_config);
  }
  void add_network_config(::flatbuffers::Offset<sparesparrow::bpm::NetworkConfig> network_config) {
    fbb_.AddOffset(ConfigUpdate::VT_NETWORK_CONFIG, network_config);
  }
  void add_display_config(::flatbuffers::Offset<sparesparrow::bpm::DisplayConfig> display_config) {
    fbb_.AddOffset(ConfigUpdate::VT_DISPLAY_CONFIG, display_config);
  }
  explicit ConfigUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConfigUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConfigUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConfigUpdate> CreateConfigUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<sparesparrow::bpm::BPMConfig> bpm_config = 0,
    ::flatbuffers::Offset<sparesparrow::bpm::AudioConfig> audio_config = 0,
    ::flatbuffers::Offset<sparesparrow::bpm::NetworkConfig> network_config = 0,
    ::flatbuffers::Offset<sparesparrow::bpm::DisplayConfig> display_config = 0) {
  ConfigUpdateBuilder builder_(_fbb);
  builder_.add_display_config(display_config);
  builder_.add_network_config(network_config);
  builder_.add_audio_config(audio_config);
  builder_.add_bpm_config(bpm_config);
  return builder_.Finish();
}

struct BPMConfig FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BPMConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_BPM = 4,
    VT_MAX_BPM = 6,
    VT_DETECTION_THRESHOLD = 8,
    VT_MIN_CONFIDENCE = 10,
    VT_ANALYSIS_WINDOW_MS = 12,
    VT_HISTORY_LENGTH = 14
  };
  uint8_t min_bpm() const {
    return GetField<uint8_t>(VT_MIN_BPM, 60);
  }
  uint8_t max_bpm() const {
    return GetField<uint8_t>(VT_MAX_BPM, 200);
  }
  float detection_threshold() const {
    return GetField<float>(VT_DETECTION_THRESHOLD, 0.3f);
  }
  float min_confidence() const {
    return GetField<float>(VT_MIN_CONFIDENCE, 0.6f);
  }
  uint16_t analysis_window_ms() const {
    return GetField<uint16_t>(VT_ANALYSIS_WINDOW_MS, 2000);
  }
  uint16_t history_length() const {
    return GetField<uint16_t>(VT_HISTORY_LENGTH, 8);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MIN_BPM, 1) &&
           VerifyField<uint8_t>(verifier, VT_MAX_BPM, 1) &&
           VerifyField<float>(verifier, VT_DETECTION_THRESHOLD, 4) &&
           VerifyField<float>(verifier, VT_MIN_CONFIDENCE, 4) &&
           VerifyField<uint16_t>(verifier, VT_ANALYSIS_WINDOW_MS, 2) &&
           VerifyField<uint16_t>(verifier, VT_HISTORY_LENGTH, 2) &&
           verifier.EndTable();
  }
};

struct BPMConfigBuilder {
  typedef BPMConfig Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min_bpm(uint8_t min_bpm) {
    fbb_.AddElement<uint8_t>(BPMConfig::VT_MIN_BPM, min_bpm, 60);
  }
  void add_max_bpm(uint8_t max_bpm) {
    fbb_.AddElement<uint8_t>(BPMConfig::VT_MAX_BPM, max_bpm, 200);
  }
  void add_detection_threshold(float detection_threshold) {
    fbb_.AddElement<float>(BPMConfig::VT_DETECTION_THRESHOLD, detection_threshold, 0.3f);
  }
  void add_min_confidence(float min_confidence) {
    fbb_.AddElement<float>(BPMConfig::VT_MIN_CONFIDENCE, min_confidence, 0.6f);
  }
  void add_analysis_window_ms(uint16_t analysis_window_ms) {
    fbb_.AddElement<uint16_t>(BPMConfig::VT_ANALYSIS_WINDOW_MS, analysis_window_ms, 2000);
  }
  void add_history_length(uint16_t history_length) {
    fbb_.AddElement<uint16_t>(BPMConfig::VT_HISTORY_LENGTH, history_length, 8);
  }
  explicit BPMConfigBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BPMConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BPMConfig>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BPMConfig> CreateBPMConfig(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t min_bpm = 60,
    uint8_t max_bpm = 200,
    float detection_threshold = 0.3f,
    float min_confidence = 0.6f,
    uint16_t analysis_window_ms = 2000,
    uint16_t history_length = 8) {
  BPMConfigBuilder builder_(_fbb);
  builder_.add_min_confidence(min_confidence);
  builder_.add_detection_threshold(detection_threshold);
  builder_.add_history_length(history_length);
  builder_.add_analysis_window_ms(analysis_window_ms);
  builder_.add_max_bpm(max_bpm);
  builder_.add_min_bpm(min_bpm);
  return builder_.Finish();
}

struct AudioConfig FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AudioConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MICROPHONE_PIN = 4,
    VT_SAMPLE_RATE = 6,
    VT_FFT_SIZE = 8,
    VT_BUFFER_SIZE = 10,
    VT_HIGH_PASS_CUTOFF = 12,
    VT_LOW_PASS_CUTOFF = 14,
    VT_AGC_ENABLED = 16
  };
  uint8_t microphone_pin() const {
    return GetField<uint8_t>(VT_MICROPHONE_PIN, 32);
  }
  uint16_t sample_rate() const {
    return GetField<uint16_t>(VT_SAMPLE_RATE, 25000);
  }
  uint16_t fft_size() const {
    return GetField<uint16_t>(VT_FFT_SIZE, 1024);
  }
  uint16_t buffer_size() const {
    return GetField<uint16_t>(VT_BUFFER_SIZE, 2048);
  }
  uint16_t high_pass_cutoff() const {
    return GetField<uint16_t>(VT_HIGH_PASS_CUTOFF, 20);
  }
  uint16_t low_pass_cutoff() const {
    return GetField<uint16_t>(VT_LOW_PASS_CUTOFF, 8000);
  }
  bool agc_enabled() const {
    return GetField<uint8_t>(VT_AGC_ENABLED, 1) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MICROPHONE_PIN, 1) &&
           VerifyField<uint16_t>(verifier, VT_SAMPLE_RATE, 2) &&
           VerifyField<uint16_t>(verifier, VT_FFT_SIZE, 2) &&
           VerifyField<uint16_t>(verifier, VT_BUFFER_SIZE, 2) &&
           VerifyField<uint16_t>(verifier, VT_HIGH_PASS_CUTOFF, 2) &&
           VerifyField<uint16_t>(verifier, VT_LOW_PASS_CUTOFF, 2) &&
           VerifyField<uint8_t>(verifier, VT_AGC_ENABLED, 1) &&
           verifier.EndTable();
  }
};

struct AudioConfigBuilder {
  typedef AudioConfig Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_microphone_pin(uint8_t microphone_pin) {
    fbb_.AddElement<uint8_t>(AudioConfig::VT_MICROPHONE_PIN, microphone_pin, 32);
  }
  void add_sample_rate(uint16_t sample_rate) {
    fbb_.AddElement<uint16_t>(AudioConfig::VT_SAMPLE_RATE, sample_rate, 25000);
  }
  void add_fft_size(uint16_t fft_size) {
    fbb_.AddElement<uint16_t>(AudioConfig::VT_FFT_SIZE, fft_size, 1024);
  }
  void add_buffer_size(uint16_t buffer_size) {
    fbb_.AddElement<uint16_t>(AudioConfig::VT_BUFFER_SIZE, buffer_size, 2048);
  }
  void add_high_pass_cutoff(uint16_t high_pass_cutoff) {
    fbb_.AddElement<uint16_t>(AudioConfig::VT_HIGH_PASS_CUTOFF, high_pass_cutoff, 20);
  }
  void add_low_pass_cutoff(uint16_t low_pass_cutoff) {
    fbb_.AddElement<uint16_t>(AudioConfig::VT_LOW_PASS_CUTOFF, low_pass_cutoff, 8000);
  }
  void add_agc_enabled(bool agc_enabled) {
    fbb_.AddElement<uint8_t>(AudioConfig::VT_AGC_ENABLED, static_cast<uint8_t>(agc_enabled), 1);
  }
  explicit AudioConfigBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AudioConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AudioConfig>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AudioConfig> CreateAudioConfig(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t microphone_pin = 32,
    uint16_t sample_rate = 25000,
    uint16_t fft_size = 1024,
    uint16_t buffer_size = 2048,
    uint16_t high_pass_cutoff = 20,
    uint16_t low_pass_cutoff = 8000,
    bool agc_enabled = true) {
  AudioConfigBuilder builder_(_fbb);
  builder_.add_low_pass_cutoff(low_pass_cutoff);
  builder_.add_high_pass_cutoff(high_pass_cutoff);
  builder_.add_buffer_size(buffer_size);
  builder_.add_fft_size(fft_size);
  builder_.add_sample_rate(sample_rate);
  builder_.add_agc_enabled(agc_enabled);
  builder_.add_microphone_pin(microphone_pin);
  return builder_.Finish();
}

struct NetworkConfig FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetworkConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIFI_SSID = 4,
    VT_WIFI_PASSWORD = 6,
    VT_HOSTNAME = 8,
    VT_WEB_PORT = 10,
    VT_WEBSOCKET_PORT = 12,
    VT_MULTICAST_GROUP = 14,
    VT_MULTICAST_PORT = 16
  };
  const ::flatbuffers::String *wifi_ssid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WIFI_SSID);
  }
  const ::flatbuffers::String *wifi_password() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WIFI_PASSWORD);
  }
  const ::flatbuffers::String *hostname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HOSTNAME);
  }
  uint16_t web_port() const {
    return GetField<uint16_t>(VT_WEB_PORT, 80);
  }
  uint16_t websocket_port() const {
    return GetField<uint16_t>(VT_WEBSOCKET_PORT, 81);
  }
  const ::flatbuffers::String *multicast_group() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MULTICAST_GROUP);
  }
  uint16_t multicast_port() const {
    return GetField<uint16_t>(VT_MULTICAST_PORT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WIFI_SSID) &&
           verifier.VerifyString(wifi_ssid()) &&
           VerifyOffset(verifier, VT_WIFI_PASSWORD) &&
           verifier.VerifyString(wifi_password()) &&
           VerifyOffset(verifier, VT_HOSTNAME) &&
           verifier.VerifyString(hostname()) &&
           VerifyField<uint16_t>(verifier, VT_WEB_PORT, 2) &&
           VerifyField<uint16_t>(verifier, VT_WEBSOCKET_PORT, 2) &&
           VerifyOffset(verifier, VT_MULTICAST_GROUP) &&
           verifier.VerifyString(multicast_group()) &&
           VerifyField<uint16_t>(verifier, VT_MULTICAST_PORT, 2) &&
           verifier.EndTable();
  }
};

struct NetworkConfigBuilder {
  typedef NetworkConfig Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_wifi_ssid(::flatbuffers::Offset<::flatbuffers::String> wifi_ssid) {
    fbb_.AddOffset(NetworkConfig::VT_WIFI_SSID, wifi_ssid);
  }
  void add_wifi_password(::flatbuffers::Offset<::flatbuffers::String> wifi_password) {
    fbb_.AddOffset(NetworkConfig::VT_WIFI_PASSWORD, wifi_password);
  }
  void add_hostname(::flatbuffers::Offset<::flatbuffers::String> hostname) {
    fbb_.AddOffset(NetworkConfig::VT_HOSTNAME, hostname);
  }
  void add_web_port(uint16_t web_port) {
    fbb_.AddElement<uint16_t>(NetworkConfig::VT_WEB_PORT, web_port, 80);
  }
  void add_websocket_port(uint16_t websocket_port) {
    fbb_.AddElement<uint16_t>(NetworkConfig::VT_WEBSOCKET_PORT, websocket_port, 81);
  }
  void add_multicast_group(::flatbuffers::Offset<::flatbuffers::String> multicast_group) {
    fbb_.AddOffset(NetworkConfig::VT_MULTICAST_GROUP, multicast_group);
  }
  void add_multicast_port(uint16_t multicast_port) {
    fbb_.AddElement<uint16_t>(NetworkConfig::VT_MULTICAST_PORT, multicast_port, 0);
  }
  explicit NetworkConfigBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetworkConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetworkConfig>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetworkConfig> CreateNetworkConfig(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> wifi_ssid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> wifi_password = 0,
    ::flatbuffers::Offset<::flatbuffers::String> hostname = 0,
    uint16_t web_port = 80,
    uint16_t websocket_port = 81,
    ::flatbuffers::Offset<::flatbuffers::String> multicast_group = 0,
    uint16_t multicast_port = 0) {
  NetworkConfigBuilder builder_(_fbb);
  builder_.add_multicast_group(multicast_group);
  builder_.add_hostname(hostname);
  builder_.add_wifi_password(wifi_password);
  builder_.add_wifi_ssid(wifi_ssid);
  builder_.add_multicast_port(multicast_port);
  builder_.add_websocket_port(websocket_port);
  builder_.add_web_port(web_port);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetworkConfig> CreateNetworkConfigDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *wifi_ssid = nullptr,
    const char *wifi_password = nullptr,
    const char *hostname = nullptr,
    uint16_t web_port = 80,
    uint16_t websocket_port = 81,
    const char *multicast_group = nullptr,
    uint16_t multicast_port = 0) {
  auto wifi_ssid__ = wifi_ssid ? _fbb.CreateString(wifi_ssid) : 0;
  auto wifi_password__ = wifi_password ? _fbb.CreateString(wifi_password) : 0;
  auto hostname__ = hostname ? _fbb.CreateString(hostname) : 0;
  auto multicast_group__ = multicast_group ? _fbb.CreateString(multicast_group) : 0;
  return sparesparrow::bpm::CreateNetworkConfig(
      _fbb,
      wifi_ssid__,
      wifi_password__,
      hostname__,
      web_port,
      websocket_port,
      multicast_group__,
      multicast_port);
}

struct DisplayConfig FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DisplayConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DISPLAY_TYPE = 4,
    VT_OLED_ADDRESS = 6,
    VT_OLED_SDA_PIN = 8,
    VT_OLED_SCL_PIN = 10,
    VT_TM1637_CLK_PIN = 12,
    VT_TM1637_DIO_PIN = 14,
    VT_BRIGHTNESS = 16,
    VT_UPDATE_INTERVAL_MS = 18,
    VT_AUTO_BRIGHTNESS = 20
  };
  sparesparrow::bpm::DisplayType display_type() const {
    return static_cast<sparesparrow::bpm::DisplayType>(GetField<int8_t>(VT_DISPLAY_TYPE, 0));
  }
  uint8_t oled_address() const {
    return GetField<uint8_t>(VT_OLED_ADDRESS, 60);
  }
  uint8_t oled_sda_pin() const {
    return GetField<uint8_t>(VT_OLED_SDA_PIN, 21);
  }
  uint8_t oled_scl_pin() const {
    return GetField<uint8_t>(VT_OLED_SCL_PIN, 22);
  }
  uint8_t tm1637_clk_pin() const {
    return GetField<uint8_t>(VT_TM1637_CLK_PIN, 22);
  }
  uint8_t tm1637_dio_pin() const {
    return GetField<uint8_t>(VT_TM1637_DIO_PIN, 23);
  }
  uint8_t brightness() const {
    return GetField<uint8_t>(VT_BRIGHTNESS, 128);
  }
  uint16_t update_interval_ms() const {
    return GetField<uint16_t>(VT_UPDATE_INTERVAL_MS, 100);
  }
  bool auto_brightness() const {
    return GetField<uint8_t>(VT_AUTO_BRIGHTNESS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_DISPLAY_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_OLED_ADDRESS, 1) &&
           VerifyField<uint8_t>(verifier, VT_OLED_SDA_PIN, 1) &&
           VerifyField<uint8_t>(verifier, VT_OLED_SCL_PIN, 1) &&
           VerifyField<uint8_t>(verifier, VT_TM1637_CLK_PIN, 1) &&
           VerifyField<uint8_t>(verifier, VT_TM1637_DIO_PIN, 1) &&
           VerifyField<uint8_t>(verifier, VT_BRIGHTNESS, 1) &&
           VerifyField<uint16_t>(verifier, VT_UPDATE_INTERVAL_MS, 2) &&
           VerifyField<uint8_t>(verifier, VT_AUTO_BRIGHTNESS, 1) &&
           verifier.EndTable();
  }
};

struct DisplayConfigBuilder {
  typedef DisplayConfig Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_display_type(sparesparrow::bpm::DisplayType display_type) {
    fbb_.AddElement<int8_t>(DisplayConfig::VT_DISPLAY_TYPE, static_cast<int8_t>(display_type), 0);
  }
  void add_oled_address(uint8_t oled_address) {
    fbb_.AddElement<uint8_t>(DisplayConfig::VT_OLED_ADDRESS, oled_address, 60);
  }
  void add_oled_sda_pin(uint8_t oled_sda_pin) {
    fbb_.AddElement<uint8_t>(DisplayConfig::VT_OLED_SDA_PIN, oled_sda_pin, 21);
  }
  void add_oled_scl_pin(uint8_t oled_scl_pin) {
    fbb_.AddElement<uint8_t>(DisplayConfig::VT_OLED_SCL_PIN, oled_scl_pin, 22);
  }
  void add_tm1637_clk_pin(uint8_t tm1637_clk_pin) {
    fbb_.AddElement<uint8_t>(DisplayConfig::VT_TM1637_CLK_PIN, tm1637_clk_pin, 22);
  }
  void add_tm1637_dio_pin(uint8_t tm1637_dio_pin) {
    fbb_.AddElement<uint8_t>(DisplayConfig::VT_TM1637_DIO_PIN, tm1637_dio_pin, 23);
  }
  void add_brightness(uint8_t brightness) {
    fbb_.AddElement<uint8_t>(DisplayConfig::VT_BRIGHTNESS, brightness, 128);
  }
  void add_update_interval_ms(uint16_t update_interval_ms) {
    fbb_.AddElement<uint16_t>(DisplayConfig::VT_UPDATE_INTERVAL_MS, update_interval_ms, 100);
  }
  void add_auto_brightness(bool auto_brightness) {
    fbb_.AddElement<uint8_t>(DisplayConfig::VT_AUTO_BRIGHTNESS, static_cast<uint8_t>(auto_brightness), 0);
  }
  explicit DisplayConfigBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DisplayConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DisplayConfig>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DisplayConfig> CreateDisplayConfig(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    sparesparrow::bpm::DisplayType display_type = sparesparrow::bpm::DisplayType::NONE,
    uint8_t oled_address = 60,
    uint8_t oled_sda_pin = 21,
    uint8_t oled_scl_pin = 22,
    uint8_t tm1637_clk_pin = 22,
    uint8_t tm1637_dio_pin = 23,
    uint8_t brightness = 128,
    uint16_t update_interval_ms = 100,
    bool auto_brightness = false) {
  DisplayConfigBuilder builder_(_fbb);
  builder_.add_update_interval_ms(update_interval_ms);
  builder_.add_auto_brightness(auto_brightness);
  builder_.add_brightness(brightness);
  builder_.add_tm1637_dio_pin(tm1637_dio_pin);
  builder_.add_tm1637_clk_pin(tm1637_clk_pin);
  builder_.add_oled_scl_pin(oled_scl_pin);
  builder_.add_oled_sda_pin(oled_sda_pin);
  builder_.add_oled_address(oled_address);
  builder_.add_display_type(display_type);
  return builder_.Finish();
}

struct DiagnosticsData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DiagnosticsDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SYSTEM_INFO = 4,
    VT_AUDIO_DIAGNOSTICS = 6,
    VT_NETWORK_DIAGNOSTICS = 8,
    VT_PERFORMANCE_METRICS = 10
  };
  const sparesparrow::bpm::SystemInfo *system_info() const {
    return GetPointer<const sparesparrow::bpm::SystemInfo *>(VT_SYSTEM_INFO);
  }
  const sparesparrow::bpm::AudioDiagnostics *audio_diagnostics() const {
    return GetPointer<const sparesparrow::bpm::AudioDiagnostics *>(VT_AUDIO_DIAGNOSTICS);
  }
  const sparesparrow::bpm::NetworkDiagnostics *network_diagnostics() const {
    return GetPointer<const sparesparrow::bpm::NetworkDiagnostics *>(VT_NETWORK_DIAGNOSTICS);
  }
  const sparesparrow::bpm::PerformanceMetrics *performance_metrics() const {
    return GetPointer<const sparesparrow::bpm::PerformanceMetrics *>(VT_PERFORMANCE_METRICS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SYSTEM_INFO) &&
           verifier.VerifyTable(system_info()) &&
           VerifyOffset(verifier, VT_AUDIO_DIAGNOSTICS) &&
           verifier.VerifyTable(audio_diagnostics()) &&
           VerifyOffset(verifier, VT_NETWORK_DIAGNOSTICS) &&
           verifier.VerifyTable(network_diagnostics()) &&
           VerifyOffset(verifier, VT_PERFORMANCE_METRICS) &&
           verifier.VerifyTable(performance_metrics()) &&
           verifier.EndTable();
  }
};

struct DiagnosticsDataBuilder {
  typedef DiagnosticsData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_system_info(::flatbuffers::Offset<sparesparrow::bpm::SystemInfo> system_info) {
    fbb_.AddOffset(DiagnosticsData::VT_SYSTEM_INFO, system_info);
  }
  void add_audio_diagnostics(::flatbuffers::Offset<sparesparrow::bpm::AudioDiagnostics> audio_diagnostics) {
    fbb_.AddOffset(DiagnosticsData::VT_AUDIO_DIAGNOSTICS, audio_diagnostics);
  }
  void add_network_diagnostics(::flatbuffers::Offset<sparesparrow::bpm::NetworkDiagnostics> network_diagnostics) {
    fbb_.AddOffset(DiagnosticsData::VT_NETWORK_DIAGNOSTICS, network_diagnostics);
  }
  void add_performance_metrics(::flatbuffers::Offset<sparesparrow::bpm::PerformanceMetrics> performance_metrics) {
    fbb_.AddOffset(DiagnosticsData::VT_PERFORMANCE_METRICS, performance_metrics);
  }
  explicit DiagnosticsDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DiagnosticsData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DiagnosticsData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DiagnosticsData> CreateDiagnosticsData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<sparesparrow::bpm::SystemInfo> system_info = 0,
    ::flatbuffers::Offset<sparesparrow::bpm::AudioDiagnostics> audio_diagnostics = 0,
    ::flatbuffers::Offset<sparesparrow::bpm::NetworkDiagnostics> network_diagnostics = 0,
    ::flatbuffers::Offset<sparesparrow::bpm::PerformanceMetrics> performance_metrics = 0) {
  DiagnosticsDataBuilder builder_(_fbb);
  builder_.add_performance_metrics(performance_metrics);
  builder_.add_network_diagnostics(network_diagnostics);
  builder_.add_audio_diagnostics(audio_diagnostics);
  builder_.add_system_info(system_info);
  return builder_.Finish();
}

struct SystemInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SystemInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIRMWARE_VERSION = 4,
    VT_HARDWARE_VERSION = 6,
    VT_BUILD_DATE = 8,
    VT_UPTIME_SECONDS = 10,
    VT_RESET_REASON = 12
  };
  const ::flatbuffers::String *firmware_version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIRMWARE_VERSION);
  }
  const ::flatbuffers::String *hardware_version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HARDWARE_VERSION);
  }
  const ::flatbuffers::String *build_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BUILD_DATE);
  }
  uint64_t uptime_seconds() const {
    return GetField<uint64_t>(VT_UPTIME_SECONDS, 0);
  }
  const ::flatbuffers::String *reset_reason() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESET_REASON);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIRMWARE_VERSION) &&
           verifier.VerifyString(firmware_version()) &&
           VerifyOffset(verifier, VT_HARDWARE_VERSION) &&
           verifier.VerifyString(hardware_version()) &&
           VerifyOffset(verifier, VT_BUILD_DATE) &&
           verifier.VerifyString(build_date()) &&
           VerifyField<uint64_t>(verifier, VT_UPTIME_SECONDS, 8) &&
           VerifyOffset(verifier, VT_RESET_REASON) &&
           verifier.VerifyString(reset_reason()) &&
           verifier.EndTable();
  }
};

struct SystemInfoBuilder {
  typedef SystemInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_firmware_version(::flatbuffers::Offset<::flatbuffers::String> firmware_version) {
    fbb_.AddOffset(SystemInfo::VT_FIRMWARE_VERSION, firmware_version);
  }
  void add_hardware_version(::flatbuffers::Offset<::flatbuffers::String> hardware_version) {
    fbb_.AddOffset(SystemInfo::VT_HARDWARE_VERSION, hardware_version);
  }
  void add_build_date(::flatbuffers::Offset<::flatbuffers::String> build_date) {
    fbb_.AddOffset(SystemInfo::VT_BUILD_DATE, build_date);
  }
  void add_uptime_seconds(uint64_t uptime_seconds) {
    fbb_.AddElement<uint64_t>(SystemInfo::VT_UPTIME_SECONDS, uptime_seconds, 0);
  }
  void add_reset_reason(::flatbuffers::Offset<::flatbuffers::String> reset_reason) {
    fbb_.AddOffset(SystemInfo::VT_RESET_REASON, reset_reason);
  }
  explicit SystemInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SystemInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SystemInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SystemInfo> CreateSystemInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> firmware_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> hardware_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> build_date = 0,
    uint64_t uptime_seconds = 0,
    ::flatbuffers::Offset<::flatbuffers::String> reset_reason = 0) {
  SystemInfoBuilder builder_(_fbb);
  builder_.add_uptime_seconds(uptime_seconds);
  builder_.add_reset_reason(reset_reason);
  builder_.add_build_date(build_date);
  builder_.add_hardware_version(hardware_version);
  builder_.add_firmware_version(firmware_version);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SystemInfo> CreateSystemInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *firmware_version = nullptr,
    const char *hardware_version = nullptr,
    const char *build_date = nullptr,
    uint64_t uptime_seconds = 0,
    const char *reset_reason = nullptr) {
  auto firmware_version__ = firmware_version ? _fbb.CreateString(firmware_version) : 0;
  auto hardware_version__ = hardware_version ? _fbb.CreateString(hardware_version) : 0;
  auto build_date__ = build_date ? _fbb.CreateString(build_date) : 0;
  auto reset_reason__ = reset_reason ? _fbb.CreateString(reset_reason) : 0;
  return sparesparrow::bpm::CreateSystemInfo(
      _fbb,
      firmware_version__,
      hardware_version__,
      build_date__,
      uptime_seconds,
      reset_reason__);
}

struct AudioDiagnostics FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AudioDiagnosticsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SAMPLES_PROCESSED = 4,
    VT_BPM_DETECTIONS = 6,
    VT_AVERAGE_CONFIDENCE = 8,
    VT_SIGNAL_QUALITY_SCORE = 10,
    VT_AUDIO_DROPOUTS = 12
  };
  uint64_t samples_processed() const {
    return GetField<uint64_t>(VT_SAMPLES_PROCESSED, 0);
  }
  uint32_t bpm_detections() const {
    return GetField<uint32_t>(VT_BPM_DETECTIONS, 0);
  }
  float average_confidence() const {
    return GetField<float>(VT_AVERAGE_CONFIDENCE, 0.0f);
  }
  float signal_quality_score() const {
    return GetField<float>(VT_SIGNAL_QUALITY_SCORE, 0.0f);
  }
  uint32_t audio_dropouts() const {
    return GetField<uint32_t>(VT_AUDIO_DROPOUTS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SAMPLES_PROCESSED, 8) &&
           VerifyField<uint32_t>(verifier, VT_BPM_DETECTIONS, 4) &&
           VerifyField<float>(verifier, VT_AVERAGE_CONFIDENCE, 4) &&
           VerifyField<float>(verifier, VT_SIGNAL_QUALITY_SCORE, 4) &&
           VerifyField<uint32_t>(verifier, VT_AUDIO_DROPOUTS, 4) &&
           verifier.EndTable();
  }
};

struct AudioDiagnosticsBuilder {
  typedef AudioDiagnostics Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_samples_processed(uint64_t samples_processed) {
    fbb_.AddElement<uint64_t>(AudioDiagnostics::VT_SAMPLES_PROCESSED, samples_processed, 0);
  }
  void add_bpm_detections(uint32_t bpm_detections) {
    fbb_.AddElement<uint32_t>(AudioDiagnostics::VT_BPM_DETECTIONS, bpm_detections, 0);
  }
  void add_average_confidence(float average_confidence) {
    fbb_.AddElement<float>(AudioDiagnostics::VT_AVERAGE_CONFIDENCE, average_confidence, 0.0f);
  }
  void add_signal_quality_score(float signal_quality_score) {
    fbb_.AddElement<float>(AudioDiagnostics::VT_SIGNAL_QUALITY_SCORE, signal_quality_score, 0.0f);
  }
  void add_audio_dropouts(uint32_t audio_dropouts) {
    fbb_.AddElement<uint32_t>(AudioDiagnostics::VT_AUDIO_DROPOUTS, audio_dropouts, 0);
  }
  explicit AudioDiagnosticsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AudioDiagnostics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AudioDiagnostics>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AudioDiagnostics> CreateAudioDiagnostics(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t samples_processed = 0,
    uint32_t bpm_detections = 0,
    float average_confidence = 0.0f,
    float signal_quality_score = 0.0f,
    uint32_t audio_dropouts = 0) {
  AudioDiagnosticsBuilder builder_(_fbb);
  builder_.add_samples_processed(samples_processed);
  builder_.add_audio_dropouts(audio_dropouts);
  builder_.add_signal_quality_score(signal_quality_score);
  builder_.add_average_confidence(average_confidence);
  builder_.add_bpm_detections(bpm_detections);
  return builder_.Finish();
}

struct NetworkDiagnostics FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetworkDiagnosticsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BYTES_SENT = 4,
    VT_BYTES_RECEIVED = 6,
    VT_CONNECTIONS_ACCEPTED = 8,
    VT_WEBSOCKET_CLIENTS = 10,
    VT_MULTICAST_CLIENTS = 12
  };
  uint64_t bytes_sent() const {
    return GetField<uint64_t>(VT_BYTES_SENT, 0);
  }
  uint64_t bytes_received() const {
    return GetField<uint64_t>(VT_BYTES_RECEIVED, 0);
  }
  uint32_t connections_accepted() const {
    return GetField<uint32_t>(VT_CONNECTIONS_ACCEPTED, 0);
  }
  uint8_t websocket_clients() const {
    return GetField<uint8_t>(VT_WEBSOCKET_CLIENTS, 0);
  }
  uint8_t multicast_clients() const {
    return GetField<uint8_t>(VT_MULTICAST_CLIENTS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_BYTES_SENT, 8) &&
           VerifyField<uint64_t>(verifier, VT_BYTES_RECEIVED, 8) &&
           VerifyField<uint32_t>(verifier, VT_CONNECTIONS_ACCEPTED, 4) &&
           VerifyField<uint8_t>(verifier, VT_WEBSOCKET_CLIENTS, 1) &&
           VerifyField<uint8_t>(verifier, VT_MULTICAST_CLIENTS, 1) &&
           verifier.EndTable();
  }
};

struct NetworkDiagnosticsBuilder {
  typedef NetworkDiagnostics Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_bytes_sent(uint64_t bytes_sent) {
    fbb_.AddElement<uint64_t>(NetworkDiagnostics::VT_BYTES_SENT, bytes_sent, 0);
  }
  void add_bytes_received(uint64_t bytes_received) {
    fbb_.AddElement<uint64_t>(NetworkDiagnostics::VT_BYTES_RECEIVED, bytes_received, 0);
  }
  void add_connections_accepted(uint32_t connections_accepted) {
    fbb_.AddElement<uint32_t>(NetworkDiagnostics::VT_CONNECTIONS_ACCEPTED, connections_accepted, 0);
  }
  void add_websocket_clients(uint8_t websocket_clients) {
    fbb_.AddElement<uint8_t>(NetworkDiagnostics::VT_WEBSOCKET_CLIENTS, websocket_clients, 0);
  }
  void add_multicast_clients(uint8_t multicast_clients) {
    fbb_.AddElement<uint8_t>(NetworkDiagnostics::VT_MULTICAST_CLIENTS, multicast_clients, 0);
  }
  explicit NetworkDiagnosticsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetworkDiagnostics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetworkDiagnostics>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetworkDiagnostics> CreateNetworkDiagnostics(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t bytes_sent = 0,
    uint64_t bytes_received = 0,
    uint32_t connections_accepted = 0,
    uint8_t websocket_clients = 0,
    uint8_t multicast_clients = 0) {
  NetworkDiagnosticsBuilder builder_(_fbb);
  builder_.add_bytes_received(bytes_received);
  builder_.add_bytes_sent(bytes_sent);
  builder_.add_connections_accepted(connections_accepted);
  builder_.add_multicast_clients(multicast_clients);
  builder_.add_websocket_clients(websocket_clients);
  return builder_.Finish();
}

struct PerformanceMetrics FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PerformanceMetricsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CPU_USAGE_PERCENT = 4,
    VT_MEMORY_USAGE_PERCENT = 6,
    VT_AUDIO_LATENCY_MS = 8,
    VT_NETWORK_LATENCY_MS = 10,
    VT_DETECTION_LATENCY_MS = 12
  };
  uint8_t cpu_usage_percent() const {
    return GetField<uint8_t>(VT_CPU_USAGE_PERCENT, 0);
  }
  uint8_t memory_usage_percent() const {
    return GetField<uint8_t>(VT_MEMORY_USAGE_PERCENT, 0);
  }
  uint16_t audio_latency_ms() const {
    return GetField<uint16_t>(VT_AUDIO_LATENCY_MS, 0);
  }
  uint16_t network_latency_ms() const {
    return GetField<uint16_t>(VT_NETWORK_LATENCY_MS, 0);
  }
  uint16_t detection_latency_ms() const {
    return GetField<uint16_t>(VT_DETECTION_LATENCY_MS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CPU_USAGE_PERCENT, 1) &&
           VerifyField<uint8_t>(verifier, VT_MEMORY_USAGE_PERCENT, 1) &&
           VerifyField<uint16_t>(verifier, VT_AUDIO_LATENCY_MS, 2) &&
           VerifyField<uint16_t>(verifier, VT_NETWORK_LATENCY_MS, 2) &&
           VerifyField<uint16_t>(verifier, VT_DETECTION_LATENCY_MS, 2) &&
           verifier.EndTable();
  }
};

struct PerformanceMetricsBuilder {
  typedef PerformanceMetrics Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cpu_usage_percent(uint8_t cpu_usage_percent) {
    fbb_.AddElement<uint8_t>(PerformanceMetrics::VT_CPU_USAGE_PERCENT, cpu_usage_percent, 0);
  }
  void add_memory_usage_percent(uint8_t memory_usage_percent) {
    fbb_.AddElement<uint8_t>(PerformanceMetrics::VT_MEMORY_USAGE_PERCENT, memory_usage_percent, 0);
  }
  void add_audio_latency_ms(uint16_t audio_latency_ms) {
    fbb_.AddElement<uint16_t>(PerformanceMetrics::VT_AUDIO_LATENCY_MS, audio_latency_ms, 0);
  }
  void add_network_latency_ms(uint16_t network_latency_ms) {
    fbb_.AddElement<uint16_t>(PerformanceMetrics::VT_NETWORK_LATENCY_MS, network_latency_ms, 0);
  }
  void add_detection_latency_ms(uint16_t detection_latency_ms) {
    fbb_.AddElement<uint16_t>(PerformanceMetrics::VT_DETECTION_LATENCY_MS, detection_latency_ms, 0);
  }
  explicit PerformanceMetricsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PerformanceMetrics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PerformanceMetrics>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PerformanceMetrics> CreatePerformanceMetrics(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t cpu_usage_percent = 0,
    uint8_t memory_usage_percent = 0,
    uint16_t audio_latency_ms = 0,
    uint16_t network_latency_ms = 0,
    uint16_t detection_latency_ms = 0) {
  PerformanceMetricsBuilder builder_(_fbb);
  builder_.add_detection_latency_ms(detection_latency_ms);
  builder_.add_network_latency_ms(network_latency_ms);
  builder_.add_audio_latency_ms(audio_latency_ms);
  builder_.add_memory_usage_percent(memory_usage_percent);
  builder_.add_cpu_usage_percent(cpu_usage_percent);
  return builder_.Finish();
}

inline bool VerifyRequestPayload(::flatbuffers::Verifier &verifier, const void *obj, RequestPayload type) {
  switch (type) {
    case RequestPayload::NONE: {
      return true;
    }
    case RequestPayload::GetStatusRequest: {
      auto ptr = reinterpret_cast<const sparesparrow::bpm::GetStatusRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestPayload::GetConfigRequest: {
      auto ptr = reinterpret_cast<const sparesparrow::bpm::GetConfigRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestPayload::SetConfigRequest: {
      auto ptr = reinterpret_cast<const sparesparrow::bpm::SetConfigRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestPayload::ResetDeviceRequest: {
      auto ptr = reinterpret_cast<const sparesparrow::bpm::ResetDeviceRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestPayload::CalibrateAudioRequest: {
      auto ptr = reinterpret_cast<const sparesparrow::bpm::CalibrateAudioRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestPayload::StartStreamingRequest: {
      auto ptr = reinterpret_cast<const sparesparrow::bpm::StartStreamingRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestPayload::StopStreamingRequest: {
      auto ptr = reinterpret_cast<const sparesparrow::bpm::StopStreamingRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestPayload::GetDiagnosticsRequest: {
      auto ptr = reinterpret_cast<const sparesparrow::bpm::GetDiagnosticsRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRequestPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<RequestPayload> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRequestPayload(
        verifier,  values->Get(i), types->GetEnum<RequestPayload>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyResponsePayload(::flatbuffers::Verifier &verifier, const void *obj, ResponsePayload type) {
  switch (type) {
    case ResponsePayload::NONE: {
      return true;
    }
    case ResponsePayload::GetStatusResponse: {
      auto ptr = reinterpret_cast<const sparesparrow::bpm::GetStatusResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePayload::GetConfigResponse: {
      auto ptr = reinterpret_cast<const sparesparrow::bpm::GetConfigResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePayload::SetConfigResponse: {
      auto ptr = reinterpret_cast<const sparesparrow::bpm::SetConfigResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePayload::ResetDeviceResponse: {
      auto ptr = reinterpret_cast<const sparesparrow::bpm::ResetDeviceResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePayload::CalibrateAudioResponse: {
      auto ptr = reinterpret_cast<const sparesparrow::bpm::CalibrateAudioResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePayload::StartStreamingResponse: {
      auto ptr = reinterpret_cast<const sparesparrow::bpm::StartStreamingResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePayload::StopStreamingResponse: {
      auto ptr = reinterpret_cast<const sparesparrow::bpm::StopStreamingResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePayload::GetDiagnosticsResponse: {
      auto ptr = reinterpret_cast<const sparesparrow::bpm::GetDiagnosticsResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyResponsePayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ResponsePayload> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResponsePayload(
        verifier,  values->Get(i), types->GetEnum<ResponsePayload>(i))) {
      return false;
    }
  }
  return true;
}

inline const sparesparrow::bpm::Response *GetResponse(const void *buf) {
  return ::flatbuffers::GetRoot<sparesparrow::bpm::Response>(buf);
}

inline const sparesparrow::bpm::Response *GetSizePrefixedResponse(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<sparesparrow::bpm::Response>(buf);
}

inline bool VerifyResponseBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<sparesparrow::bpm::Response>(nullptr);
}

inline bool VerifySizePrefixedResponseBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<sparesparrow::bpm::Response>(nullptr);
}

inline void FinishResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<sparesparrow::bpm::Response> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<sparesparrow::bpm::Response> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace bpm
}  // namespace sparesparrow

#endif  // FLATBUFFERS_GENERATED_BPM_SPARESPARROW_BPM_H_
