#!/usr/bin/env python3
"""
FlatBuffers Enum Extraction Script for ESP32 BPM Detector

This script extracts enums from FlatBuffers generated headers and creates
clean extracted header files that can be used across multiple source files.

Based on the OMS/ngaims-icd-dev approach for automated enum extraction.

Usage:
    python3 scripts/extract_flatbuffers_enums.py
"""

import re
import os
from pathlib import Path

# Constants for header generation
FLATBUFFERS_DEC = """// automatically generated by extracting enums from BPM generated files

#pragma once

#include <cstdint>"""

# Regex patterns for extracting enums and namespaces
ENUM_REGEX = r"\n+enum [A-Za-z_][A-Za-z_0-9 :{\n=,]*};"
NAMESPACE_REGEX = r"\nnamespace [a-zA-Z_][a-zA-Z_0-9]* {"
BPM_INCLUDE_REGEX = r'\n#include "Bpm([\w]+)_generated\.h"'
BPM_INCLUDE_SUB_REGEX = r'\n#include "Bpm\1_extracted.h"'


def extract_header(file_path: Path, header_file_name: Path):
    """
    Extract enums from a generated FlatBuffers header file.

    Args:
        file_path: Path to the generated header file
        header_file_name: Path for the extracted header file
    """
    print(f"Extracting enums from {file_path} -> {header_file_name}")

    with open(file_path, 'r') as file:
        content = file.read()

    # Find all include statements for BPM generated headers
    bpm_header_matches = re.finditer(BPM_INCLUDE_REGEX, content)

    # Find all namespace declarations
    namespace_matches = re.finditer(NAMESPACE_REGEX, content)

    # Find all enum declarations
    enum_matches = re.finditer(ENUM_REGEX, content)

    # Build the extracted content
    extracted_content = ''

    # Replace includes with extracted versions
    for _, match in enumerate(bpm_header_matches, start=1):
        include = match.group()
        include = re.sub(BPM_INCLUDE_REGEX, BPM_INCLUDE_SUB_REGEX, include, 0, re.MULTILINE)
        extracted_content += include

    extracted_content += '\n'

    # Add namespace declarations
    namespace_count = 0
    for namespace_count, match in enumerate(namespace_matches, start=1):
        extracted_content += match.group()
        extracted_content += '\n'

    # Add ExtEnum namespace wrapper
    extracted_content += 'namespace ExtEnum {\n'

    # Add all enums
    enum_count = 0
    for enum_count, match in enumerate(enum_matches, start=1):
        extracted_content += match.group()
        extracted_content += '\n'

    # Close namespaces (ExtEnum + all outer namespaces)
    extracted_content += '\n' + ('}\n' * (namespace_count + 1))

    # Write the extracted header file
    with open(header_file_name, 'w') as header_file:
        header_file.write(FLATBUFFERS_DEC)
        header_file.write(extracted_content)

    print(f"Extracted {enum_count} enums from {namespace_count} namespaces")


def extract_all_enums(include_dir: Path):
    """
    Extract enums from all generated FlatBuffers headers in the include directory.

    Args:
        include_dir: Directory containing generated header files
    """
    print(f"Scanning for generated FlatBuffers headers in {include_dir}")

    generated_headers = list(include_dir.glob("*_generated.h"))

    if not generated_headers:
        print("No generated FlatBuffers headers found")
        return

    print(f"Found {len(generated_headers)} generated header files")

    for generated_header in generated_headers:
        extracted_header = generated_header.parent / generated_header.name.replace('_generated.h', '_extracted.h')
        extract_header(generated_header, extracted_header)

    print("\n✅ Enum extraction completed successfully!")


def main():
    """Main function to extract enums from FlatBuffers headers"""
    script_dir = Path(__file__).parent
    project_root = script_dir.parent

    # Include directory where FlatBuffers headers are generated
    include_dir = project_root / "include"

    if not include_dir.exists():
        print(f"❌ Include directory not found: {include_dir}")
        print("Please run generate_flatbuffers.py first to generate the headers")
        return 1

    try:
        extract_all_enums(include_dir)
        return 0
    except Exception as e:
        print(f"❌ Error during enum extraction: {e}")
        return 1


if __name__ == "__main__":
    exit(main())