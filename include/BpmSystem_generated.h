// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BPMSYSTEM_SPARETOOLS_BPM_H_
#define FLATBUFFERS_GENERATED_BPMSYSTEM_SPARETOOLS_BPM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

#include "BpmAudio_generated.h"

namespace sparetools {
namespace bpm {

struct StatusUpdate;
struct StatusUpdateBuilder;

struct SystemInfo;
struct SystemInfoBuilder;

struct NetworkDiagnostics;
struct NetworkDiagnosticsBuilder;

struct PerformanceMetrics;
struct PerformanceMetricsBuilder;

struct DiagnosticsData;
struct DiagnosticsDataBuilder;

struct StatusUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatusUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPTIME_SECONDS = 4,
    VT_FREE_HEAP_BYTES = 6,
    VT_MIN_FREE_HEAP_BYTES = 8,
    VT_CPU_USAGE_PERCENT = 10,
    VT_WIFI_RSSI = 12,
    VT_AUDIO_STATUS = 14,
    VT_TEMPERATURE_CELSIUS = 16,
    VT_BATTERY_LEVEL_PERCENT = 18
  };
  uint64_t uptime_seconds() const {
    return GetField<uint64_t>(VT_UPTIME_SECONDS, 0);
  }
  uint32_t free_heap_bytes() const {
    return GetField<uint32_t>(VT_FREE_HEAP_BYTES, 0);
  }
  uint32_t min_free_heap_bytes() const {
    return GetField<uint32_t>(VT_MIN_FREE_HEAP_BYTES, 0);
  }
  uint8_t cpu_usage_percent() const {
    return GetField<uint8_t>(VT_CPU_USAGE_PERCENT, 0);
  }
  int8_t wifi_rssi() const {
    return GetField<int8_t>(VT_WIFI_RSSI, 0);
  }
  const sparetools::bpm::AudioStatus *audio_status() const {
    return GetPointer<const sparetools::bpm::AudioStatus *>(VT_AUDIO_STATUS);
  }
  float temperature_celsius() const {
    return GetField<float>(VT_TEMPERATURE_CELSIUS, 0.0f);
  }
  uint8_t battery_level_percent() const {
    return GetField<uint8_t>(VT_BATTERY_LEVEL_PERCENT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_UPTIME_SECONDS, 8) &&
           VerifyField<uint32_t>(verifier, VT_FREE_HEAP_BYTES, 4) &&
           VerifyField<uint32_t>(verifier, VT_MIN_FREE_HEAP_BYTES, 4) &&
           VerifyField<uint8_t>(verifier, VT_CPU_USAGE_PERCENT, 1) &&
           VerifyField<int8_t>(verifier, VT_WIFI_RSSI, 1) &&
           VerifyOffset(verifier, VT_AUDIO_STATUS) &&
           verifier.VerifyTable(audio_status()) &&
           VerifyField<float>(verifier, VT_TEMPERATURE_CELSIUS, 4) &&
           VerifyField<uint8_t>(verifier, VT_BATTERY_LEVEL_PERCENT, 1) &&
           verifier.EndTable();
  }
};

struct StatusUpdateBuilder {
  typedef StatusUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uptime_seconds(uint64_t uptime_seconds) {
    fbb_.AddElement<uint64_t>(StatusUpdate::VT_UPTIME_SECONDS, uptime_seconds, 0);
  }
  void add_free_heap_bytes(uint32_t free_heap_bytes) {
    fbb_.AddElement<uint32_t>(StatusUpdate::VT_FREE_HEAP_BYTES, free_heap_bytes, 0);
  }
  void add_min_free_heap_bytes(uint32_t min_free_heap_bytes) {
    fbb_.AddElement<uint32_t>(StatusUpdate::VT_MIN_FREE_HEAP_BYTES, min_free_heap_bytes, 0);
  }
  void add_cpu_usage_percent(uint8_t cpu_usage_percent) {
    fbb_.AddElement<uint8_t>(StatusUpdate::VT_CPU_USAGE_PERCENT, cpu_usage_percent, 0);
  }
  void add_wifi_rssi(int8_t wifi_rssi) {
    fbb_.AddElement<int8_t>(StatusUpdate::VT_WIFI_RSSI, wifi_rssi, 0);
  }
  void add_audio_status(flatbuffers::Offset<sparetools::bpm::AudioStatus> audio_status) {
    fbb_.AddOffset(StatusUpdate::VT_AUDIO_STATUS, audio_status);
  }
  void add_temperature_celsius(float temperature_celsius) {
    fbb_.AddElement<float>(StatusUpdate::VT_TEMPERATURE_CELSIUS, temperature_celsius, 0.0f);
  }
  void add_battery_level_percent(uint8_t battery_level_percent) {
    fbb_.AddElement<uint8_t>(StatusUpdate::VT_BATTERY_LEVEL_PERCENT, battery_level_percent, 0);
  }
  explicit StatusUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StatusUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatusUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatusUpdate> CreateStatusUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t uptime_seconds = 0,
    uint32_t free_heap_bytes = 0,
    uint32_t min_free_heap_bytes = 0,
    uint8_t cpu_usage_percent = 0,
    int8_t wifi_rssi = 0,
    flatbuffers::Offset<sparetools::bpm::AudioStatus> audio_status = 0,
    float temperature_celsius = 0.0f,
    uint8_t battery_level_percent = 0) {
  StatusUpdateBuilder builder_(_fbb);
  builder_.add_uptime_seconds(uptime_seconds);
  builder_.add_temperature_celsius(temperature_celsius);
  builder_.add_audio_status(audio_status);
  builder_.add_min_free_heap_bytes(min_free_heap_bytes);
  builder_.add_free_heap_bytes(free_heap_bytes);
  builder_.add_battery_level_percent(battery_level_percent);
  builder_.add_wifi_rssi(wifi_rssi);
  builder_.add_cpu_usage_percent(cpu_usage_percent);
  return builder_.Finish();
}

struct SystemInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SystemInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIRMWARE_VERSION = 4,
    VT_HARDWARE_VERSION = 6,
    VT_ESP_IDF_VERSION = 8,
    VT_BUILD_DATE = 10,
    VT_FLASH_SIZE_BYTES = 12,
    VT_PSRAM_SIZE_BYTES = 14
  };
  const flatbuffers::String *firmware_version() const {
    return GetPointer<const flatbuffers::String *>(VT_FIRMWARE_VERSION);
  }
  const flatbuffers::String *hardware_version() const {
    return GetPointer<const flatbuffers::String *>(VT_HARDWARE_VERSION);
  }
  const flatbuffers::String *esp_idf_version() const {
    return GetPointer<const flatbuffers::String *>(VT_ESP_IDF_VERSION);
  }
  const flatbuffers::String *build_date() const {
    return GetPointer<const flatbuffers::String *>(VT_BUILD_DATE);
  }
  uint32_t flash_size_bytes() const {
    return GetField<uint32_t>(VT_FLASH_SIZE_BYTES, 0);
  }
  uint32_t psram_size_bytes() const {
    return GetField<uint32_t>(VT_PSRAM_SIZE_BYTES, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIRMWARE_VERSION) &&
           verifier.VerifyString(firmware_version()) &&
           VerifyOffset(verifier, VT_HARDWARE_VERSION) &&
           verifier.VerifyString(hardware_version()) &&
           VerifyOffset(verifier, VT_ESP_IDF_VERSION) &&
           verifier.VerifyString(esp_idf_version()) &&
           VerifyOffset(verifier, VT_BUILD_DATE) &&
           verifier.VerifyString(build_date()) &&
           VerifyField<uint32_t>(verifier, VT_FLASH_SIZE_BYTES, 4) &&
           VerifyField<uint32_t>(verifier, VT_PSRAM_SIZE_BYTES, 4) &&
           verifier.EndTable();
  }
};

struct SystemInfoBuilder {
  typedef SystemInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_firmware_version(flatbuffers::Offset<flatbuffers::String> firmware_version) {
    fbb_.AddOffset(SystemInfo::VT_FIRMWARE_VERSION, firmware_version);
  }
  void add_hardware_version(flatbuffers::Offset<flatbuffers::String> hardware_version) {
    fbb_.AddOffset(SystemInfo::VT_HARDWARE_VERSION, hardware_version);
  }
  void add_esp_idf_version(flatbuffers::Offset<flatbuffers::String> esp_idf_version) {
    fbb_.AddOffset(SystemInfo::VT_ESP_IDF_VERSION, esp_idf_version);
  }
  void add_build_date(flatbuffers::Offset<flatbuffers::String> build_date) {
    fbb_.AddOffset(SystemInfo::VT_BUILD_DATE, build_date);
  }
  void add_flash_size_bytes(uint32_t flash_size_bytes) {
    fbb_.AddElement<uint32_t>(SystemInfo::VT_FLASH_SIZE_BYTES, flash_size_bytes, 0);
  }
  void add_psram_size_bytes(uint32_t psram_size_bytes) {
    fbb_.AddElement<uint32_t>(SystemInfo::VT_PSRAM_SIZE_BYTES, psram_size_bytes, 0);
  }
  explicit SystemInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SystemInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SystemInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<SystemInfo> CreateSystemInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> firmware_version = 0,
    flatbuffers::Offset<flatbuffers::String> hardware_version = 0,
    flatbuffers::Offset<flatbuffers::String> esp_idf_version = 0,
    flatbuffers::Offset<flatbuffers::String> build_date = 0,
    uint32_t flash_size_bytes = 0,
    uint32_t psram_size_bytes = 0) {
  SystemInfoBuilder builder_(_fbb);
  builder_.add_psram_size_bytes(psram_size_bytes);
  builder_.add_flash_size_bytes(flash_size_bytes);
  builder_.add_build_date(build_date);
  builder_.add_esp_idf_version(esp_idf_version);
  builder_.add_hardware_version(hardware_version);
  builder_.add_firmware_version(firmware_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<SystemInfo> CreateSystemInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *firmware_version = nullptr,
    const char *hardware_version = nullptr,
    const char *esp_idf_version = nullptr,
    const char *build_date = nullptr,
    uint32_t flash_size_bytes = 0,
    uint32_t psram_size_bytes = 0) {
  auto firmware_version__ = firmware_version ? _fbb.CreateString(firmware_version) : 0;
  auto hardware_version__ = hardware_version ? _fbb.CreateString(hardware_version) : 0;
  auto esp_idf_version__ = esp_idf_version ? _fbb.CreateString(esp_idf_version) : 0;
  auto build_date__ = build_date ? _fbb.CreateString(build_date) : 0;
  return sparetools::bpm::CreateSystemInfo(
      _fbb,
      firmware_version__,
      hardware_version__,
      esp_idf_version__,
      build_date__,
      flash_size_bytes,
      psram_size_bytes);
}

struct NetworkDiagnostics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NetworkDiagnosticsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIFI_CONNECTED = 4,
    VT_IP_ADDRESS = 6,
    VT_GATEWAY = 8,
    VT_SUBNET = 10,
    VT_DNS_SERVER = 12,
    VT_RSSI = 14,
    VT_CHANNEL = 16,
    VT_TX_POWER = 18,
    VT_CONNECTION_TIME_SECONDS = 20,
    VT_RECONNECT_COUNT = 22
  };
  bool wifi_connected() const {
    return GetField<uint8_t>(VT_WIFI_CONNECTED, 0) != 0;
  }
  const flatbuffers::String *ip_address() const {
    return GetPointer<const flatbuffers::String *>(VT_IP_ADDRESS);
  }
  const flatbuffers::String *gateway() const {
    return GetPointer<const flatbuffers::String *>(VT_GATEWAY);
  }
  const flatbuffers::String *subnet() const {
    return GetPointer<const flatbuffers::String *>(VT_SUBNET);
  }
  const flatbuffers::String *dns_server() const {
    return GetPointer<const flatbuffers::String *>(VT_DNS_SERVER);
  }
  int8_t rssi() const {
    return GetField<int8_t>(VT_RSSI, 0);
  }
  uint8_t channel() const {
    return GetField<uint8_t>(VT_CHANNEL, 0);
  }
  int8_t tx_power() const {
    return GetField<int8_t>(VT_TX_POWER, 0);
  }
  uint64_t connection_time_seconds() const {
    return GetField<uint64_t>(VT_CONNECTION_TIME_SECONDS, 0);
  }
  uint32_t reconnect_count() const {
    return GetField<uint32_t>(VT_RECONNECT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_WIFI_CONNECTED, 1) &&
           VerifyOffset(verifier, VT_IP_ADDRESS) &&
           verifier.VerifyString(ip_address()) &&
           VerifyOffset(verifier, VT_GATEWAY) &&
           verifier.VerifyString(gateway()) &&
           VerifyOffset(verifier, VT_SUBNET) &&
           verifier.VerifyString(subnet()) &&
           VerifyOffset(verifier, VT_DNS_SERVER) &&
           verifier.VerifyString(dns_server()) &&
           VerifyField<int8_t>(verifier, VT_RSSI, 1) &&
           VerifyField<uint8_t>(verifier, VT_CHANNEL, 1) &&
           VerifyField<int8_t>(verifier, VT_TX_POWER, 1) &&
           VerifyField<uint64_t>(verifier, VT_CONNECTION_TIME_SECONDS, 8) &&
           VerifyField<uint32_t>(verifier, VT_RECONNECT_COUNT, 4) &&
           verifier.EndTable();
  }
};

struct NetworkDiagnosticsBuilder {
  typedef NetworkDiagnostics Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_wifi_connected(bool wifi_connected) {
    fbb_.AddElement<uint8_t>(NetworkDiagnostics::VT_WIFI_CONNECTED, static_cast<uint8_t>(wifi_connected), 0);
  }
  void add_ip_address(flatbuffers::Offset<flatbuffers::String> ip_address) {
    fbb_.AddOffset(NetworkDiagnostics::VT_IP_ADDRESS, ip_address);
  }
  void add_gateway(flatbuffers::Offset<flatbuffers::String> gateway) {
    fbb_.AddOffset(NetworkDiagnostics::VT_GATEWAY, gateway);
  }
  void add_subnet(flatbuffers::Offset<flatbuffers::String> subnet) {
    fbb_.AddOffset(NetworkDiagnostics::VT_SUBNET, subnet);
  }
  void add_dns_server(flatbuffers::Offset<flatbuffers::String> dns_server) {
    fbb_.AddOffset(NetworkDiagnostics::VT_DNS_SERVER, dns_server);
  }
  void add_rssi(int8_t rssi) {
    fbb_.AddElement<int8_t>(NetworkDiagnostics::VT_RSSI, rssi, 0);
  }
  void add_channel(uint8_t channel) {
    fbb_.AddElement<uint8_t>(NetworkDiagnostics::VT_CHANNEL, channel, 0);
  }
  void add_tx_power(int8_t tx_power) {
    fbb_.AddElement<int8_t>(NetworkDiagnostics::VT_TX_POWER, tx_power, 0);
  }
  void add_connection_time_seconds(uint64_t connection_time_seconds) {
    fbb_.AddElement<uint64_t>(NetworkDiagnostics::VT_CONNECTION_TIME_SECONDS, connection_time_seconds, 0);
  }
  void add_reconnect_count(uint32_t reconnect_count) {
    fbb_.AddElement<uint32_t>(NetworkDiagnostics::VT_RECONNECT_COUNT, reconnect_count, 0);
  }
  explicit NetworkDiagnosticsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NetworkDiagnostics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NetworkDiagnostics>(end);
    return o;
  }
};

inline flatbuffers::Offset<NetworkDiagnostics> CreateNetworkDiagnostics(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool wifi_connected = false,
    flatbuffers::Offset<flatbuffers::String> ip_address = 0,
    flatbuffers::Offset<flatbuffers::String> gateway = 0,
    flatbuffers::Offset<flatbuffers::String> subnet = 0,
    flatbuffers::Offset<flatbuffers::String> dns_server = 0,
    int8_t rssi = 0,
    uint8_t channel = 0,
    int8_t tx_power = 0,
    uint64_t connection_time_seconds = 0,
    uint32_t reconnect_count = 0) {
  NetworkDiagnosticsBuilder builder_(_fbb);
  builder_.add_connection_time_seconds(connection_time_seconds);
  builder_.add_reconnect_count(reconnect_count);
  builder_.add_dns_server(dns_server);
  builder_.add_subnet(subnet);
  builder_.add_gateway(gateway);
  builder_.add_ip_address(ip_address);
  builder_.add_tx_power(tx_power);
  builder_.add_channel(channel);
  builder_.add_rssi(rssi);
  builder_.add_wifi_connected(wifi_connected);
  return builder_.Finish();
}

inline flatbuffers::Offset<NetworkDiagnostics> CreateNetworkDiagnosticsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool wifi_connected = false,
    const char *ip_address = nullptr,
    const char *gateway = nullptr,
    const char *subnet = nullptr,
    const char *dns_server = nullptr,
    int8_t rssi = 0,
    uint8_t channel = 0,
    int8_t tx_power = 0,
    uint64_t connection_time_seconds = 0,
    uint32_t reconnect_count = 0) {
  auto ip_address__ = ip_address ? _fbb.CreateString(ip_address) : 0;
  auto gateway__ = gateway ? _fbb.CreateString(gateway) : 0;
  auto subnet__ = subnet ? _fbb.CreateString(subnet) : 0;
  auto dns_server__ = dns_server ? _fbb.CreateString(dns_server) : 0;
  return sparetools::bpm::CreateNetworkDiagnostics(
      _fbb,
      wifi_connected,
      ip_address__,
      gateway__,
      subnet__,
      dns_server__,
      rssi,
      channel,
      tx_power,
      connection_time_seconds,
      reconnect_count);
}

struct PerformanceMetrics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PerformanceMetricsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FREE_HEAP_BYTES = 4,
    VT_MIN_FREE_HEAP_BYTES = 6,
    VT_LARGEST_FREE_BLOCK_BYTES = 8,
    VT_CPU_USAGE_PERCENT = 10,
    VT_TASK_COUNT = 12,
    VT_UPTIME_SECONDS = 14,
    VT_RESET_REASON = 16
  };
  uint32_t free_heap_bytes() const {
    return GetField<uint32_t>(VT_FREE_HEAP_BYTES, 0);
  }
  uint32_t min_free_heap_bytes() const {
    return GetField<uint32_t>(VT_MIN_FREE_HEAP_BYTES, 0);
  }
  uint32_t largest_free_block_bytes() const {
    return GetField<uint32_t>(VT_LARGEST_FREE_BLOCK_BYTES, 0);
  }
  uint8_t cpu_usage_percent() const {
    return GetField<uint8_t>(VT_CPU_USAGE_PERCENT, 0);
  }
  uint8_t task_count() const {
    return GetField<uint8_t>(VT_TASK_COUNT, 0);
  }
  uint64_t uptime_seconds() const {
    return GetField<uint64_t>(VT_UPTIME_SECONDS, 0);
  }
  const flatbuffers::String *reset_reason() const {
    return GetPointer<const flatbuffers::String *>(VT_RESET_REASON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FREE_HEAP_BYTES, 4) &&
           VerifyField<uint32_t>(verifier, VT_MIN_FREE_HEAP_BYTES, 4) &&
           VerifyField<uint32_t>(verifier, VT_LARGEST_FREE_BLOCK_BYTES, 4) &&
           VerifyField<uint8_t>(verifier, VT_CPU_USAGE_PERCENT, 1) &&
           VerifyField<uint8_t>(verifier, VT_TASK_COUNT, 1) &&
           VerifyField<uint64_t>(verifier, VT_UPTIME_SECONDS, 8) &&
           VerifyOffset(verifier, VT_RESET_REASON) &&
           verifier.VerifyString(reset_reason()) &&
           verifier.EndTable();
  }
};

struct PerformanceMetricsBuilder {
  typedef PerformanceMetrics Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_free_heap_bytes(uint32_t free_heap_bytes) {
    fbb_.AddElement<uint32_t>(PerformanceMetrics::VT_FREE_HEAP_BYTES, free_heap_bytes, 0);
  }
  void add_min_free_heap_bytes(uint32_t min_free_heap_bytes) {
    fbb_.AddElement<uint32_t>(PerformanceMetrics::VT_MIN_FREE_HEAP_BYTES, min_free_heap_bytes, 0);
  }
  void add_largest_free_block_bytes(uint32_t largest_free_block_bytes) {
    fbb_.AddElement<uint32_t>(PerformanceMetrics::VT_LARGEST_FREE_BLOCK_BYTES, largest_free_block_bytes, 0);
  }
  void add_cpu_usage_percent(uint8_t cpu_usage_percent) {
    fbb_.AddElement<uint8_t>(PerformanceMetrics::VT_CPU_USAGE_PERCENT, cpu_usage_percent, 0);
  }
  void add_task_count(uint8_t task_count) {
    fbb_.AddElement<uint8_t>(PerformanceMetrics::VT_TASK_COUNT, task_count, 0);
  }
  void add_uptime_seconds(uint64_t uptime_seconds) {
    fbb_.AddElement<uint64_t>(PerformanceMetrics::VT_UPTIME_SECONDS, uptime_seconds, 0);
  }
  void add_reset_reason(flatbuffers::Offset<flatbuffers::String> reset_reason) {
    fbb_.AddOffset(PerformanceMetrics::VT_RESET_REASON, reset_reason);
  }
  explicit PerformanceMetricsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PerformanceMetrics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PerformanceMetrics>(end);
    return o;
  }
};

inline flatbuffers::Offset<PerformanceMetrics> CreatePerformanceMetrics(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t free_heap_bytes = 0,
    uint32_t min_free_heap_bytes = 0,
    uint32_t largest_free_block_bytes = 0,
    uint8_t cpu_usage_percent = 0,
    uint8_t task_count = 0,
    uint64_t uptime_seconds = 0,
    flatbuffers::Offset<flatbuffers::String> reset_reason = 0) {
  PerformanceMetricsBuilder builder_(_fbb);
  builder_.add_uptime_seconds(uptime_seconds);
  builder_.add_reset_reason(reset_reason);
  builder_.add_largest_free_block_bytes(largest_free_block_bytes);
  builder_.add_min_free_heap_bytes(min_free_heap_bytes);
  builder_.add_free_heap_bytes(free_heap_bytes);
  builder_.add_task_count(task_count);
  builder_.add_cpu_usage_percent(cpu_usage_percent);
  return builder_.Finish();
}

inline flatbuffers::Offset<PerformanceMetrics> CreatePerformanceMetricsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t free_heap_bytes = 0,
    uint32_t min_free_heap_bytes = 0,
    uint32_t largest_free_block_bytes = 0,
    uint8_t cpu_usage_percent = 0,
    uint8_t task_count = 0,
    uint64_t uptime_seconds = 0,
    const char *reset_reason = nullptr) {
  auto reset_reason__ = reset_reason ? _fbb.CreateString(reset_reason) : 0;
  return sparetools::bpm::CreatePerformanceMetrics(
      _fbb,
      free_heap_bytes,
      min_free_heap_bytes,
      largest_free_block_bytes,
      cpu_usage_percent,
      task_count,
      uptime_seconds,
      reset_reason__);
}

struct DiagnosticsData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DiagnosticsDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SYSTEM_INFO = 4,
    VT_AUDIO_DIAGNOSTICS = 6,
    VT_NETWORK_DIAGNOSTICS = 8,
    VT_PERFORMANCE_METRICS = 10,
    VT_TIMESTAMP = 12
  };
  const sparetools::bpm::SystemInfo *system_info() const {
    return GetPointer<const sparetools::bpm::SystemInfo *>(VT_SYSTEM_INFO);
  }
  const sparetools::bpm::AudioDiagnostics *audio_diagnostics() const {
    return GetPointer<const sparetools::bpm::AudioDiagnostics *>(VT_AUDIO_DIAGNOSTICS);
  }
  const sparetools::bpm::NetworkDiagnostics *network_diagnostics() const {
    return GetPointer<const sparetools::bpm::NetworkDiagnostics *>(VT_NETWORK_DIAGNOSTICS);
  }
  const sparetools::bpm::PerformanceMetrics *performance_metrics() const {
    return GetPointer<const sparetools::bpm::PerformanceMetrics *>(VT_PERFORMANCE_METRICS);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SYSTEM_INFO) &&
           verifier.VerifyTable(system_info()) &&
           VerifyOffset(verifier, VT_AUDIO_DIAGNOSTICS) &&
           verifier.VerifyTable(audio_diagnostics()) &&
           VerifyOffset(verifier, VT_NETWORK_DIAGNOSTICS) &&
           verifier.VerifyTable(network_diagnostics()) &&
           VerifyOffset(verifier, VT_PERFORMANCE_METRICS) &&
           verifier.VerifyTable(performance_metrics()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct DiagnosticsDataBuilder {
  typedef DiagnosticsData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_system_info(flatbuffers::Offset<sparetools::bpm::SystemInfo> system_info) {
    fbb_.AddOffset(DiagnosticsData::VT_SYSTEM_INFO, system_info);
  }
  void add_audio_diagnostics(flatbuffers::Offset<sparetools::bpm::AudioDiagnostics> audio_diagnostics) {
    fbb_.AddOffset(DiagnosticsData::VT_AUDIO_DIAGNOSTICS, audio_diagnostics);
  }
  void add_network_diagnostics(flatbuffers::Offset<sparetools::bpm::NetworkDiagnostics> network_diagnostics) {
    fbb_.AddOffset(DiagnosticsData::VT_NETWORK_DIAGNOSTICS, network_diagnostics);
  }
  void add_performance_metrics(flatbuffers::Offset<sparetools::bpm::PerformanceMetrics> performance_metrics) {
    fbb_.AddOffset(DiagnosticsData::VT_PERFORMANCE_METRICS, performance_metrics);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(DiagnosticsData::VT_TIMESTAMP, timestamp, 0);
  }
  explicit DiagnosticsDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DiagnosticsData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DiagnosticsData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DiagnosticsData> CreateDiagnosticsData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<sparetools::bpm::SystemInfo> system_info = 0,
    flatbuffers::Offset<sparetools::bpm::AudioDiagnostics> audio_diagnostics = 0,
    flatbuffers::Offset<sparetools::bpm::NetworkDiagnostics> network_diagnostics = 0,
    flatbuffers::Offset<sparetools::bpm::PerformanceMetrics> performance_metrics = 0,
    uint64_t timestamp = 0) {
  DiagnosticsDataBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_performance_metrics(performance_metrics);
  builder_.add_network_diagnostics(network_diagnostics);
  builder_.add_audio_diagnostics(audio_diagnostics);
  builder_.add_system_info(system_info);
  return builder_.Finish();
}

}  // namespace bpm
}  // namespace sparetools

#endif  // FLATBUFFERS_GENERATED_BPMSYSTEM_SPARETOOLS_BPM_H_
