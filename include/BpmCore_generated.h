// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BPMCORE_SPARETOOLS_BPM_H_
#define FLATBUFFERS_GENERATED_BPMCORE_SPARETOOLS_BPM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

#include "BpmCommon_generated.h"

namespace sparetools {
namespace bpm {

struct BPMAnalysis;
struct BPMAnalysisBuilder;

struct BPMQuality;
struct BPMQualityBuilder;

struct BPMUpdate;
struct BPMUpdateBuilder;

struct BPMAnalysis FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BPMAnalysisBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STABILITY = 4,
    VT_REGULARITY = 6,
    VT_DOMINANT_FREQUENCY = 8,
    VT_SPECTRAL_CENTROID = 10,
    VT_BEAT_POSITION = 12,
    VT_TEMPO_CONSISTENCY = 14
  };
  float stability() const {
    return GetField<float>(VT_STABILITY, 0.0f);
  }
  float regularity() const {
    return GetField<float>(VT_REGULARITY, 0.0f);
  }
  float dominant_frequency() const {
    return GetField<float>(VT_DOMINANT_FREQUENCY, 0.0f);
  }
  float spectral_centroid() const {
    return GetField<float>(VT_SPECTRAL_CENTROID, 0.0f);
  }
  float beat_position() const {
    return GetField<float>(VT_BEAT_POSITION, 0.0f);
  }
  float tempo_consistency() const {
    return GetField<float>(VT_TEMPO_CONSISTENCY, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_STABILITY, 4) &&
           VerifyField<float>(verifier, VT_REGULARITY, 4) &&
           VerifyField<float>(verifier, VT_DOMINANT_FREQUENCY, 4) &&
           VerifyField<float>(verifier, VT_SPECTRAL_CENTROID, 4) &&
           VerifyField<float>(verifier, VT_BEAT_POSITION, 4) &&
           VerifyField<float>(verifier, VT_TEMPO_CONSISTENCY, 4) &&
           verifier.EndTable();
  }
};

struct BPMAnalysisBuilder {
  typedef BPMAnalysis Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stability(float stability) {
    fbb_.AddElement<float>(BPMAnalysis::VT_STABILITY, stability, 0.0f);
  }
  void add_regularity(float regularity) {
    fbb_.AddElement<float>(BPMAnalysis::VT_REGULARITY, regularity, 0.0f);
  }
  void add_dominant_frequency(float dominant_frequency) {
    fbb_.AddElement<float>(BPMAnalysis::VT_DOMINANT_FREQUENCY, dominant_frequency, 0.0f);
  }
  void add_spectral_centroid(float spectral_centroid) {
    fbb_.AddElement<float>(BPMAnalysis::VT_SPECTRAL_CENTROID, spectral_centroid, 0.0f);
  }
  void add_beat_position(float beat_position) {
    fbb_.AddElement<float>(BPMAnalysis::VT_BEAT_POSITION, beat_position, 0.0f);
  }
  void add_tempo_consistency(float tempo_consistency) {
    fbb_.AddElement<float>(BPMAnalysis::VT_TEMPO_CONSISTENCY, tempo_consistency, 0.0f);
  }
  explicit BPMAnalysisBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BPMAnalysis> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BPMAnalysis>(end);
    return o;
  }
};

inline flatbuffers::Offset<BPMAnalysis> CreateBPMAnalysis(
    flatbuffers::FlatBufferBuilder &_fbb,
    float stability = 0.0f,
    float regularity = 0.0f,
    float dominant_frequency = 0.0f,
    float spectral_centroid = 0.0f,
    float beat_position = 0.0f,
    float tempo_consistency = 0.0f) {
  BPMAnalysisBuilder builder_(_fbb);
  builder_.add_tempo_consistency(tempo_consistency);
  builder_.add_beat_position(beat_position);
  builder_.add_spectral_centroid(spectral_centroid);
  builder_.add_dominant_frequency(dominant_frequency);
  builder_.add_regularity(regularity);
  builder_.add_stability(stability);
  return builder_.Finish();
}

struct BPMQuality FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BPMQualityBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SNR_DB = 4,
    VT_CONSECUTIVE_DETECTIONS = 6,
    VT_RELIABILITY_SCORE = 8,
    VT_FALSE_POSITIVE_RATE = 10,
    VT_ALGORITHM_CONFIDENCE = 12
  };
  float snr_db() const {
    return GetField<float>(VT_SNR_DB, 0.0f);
  }
  uint16_t consecutive_detections() const {
    return GetField<uint16_t>(VT_CONSECUTIVE_DETECTIONS, 0);
  }
  float reliability_score() const {
    return GetField<float>(VT_RELIABILITY_SCORE, 0.0f);
  }
  float false_positive_rate() const {
    return GetField<float>(VT_FALSE_POSITIVE_RATE, 0.0f);
  }
  float algorithm_confidence() const {
    return GetField<float>(VT_ALGORITHM_CONFIDENCE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SNR_DB, 4) &&
           VerifyField<uint16_t>(verifier, VT_CONSECUTIVE_DETECTIONS, 2) &&
           VerifyField<float>(verifier, VT_RELIABILITY_SCORE, 4) &&
           VerifyField<float>(verifier, VT_FALSE_POSITIVE_RATE, 4) &&
           VerifyField<float>(verifier, VT_ALGORITHM_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct BPMQualityBuilder {
  typedef BPMQuality Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_snr_db(float snr_db) {
    fbb_.AddElement<float>(BPMQuality::VT_SNR_DB, snr_db, 0.0f);
  }
  void add_consecutive_detections(uint16_t consecutive_detections) {
    fbb_.AddElement<uint16_t>(BPMQuality::VT_CONSECUTIVE_DETECTIONS, consecutive_detections, 0);
  }
  void add_reliability_score(float reliability_score) {
    fbb_.AddElement<float>(BPMQuality::VT_RELIABILITY_SCORE, reliability_score, 0.0f);
  }
  void add_false_positive_rate(float false_positive_rate) {
    fbb_.AddElement<float>(BPMQuality::VT_FALSE_POSITIVE_RATE, false_positive_rate, 0.0f);
  }
  void add_algorithm_confidence(float algorithm_confidence) {
    fbb_.AddElement<float>(BPMQuality::VT_ALGORITHM_CONFIDENCE, algorithm_confidence, 0.0f);
  }
  explicit BPMQualityBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BPMQuality> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BPMQuality>(end);
    return o;
  }
};

inline flatbuffers::Offset<BPMQuality> CreateBPMQuality(
    flatbuffers::FlatBufferBuilder &_fbb,
    float snr_db = 0.0f,
    uint16_t consecutive_detections = 0,
    float reliability_score = 0.0f,
    float false_positive_rate = 0.0f,
    float algorithm_confidence = 0.0f) {
  BPMQualityBuilder builder_(_fbb);
  builder_.add_algorithm_confidence(algorithm_confidence);
  builder_.add_false_positive_rate(false_positive_rate);
  builder_.add_reliability_score(reliability_score);
  builder_.add_snr_db(snr_db);
  builder_.add_consecutive_detections(consecutive_detections);
  return builder_.Finish();
}

struct BPMUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BPMUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BPM = 4,
    VT_CONFIDENCE = 6,
    VT_SIGNAL_LEVEL = 8,
    VT_STATUS = 10,
    VT_ANALYSIS = 12,
    VT_QUALITY = 14,
    VT_TIMESTAMP = 16
  };
  float bpm() const {
    return GetField<float>(VT_BPM, 0.0f);
  }
  float confidence() const {
    return GetField<float>(VT_CONFIDENCE, 0.0f);
  }
  float signal_level() const {
    return GetField<float>(VT_SIGNAL_LEVEL, 0.0f);
  }
  sparetools::bpm::DetectionStatus status() const {
    return static_cast<sparetools::bpm::DetectionStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  const sparetools::bpm::BPMAnalysis *analysis() const {
    return GetPointer<const sparetools::bpm::BPMAnalysis *>(VT_ANALYSIS);
  }
  const sparetools::bpm::BPMQuality *quality() const {
    return GetPointer<const sparetools::bpm::BPMQuality *>(VT_QUALITY);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BPM, 4) &&
           VerifyField<float>(verifier, VT_CONFIDENCE, 4) &&
           VerifyField<float>(verifier, VT_SIGNAL_LEVEL, 4) &&
           VerifyField<int8_t>(verifier, VT_STATUS, 1) &&
           VerifyOffset(verifier, VT_ANALYSIS) &&
           verifier.VerifyTable(analysis()) &&
           VerifyOffset(verifier, VT_QUALITY) &&
           verifier.VerifyTable(quality()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct BPMUpdateBuilder {
  typedef BPMUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bpm(float bpm) {
    fbb_.AddElement<float>(BPMUpdate::VT_BPM, bpm, 0.0f);
  }
  void add_confidence(float confidence) {
    fbb_.AddElement<float>(BPMUpdate::VT_CONFIDENCE, confidence, 0.0f);
  }
  void add_signal_level(float signal_level) {
    fbb_.AddElement<float>(BPMUpdate::VT_SIGNAL_LEVEL, signal_level, 0.0f);
  }
  void add_status(sparetools::bpm::DetectionStatus status) {
    fbb_.AddElement<int8_t>(BPMUpdate::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_analysis(flatbuffers::Offset<sparetools::bpm::BPMAnalysis> analysis) {
    fbb_.AddOffset(BPMUpdate::VT_ANALYSIS, analysis);
  }
  void add_quality(flatbuffers::Offset<sparetools::bpm::BPMQuality> quality) {
    fbb_.AddOffset(BPMUpdate::VT_QUALITY, quality);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(BPMUpdate::VT_TIMESTAMP, timestamp, 0);
  }
  explicit BPMUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BPMUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BPMUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<BPMUpdate> CreateBPMUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    float bpm = 0.0f,
    float confidence = 0.0f,
    float signal_level = 0.0f,
    sparetools::bpm::DetectionStatus status = sparetools::bpm::DetectionStatus_INITIALIZING,
    flatbuffers::Offset<sparetools::bpm::BPMAnalysis> analysis = 0,
    flatbuffers::Offset<sparetools::bpm::BPMQuality> quality = 0,
    uint64_t timestamp = 0) {
  BPMUpdateBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_quality(quality);
  builder_.add_analysis(analysis);
  builder_.add_signal_level(signal_level);
  builder_.add_confidence(confidence);
  builder_.add_bpm(bpm);
  builder_.add_status(status);
  return builder_.Finish();
}

}  // namespace bpm
}  // namespace sparetools

#endif  // FLATBUFFERS_GENERATED_BPMCORE_SPARETOOLS_BPM_H_
