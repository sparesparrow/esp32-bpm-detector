// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BPMPROTOCOL_SPARETOOLS_BPM_H_
#define FLATBUFFERS_GENERATED_BPMPROTOCOL_SPARETOOLS_BPM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is compatible
// Relaxed version check for broader compatibility
static_assert(FLATBUFFERS_VERSION_MAJOR >= 2 ||
              (FLATBUFFERS_VERSION_MAJOR == 2 && FLATBUFFERS_VERSION_MINOR >= 0),
             "FlatBuffers version 2.0.0 or higher required");

namespace sparetools {
namespace bpm {

struct Header;
struct HeaderBuilder;

struct GetStatusRequest;
struct GetStatusRequestBuilder;

struct GetConfigRequest;
struct GetConfigRequestBuilder;

struct SetConfigRequest;
struct SetConfigRequestBuilder;

struct ResetDeviceRequest;
struct ResetDeviceRequestBuilder;

struct CalibrateAudioRequest;
struct CalibrateAudioRequestBuilder;

struct StartStreamingRequest;
struct StartStreamingRequestBuilder;

struct StopStreamingRequest;
struct StopStreamingRequestBuilder;

struct GetDiagnosticsRequest;
struct GetDiagnosticsRequestBuilder;

struct Request;
struct RequestBuilder;

struct BPMAnalysis;
struct BPMAnalysisBuilder;

struct BPMQuality;
struct BPMQualityBuilder;

struct BPMUpdate;
struct BPMUpdateBuilder;

struct AudioStatus;
struct AudioStatusBuilder;

struct AudioCalibrationData;
struct AudioCalibrationDataBuilder;

struct StatusUpdate;
struct StatusUpdateBuilder;

struct ConfigUpdate;
struct ConfigUpdateBuilder;

struct BPMConfig;
struct BPMConfigBuilder;

struct AudioConfig;
struct AudioConfigBuilder;

struct NetworkConfig;
struct NetworkConfigBuilder;

struct DisplayConfig;
struct DisplayConfigBuilder;

struct ErrorReport;
struct ErrorReportBuilder;

struct SystemInfo;
struct SystemInfoBuilder;

struct AudioDiagnostics;
struct AudioDiagnosticsBuilder;

struct NetworkDiagnostics;
struct NetworkDiagnosticsBuilder;

struct PerformanceMetrics;
struct PerformanceMetricsBuilder;

struct DiagnosticsData;
struct DiagnosticsDataBuilder;

struct GetStatusResponse;
struct GetStatusResponseBuilder;

struct GetConfigResponse;
struct GetConfigResponseBuilder;

struct SetConfigResponse;
struct SetConfigResponseBuilder;

struct ResetDeviceResponse;
struct ResetDeviceResponseBuilder;

struct CalibrateAudioResponse;
struct CalibrateAudioResponseBuilder;

struct StartStreamingResponse;
struct StartStreamingResponseBuilder;

struct StopStreamingResponse;
struct StopStreamingResponseBuilder;

struct GetDiagnosticsResponse;
struct GetDiagnosticsResponseBuilder;

struct Status;
struct StatusBuilder;

struct Response;
struct ResponseBuilder;

enum DetectionStatus : int8_t {
  DetectionStatus_INITIALIZING = 0,
  DetectionStatus_DETECTING = 1,
  DetectionStatus_LOW_SIGNAL = 2,
  DetectionStatus_NO_SIGNAL = 3,
  DetectionStatus_ERROR = 4,
  DetectionStatus_CALIBRATING = 5,
  DetectionStatus_MIN = DetectionStatus_INITIALIZING,
  DetectionStatus_MAX = DetectionStatus_CALIBRATING
};

inline const DetectionStatus (&EnumValuesDetectionStatus())[6] {
  static const DetectionStatus values[] = {
    DetectionStatus_INITIALIZING,
    DetectionStatus_DETECTING,
    DetectionStatus_LOW_SIGNAL,
    DetectionStatus_NO_SIGNAL,
    DetectionStatus_ERROR,
    DetectionStatus_CALIBRATING
  };
  return values;
}

inline const char * const *EnumNamesDetectionStatus() {
  static const char * const names[7] = {
    "INITIALIZING",
    "DETECTING",
    "LOW_SIGNAL",
    "NO_SIGNAL",
    "ERROR",
    "CALIBRATING",
    nullptr
  };
  return names;
}

inline const char *EnumNameDetectionStatus(DetectionStatus e) {
  if (flatbuffers::IsOutRange(e, DetectionStatus_INITIALIZING, DetectionStatus_CALIBRATING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDetectionStatus()[index];
}

enum StatusEnum : int32_t {
  StatusEnum_Success = 0,
  StatusEnum_Error = 1,
  StatusEnum_Warning = 2,
  StatusEnum_Info = 3,
  StatusEnum_MIN = StatusEnum_Success,
  StatusEnum_MAX = StatusEnum_Info
};

inline const StatusEnum (&EnumValuesStatusEnum())[4] {
  static const StatusEnum values[] = {
    StatusEnum_Success,
    StatusEnum_Error,
    StatusEnum_Warning,
    StatusEnum_Info
  };
  return values;
}

inline const char * const *EnumNamesStatusEnum() {
  static const char * const names[5] = {
    "Success",
    "Error",
    "Warning",
    "Info",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatusEnum(StatusEnum e) {
  if (flatbuffers::IsOutRange(e, StatusEnum_Success, StatusEnum_Info)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatusEnum()[index];
}

enum RequestType : int8_t {
  RequestType_GET_STATUS = 0,
  RequestType_GET_CONFIG = 1,
  RequestType_SET_CONFIG = 2,
  RequestType_RESET_DEVICE = 3,
  RequestType_CALIBRATE_AUDIO = 4,
  RequestType_START_STREAMING = 5,
  RequestType_STOP_STREAMING = 6,
  RequestType_GET_DIAGNOSTICS = 7,
  RequestType_MIN = RequestType_GET_STATUS,
  RequestType_MAX = RequestType_GET_DIAGNOSTICS
};

inline const RequestType (&EnumValuesRequestType())[8] {
  static const RequestType values[] = {
    RequestType_GET_STATUS,
    RequestType_GET_CONFIG,
    RequestType_SET_CONFIG,
    RequestType_RESET_DEVICE,
    RequestType_CALIBRATE_AUDIO,
    RequestType_START_STREAMING,
    RequestType_STOP_STREAMING,
    RequestType_GET_DIAGNOSTICS
  };
  return values;
}

inline const char * const *EnumNamesRequestType() {
  static const char * const names[9] = {
    "GET_STATUS",
    "GET_CONFIG",
    "SET_CONFIG",
    "RESET_DEVICE",
    "CALIBRATE_AUDIO",
    "START_STREAMING",
    "STOP_STREAMING",
    "GET_DIAGNOSTICS",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestType(RequestType e) {
  if (flatbuffers::IsOutRange(e, RequestType_GET_STATUS, RequestType_GET_DIAGNOSTICS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestType()[index];
}

enum ResponsePayload : uint8_t {
  ResponsePayload_NONE = 0,
  ResponsePayload_GetStatusResponse = 1,
  ResponsePayload_GetConfigResponse = 2,
  ResponsePayload_SetConfigResponse = 3,
  ResponsePayload_ResetDeviceResponse = 4,
  ResponsePayload_CalibrateAudioResponse = 5,
  ResponsePayload_StartStreamingResponse = 6,
  ResponsePayload_StopStreamingResponse = 7,
  ResponsePayload_GetDiagnosticsResponse = 8,
  ResponsePayload_MIN = ResponsePayload_NONE,
  ResponsePayload_MAX = ResponsePayload_GetDiagnosticsResponse
};

inline const ResponsePayload (&EnumValuesResponsePayload())[9] {
  static const ResponsePayload values[] = {
    ResponsePayload_NONE,
    ResponsePayload_GetStatusResponse,
    ResponsePayload_GetConfigResponse,
    ResponsePayload_SetConfigResponse,
    ResponsePayload_ResetDeviceResponse,
    ResponsePayload_CalibrateAudioResponse,
    ResponsePayload_StartStreamingResponse,
    ResponsePayload_StopStreamingResponse,
    ResponsePayload_GetDiagnosticsResponse
  };
  return values;
}

inline const char * const *EnumNamesResponsePayload() {
  static const char * const names[10] = {
    "NONE",
    "GetStatusResponse",
    "GetConfigResponse",
    "SetConfigResponse",
    "ResetDeviceResponse",
    "CalibrateAudioResponse",
    "StartStreamingResponse",
    "StopStreamingResponse",
    "GetDiagnosticsResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameResponsePayload(ResponsePayload e) {
  if (flatbuffers::IsOutRange(e, ResponsePayload_NONE, ResponsePayload_GetDiagnosticsResponse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResponsePayload()[index];
}

enum RequestPayload : uint8_t {
  RequestPayload_NONE = 0,
  RequestPayload_GetStatusRequest = 1,
  RequestPayload_GetConfigRequest = 2,
  RequestPayload_SetConfigRequest = 3,
  RequestPayload_ResetDeviceRequest = 4,
  RequestPayload_CalibrateAudioRequest = 5,
  RequestPayload_StartStreamingRequest = 6,
  RequestPayload_StopStreamingRequest = 7,
  RequestPayload_GetDiagnosticsRequest = 8,
  RequestPayload_MIN = RequestPayload_NONE,
  RequestPayload_MAX = RequestPayload_GetDiagnosticsRequest
};

inline const RequestPayload (&EnumValuesRequestPayload())[9] {
  static const RequestPayload values[] = {
    RequestPayload_NONE,
    RequestPayload_GetStatusRequest,
    RequestPayload_GetConfigRequest,
    RequestPayload_SetConfigRequest,
    RequestPayload_ResetDeviceRequest,
    RequestPayload_CalibrateAudioRequest,
    RequestPayload_StartStreamingRequest,
    RequestPayload_StopStreamingRequest,
    RequestPayload_GetDiagnosticsRequest
  };
  return values;
}

inline const char * const *EnumNamesRequestPayload() {
  static const char * const names[10] = {
    "NONE",
    "GetStatusRequest",
    "GetConfigRequest",
    "SetConfigRequest",
    "ResetDeviceRequest",
    "CalibrateAudioRequest",
    "StartStreamingRequest",
    "StopStreamingRequest",
    "GetDiagnosticsRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestPayload(RequestPayload e) {
  if (flatbuffers::IsOutRange(e, RequestPayload_NONE, RequestPayload_GetDiagnosticsRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestPayload()[index];
}

enum StreamType : int8_t {
  StreamType_WEBSOCKET = 0,
  StreamType_HTTP = 1,
  StreamType_MQTT = 2,
  StreamType_MIN = StreamType_WEBSOCKET,
  StreamType_MAX = StreamType_MQTT
};

inline const StreamType (&EnumValuesStreamType())[3] {
  static const StreamType values[] = {
    StreamType_WEBSOCKET,
    StreamType_HTTP,
    StreamType_MQTT
  };
  return values;
}

inline const char * const *EnumNamesStreamType() {
  static const char * const names[4] = {
    "WEBSOCKET",
    "HTTP",
    "MQTT",
    nullptr
  };
  return names;
}

inline const char *EnumNameStreamType(StreamType e) {
  if (flatbuffers::IsOutRange(e, StreamType_WEBSOCKET, StreamType_MQTT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStreamType()[index];
}

struct Header FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_TIMESTAMP = 6,
    VT_SEQUENCE_ID = 8
  };
  uint16_t version() const {
    return GetField<uint16_t>(VT_VERSION, 1);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  uint32_t sequence_id() const {
    return GetField<uint32_t>(VT_SEQUENCE_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_VERSION, 2) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyField<uint32_t>(verifier, VT_SEQUENCE_ID, 4) &&
           verifier.EndTable();
  }
};

struct HeaderBuilder {
  typedef Header Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint16_t version) {
    fbb_.AddElement<uint16_t>(Header::VT_VERSION, version, 1);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(Header::VT_TIMESTAMP, timestamp, 0);
  }
  void add_sequence_id(uint32_t sequence_id) {
    fbb_.AddElement<uint32_t>(Header::VT_SEQUENCE_ID, sequence_id, 0);
  }
  explicit HeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Header> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Header>(end);
    return o;
  }
};

inline flatbuffers::Offset<Header> CreateHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t version = 1,
    uint64_t timestamp = 0,
    uint32_t sequence_id = 0) {
  HeaderBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_sequence_id(sequence_id);
  builder_.add_version(version);
  return builder_.Finish();
}

struct GetStatusRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetStatusRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GetStatusRequestBuilder {
  typedef GetStatusRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GetStatusRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GetStatusRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetStatusRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetStatusRequest> CreateGetStatusRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GetStatusRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GetConfigRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetConfigRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GetConfigRequestBuilder {
  typedef GetConfigRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GetConfigRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GetConfigRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetConfigRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetConfigRequest> CreateGetConfigRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GetConfigRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SetConfigRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SetConfigRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONFIG = 4
  };
  const sparetools::bpm::ConfigUpdate *config() const {
    return GetPointer<const sparetools::bpm::ConfigUpdate *>(VT_CONFIG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           verifier.VerifyTable(config()) &&
           verifier.EndTable();
  }
};

struct SetConfigRequestBuilder {
  typedef SetConfigRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_config(flatbuffers::Offset<sparetools::bpm::ConfigUpdate> config) {
    fbb_.AddOffset(SetConfigRequest::VT_CONFIG, config);
  }
  explicit SetConfigRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SetConfigRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetConfigRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetConfigRequest> CreateSetConfigRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<sparetools::bpm::ConfigUpdate> config = 0) {
  SetConfigRequestBuilder builder_(_fbb);
  builder_.add_config(config);
  return builder_.Finish();
}

struct ResetDeviceRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResetDeviceRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ResetDeviceRequestBuilder {
  typedef ResetDeviceRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ResetDeviceRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ResetDeviceRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResetDeviceRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResetDeviceRequest> CreateResetDeviceRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ResetDeviceRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CalibrateAudioRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CalibrateAudioRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DURATION_SECONDS = 4,
    VT_TARGET_FREQUENCY = 6
  };
  uint16_t duration_seconds() const {
    return GetField<uint16_t>(VT_DURATION_SECONDS, 10);
  }
  float target_frequency() const {
    return GetField<float>(VT_TARGET_FREQUENCY, 440.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_DURATION_SECONDS, 2) &&
           VerifyField<float>(verifier, VT_TARGET_FREQUENCY, 4) &&
           verifier.EndTable();
  }
};

struct CalibrateAudioRequestBuilder {
  typedef CalibrateAudioRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_duration_seconds(uint16_t duration_seconds) {
    fbb_.AddElement<uint16_t>(CalibrateAudioRequest::VT_DURATION_SECONDS, duration_seconds, 10);
  }
  void add_target_frequency(float target_frequency) {
    fbb_.AddElement<float>(CalibrateAudioRequest::VT_TARGET_FREQUENCY, target_frequency, 440.0f);
  }
  explicit CalibrateAudioRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CalibrateAudioRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CalibrateAudioRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CalibrateAudioRequest> CreateCalibrateAudioRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t duration_seconds = 10,
    float target_frequency = 440.0f) {
  CalibrateAudioRequestBuilder builder_(_fbb);
  builder_.add_target_frequency(target_frequency);
  builder_.add_duration_seconds(duration_seconds);
  return builder_.Finish();
}

struct StartStreamingRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StartStreamingRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_TYPE = 4,
    VT_ENDPOINT = 6,
    VT_INTERVAL_MS = 8
  };
  sparetools::bpm::StreamType stream_type() const {
    return static_cast<sparetools::bpm::StreamType>(GetField<int8_t>(VT_STREAM_TYPE, 0));
  }
  const flatbuffers::String *endpoint() const {
    return GetPointer<const flatbuffers::String *>(VT_ENDPOINT);
  }
  uint16_t interval_ms() const {
    return GetField<uint16_t>(VT_INTERVAL_MS, 1000);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STREAM_TYPE, 1) &&
           VerifyOffset(verifier, VT_ENDPOINT) &&
           verifier.VerifyString(endpoint()) &&
           VerifyField<uint16_t>(verifier, VT_INTERVAL_MS, 2) &&
           verifier.EndTable();
  }
};

struct StartStreamingRequestBuilder {
  typedef StartStreamingRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_type(sparetools::bpm::StreamType stream_type) {
    fbb_.AddElement<int8_t>(StartStreamingRequest::VT_STREAM_TYPE, static_cast<int8_t>(stream_type), 0);
  }
  void add_endpoint(flatbuffers::Offset<flatbuffers::String> endpoint) {
    fbb_.AddOffset(StartStreamingRequest::VT_ENDPOINT, endpoint);
  }
  void add_interval_ms(uint16_t interval_ms) {
    fbb_.AddElement<uint16_t>(StartStreamingRequest::VT_INTERVAL_MS, interval_ms, 1000);
  }
  explicit StartStreamingRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StartStreamingRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StartStreamingRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<StartStreamingRequest> CreateStartStreamingRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    sparetools::bpm::StreamType stream_type = sparetools::bpm::StreamType_WEBSOCKET,
    flatbuffers::Offset<flatbuffers::String> endpoint = 0,
    uint16_t interval_ms = 1000) {
  StartStreamingRequestBuilder builder_(_fbb);
  builder_.add_endpoint(endpoint);
  builder_.add_interval_ms(interval_ms);
  builder_.add_stream_type(stream_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<StartStreamingRequest> CreateStartStreamingRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    sparetools::bpm::StreamType stream_type = sparetools::bpm::StreamType_WEBSOCKET,
    const char *endpoint = nullptr,
    uint16_t interval_ms = 1000) {
  auto endpoint__ = endpoint ? _fbb.CreateString(endpoint) : 0;
  return sparetools::bpm::CreateStartStreamingRequest(
      _fbb,
      stream_type,
      endpoint__,
      interval_ms);
}

struct StopStreamingRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StopStreamingRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct StopStreamingRequestBuilder {
  typedef StopStreamingRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit StopStreamingRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StopStreamingRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StopStreamingRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<StopStreamingRequest> CreateStopStreamingRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  StopStreamingRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GetDiagnosticsRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetDiagnosticsRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INCLUDE_AUDIO = 4,
    VT_INCLUDE_NETWORK = 6,
    VT_INCLUDE_PERFORMANCE = 8
  };
  bool include_audio() const {
    return GetField<uint8_t>(VT_INCLUDE_AUDIO, 1) != 0;
  }
  bool include_network() const {
    return GetField<uint8_t>(VT_INCLUDE_NETWORK, 1) != 0;
  }
  bool include_performance() const {
    return GetField<uint8_t>(VT_INCLUDE_PERFORMANCE, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_AUDIO, 1) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_NETWORK, 1) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_PERFORMANCE, 1) &&
           verifier.EndTable();
  }
};

struct GetDiagnosticsRequestBuilder {
  typedef GetDiagnosticsRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_include_audio(bool include_audio) {
    fbb_.AddElement<uint8_t>(GetDiagnosticsRequest::VT_INCLUDE_AUDIO, static_cast<uint8_t>(include_audio), 1);
  }
  void add_include_network(bool include_network) {
    fbb_.AddElement<uint8_t>(GetDiagnosticsRequest::VT_INCLUDE_NETWORK, static_cast<uint8_t>(include_network), 1);
  }
  void add_include_performance(bool include_performance) {
    fbb_.AddElement<uint8_t>(GetDiagnosticsRequest::VT_INCLUDE_PERFORMANCE, static_cast<uint8_t>(include_performance), 1);
  }
  explicit GetDiagnosticsRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GetDiagnosticsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetDiagnosticsRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetDiagnosticsRequest> CreateGetDiagnosticsRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool include_audio = true,
    bool include_network = true,
    bool include_performance = true) {
  GetDiagnosticsRequestBuilder builder_(_fbb);
  builder_.add_include_performance(include_performance);
  builder_.add_include_network(include_network);
  builder_.add_include_audio(include_audio);
  return builder_.Finish();
}

struct Request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_REQUEST_TYPE = 6,
    VT_DATA_TYPE = 8,
    VT_DATA = 10
  };
  const sparetools::bpm::Header *header() const {
    return GetPointer<const sparetools::bpm::Header *>(VT_HEADER);
  }
  sparetools::bpm::RequestType request_type() const {
    return static_cast<sparetools::bpm::RequestType>(GetField<int8_t>(VT_REQUEST_TYPE, 0));
  }
  sparetools::bpm::RequestPayload data_type() const {
    return static_cast<sparetools::bpm::RequestPayload>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<int8_t>(verifier, VT_REQUEST_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct RequestBuilder {
  typedef Request Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_header(flatbuffers::Offset<sparetools::bpm::Header> header) {
    fbb_.AddOffset(Request::VT_HEADER, header);
  }
  void add_request_type(sparetools::bpm::RequestType request_type) {
    fbb_.AddElement<int8_t>(Request::VT_REQUEST_TYPE, static_cast<int8_t>(request_type), 0);
  }
  void add_data_type(sparetools::bpm::RequestPayload data_type) {
    fbb_.AddElement<uint8_t>(Request::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Request::VT_DATA, data);
  }
  explicit RequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request> CreateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<sparetools::bpm::Header> header = 0,
    sparetools::bpm::RequestType request_type = sparetools::bpm::RequestType_GET_STATUS,
    sparetools::bpm::RequestPayload data_type = sparetools::bpm::RequestPayload_NONE,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  RequestBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_header(header);
  builder_.add_data_type(data_type);
  builder_.add_request_type(request_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request> CreateRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<sparetools::bpm::Header> header = 0,
    sparetools::bpm::RequestType request_type = sparetools::bpm::RequestType_GET_STATUS,
    sparetools::bpm::RequestPayload data_type = sparetools::bpm::RequestPayload_NONE,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return sparetools::bpm::CreateRequest(
      _fbb,
      header,
      request_type,
      data_type,
      data__);
}

struct BPMAnalysis FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BPMAnalysisBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STABILITY = 4,
    VT_REGULARITY = 6,
    VT_DOMINANT_FREQUENCY = 8,
    VT_SPECTRAL_CENTROID = 10,
    VT_BEAT_POSITION = 12,
    VT_TEMPO_CONSISTENCY = 14
  };
  float stability() const {
    return GetField<float>(VT_STABILITY, 0.0f);
  }
  float regularity() const {
    return GetField<float>(VT_REGULARITY, 0.0f);
  }
  float dominant_frequency() const {
    return GetField<float>(VT_DOMINANT_FREQUENCY, 0.0f);
  }
  float spectral_centroid() const {
    return GetField<float>(VT_SPECTRAL_CENTROID, 0.0f);
  }
  float beat_position() const {
    return GetField<float>(VT_BEAT_POSITION, 0.0f);
  }
  float tempo_consistency() const {
    return GetField<float>(VT_TEMPO_CONSISTENCY, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_STABILITY, 4) &&
           VerifyField<float>(verifier, VT_REGULARITY, 4) &&
           VerifyField<float>(verifier, VT_DOMINANT_FREQUENCY, 4) &&
           VerifyField<float>(verifier, VT_SPECTRAL_CENTROID, 4) &&
           VerifyField<float>(verifier, VT_BEAT_POSITION, 4) &&
           VerifyField<float>(verifier, VT_TEMPO_CONSISTENCY, 4) &&
           verifier.EndTable();
  }
};

struct BPMAnalysisBuilder {
  typedef BPMAnalysis Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stability(float stability) {
    fbb_.AddElement<float>(BPMAnalysis::VT_STABILITY, stability, 0.0f);
  }
  void add_regularity(float regularity) {
    fbb_.AddElement<float>(BPMAnalysis::VT_REGULARITY, regularity, 0.0f);
  }
  void add_dominant_frequency(float dominant_frequency) {
    fbb_.AddElement<float>(BPMAnalysis::VT_DOMINANT_FREQUENCY, dominant_frequency, 0.0f);
  }
  void add_spectral_centroid(float spectral_centroid) {
    fbb_.AddElement<float>(BPMAnalysis::VT_SPECTRAL_CENTROID, spectral_centroid, 0.0f);
  }
  void add_beat_position(float beat_position) {
    fbb_.AddElement<float>(BPMAnalysis::VT_BEAT_POSITION, beat_position, 0.0f);
  }
  void add_tempo_consistency(float tempo_consistency) {
    fbb_.AddElement<float>(BPMAnalysis::VT_TEMPO_CONSISTENCY, tempo_consistency, 0.0f);
  }
  explicit BPMAnalysisBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BPMAnalysis> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BPMAnalysis>(end);
    return o;
  }
};

inline flatbuffers::Offset<BPMAnalysis> CreateBPMAnalysis(
    flatbuffers::FlatBufferBuilder &_fbb,
    float stability = 0.0f,
    float regularity = 0.0f,
    float dominant_frequency = 0.0f,
    float spectral_centroid = 0.0f,
    float beat_position = 0.0f,
    float tempo_consistency = 0.0f) {
  BPMAnalysisBuilder builder_(_fbb);
  builder_.add_tempo_consistency(tempo_consistency);
  builder_.add_beat_position(beat_position);
  builder_.add_spectral_centroid(spectral_centroid);
  builder_.add_dominant_frequency(dominant_frequency);
  builder_.add_regularity(regularity);
  builder_.add_stability(stability);
  return builder_.Finish();
}

struct BPMQuality FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BPMQualityBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SNR_DB = 4,
    VT_CONSECUTIVE_DETECTIONS = 6,
    VT_RELIABILITY_SCORE = 8,
    VT_FALSE_POSITIVE_RATE = 10,
    VT_ALGORITHM_CONFIDENCE = 12
  };
  float snr_db() const {
    return GetField<float>(VT_SNR_DB, 0.0f);
  }
  uint16_t consecutive_detections() const {
    return GetField<uint16_t>(VT_CONSECUTIVE_DETECTIONS, 0);
  }
  float reliability_score() const {
    return GetField<float>(VT_RELIABILITY_SCORE, 0.0f);
  }
  float false_positive_rate() const {
    return GetField<float>(VT_FALSE_POSITIVE_RATE, 0.0f);
  }
  float algorithm_confidence() const {
    return GetField<float>(VT_ALGORITHM_CONFIDENCE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SNR_DB, 4) &&
           VerifyField<uint16_t>(verifier, VT_CONSECUTIVE_DETECTIONS, 2) &&
           VerifyField<float>(verifier, VT_RELIABILITY_SCORE, 4) &&
           VerifyField<float>(verifier, VT_FALSE_POSITIVE_RATE, 4) &&
           VerifyField<float>(verifier, VT_ALGORITHM_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct BPMQualityBuilder {
  typedef BPMQuality Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_snr_db(float snr_db) {
    fbb_.AddElement<float>(BPMQuality::VT_SNR_DB, snr_db, 0.0f);
  }
  void add_consecutive_detections(uint16_t consecutive_detections) {
    fbb_.AddElement<uint16_t>(BPMQuality::VT_CONSECUTIVE_DETECTIONS, consecutive_detections, 0);
  }
  void add_reliability_score(float reliability_score) {
    fbb_.AddElement<float>(BPMQuality::VT_RELIABILITY_SCORE, reliability_score, 0.0f);
  }
  void add_false_positive_rate(float false_positive_rate) {
    fbb_.AddElement<float>(BPMQuality::VT_FALSE_POSITIVE_RATE, false_positive_rate, 0.0f);
  }
  void add_algorithm_confidence(float algorithm_confidence) {
    fbb_.AddElement<float>(BPMQuality::VT_ALGORITHM_CONFIDENCE, algorithm_confidence, 0.0f);
  }
  explicit BPMQualityBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BPMQuality> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BPMQuality>(end);
    return o;
  }
};

inline flatbuffers::Offset<BPMQuality> CreateBPMQuality(
    flatbuffers::FlatBufferBuilder &_fbb,
    float snr_db = 0.0f,
    uint16_t consecutive_detections = 0,
    float reliability_score = 0.0f,
    float false_positive_rate = 0.0f,
    float algorithm_confidence = 0.0f) {
  BPMQualityBuilder builder_(_fbb);
  builder_.add_algorithm_confidence(algorithm_confidence);
  builder_.add_false_positive_rate(false_positive_rate);
  builder_.add_reliability_score(reliability_score);
  builder_.add_snr_db(snr_db);
  builder_.add_consecutive_detections(consecutive_detections);
  return builder_.Finish();
}

struct BPMUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BPMUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BPM = 4,
    VT_CONFIDENCE = 6,
    VT_SIGNAL_LEVEL = 8,
    VT_STATUS = 10,
    VT_ANALYSIS = 12,
    VT_QUALITY = 14,
    VT_TIMESTAMP = 16
  };
  float bpm() const {
    return GetField<float>(VT_BPM, 0.0f);
  }
  float confidence() const {
    return GetField<float>(VT_CONFIDENCE, 0.0f);
  }
  float signal_level() const {
    return GetField<float>(VT_SIGNAL_LEVEL, 0.0f);
  }
  sparetools::bpm::DetectionStatus status() const {
    return static_cast<sparetools::bpm::DetectionStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  const sparetools::bpm::BPMAnalysis *analysis() const {
    return GetPointer<const sparetools::bpm::BPMAnalysis *>(VT_ANALYSIS);
  }
  const sparetools::bpm::BPMQuality *quality() const {
    return GetPointer<const sparetools::bpm::BPMQuality *>(VT_QUALITY);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BPM, 4) &&
           VerifyField<float>(verifier, VT_CONFIDENCE, 4) &&
           VerifyField<float>(verifier, VT_SIGNAL_LEVEL, 4) &&
           VerifyField<int8_t>(verifier, VT_STATUS, 1) &&
           VerifyOffset(verifier, VT_ANALYSIS) &&
           verifier.VerifyTable(analysis()) &&
           VerifyOffset(verifier, VT_QUALITY) &&
           verifier.VerifyTable(quality()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct BPMUpdateBuilder {
  typedef BPMUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bpm(float bpm) {
    fbb_.AddElement<float>(BPMUpdate::VT_BPM, bpm, 0.0f);
  }
  void add_confidence(float confidence) {
    fbb_.AddElement<float>(BPMUpdate::VT_CONFIDENCE, confidence, 0.0f);
  }
  void add_signal_level(float signal_level) {
    fbb_.AddElement<float>(BPMUpdate::VT_SIGNAL_LEVEL, signal_level, 0.0f);
  }
  void add_status(sparetools::bpm::DetectionStatus status) {
    fbb_.AddElement<int8_t>(BPMUpdate::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_analysis(flatbuffers::Offset<sparetools::bpm::BPMAnalysis> analysis) {
    fbb_.AddOffset(BPMUpdate::VT_ANALYSIS, analysis);
  }
  void add_quality(flatbuffers::Offset<sparetools::bpm::BPMQuality> quality) {
    fbb_.AddOffset(BPMUpdate::VT_QUALITY, quality);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(BPMUpdate::VT_TIMESTAMP, timestamp, 0);
  }
  explicit BPMUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BPMUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BPMUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<BPMUpdate> CreateBPMUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    float bpm = 0.0f,
    float confidence = 0.0f,
    float signal_level = 0.0f,
    sparetools::bpm::DetectionStatus status = sparetools::bpm::DetectionStatus_INITIALIZING,
    flatbuffers::Offset<sparetools::bpm::BPMAnalysis> analysis = 0,
    flatbuffers::Offset<sparetools::bpm::BPMQuality> quality = 0,
    uint64_t timestamp = 0) {
  BPMUpdateBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_quality(quality);
  builder_.add_analysis(analysis);
  builder_.add_signal_level(signal_level);
  builder_.add_confidence(confidence);
  builder_.add_bpm(bpm);
  builder_.add_status(status);
  return builder_.Finish();
}

struct AudioStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AudioStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SAMPLE_RATE = 4,
    VT_BUFFER_SIZE = 6,
    VT_CHANNELS = 8,
    VT_IS_CALIBRATED = 10,
    VT_LAST_CALIBRATION = 12,
    VT_NOISE_FLOOR_DB = 14
  };
  uint32_t sample_rate() const {
    return GetField<uint32_t>(VT_SAMPLE_RATE, 25000);
  }
  uint16_t buffer_size() const {
    return GetField<uint16_t>(VT_BUFFER_SIZE, 1024);
  }
  uint8_t channels() const {
    return GetField<uint8_t>(VT_CHANNELS, 1);
  }
  bool is_calibrated() const {
    return GetField<uint8_t>(VT_IS_CALIBRATED, 0) != 0;
  }
  uint64_t last_calibration() const {
    return GetField<uint64_t>(VT_LAST_CALIBRATION, 0);
  }
  float noise_floor_db() const {
    return GetField<float>(VT_NOISE_FLOOR_DB, -60.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SAMPLE_RATE, 4) &&
           VerifyField<uint16_t>(verifier, VT_BUFFER_SIZE, 2) &&
           VerifyField<uint8_t>(verifier, VT_CHANNELS, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_CALIBRATED, 1) &&
           VerifyField<uint64_t>(verifier, VT_LAST_CALIBRATION, 8) &&
           VerifyField<float>(verifier, VT_NOISE_FLOOR_DB, 4) &&
           verifier.EndTable();
  }
};

struct AudioStatusBuilder {
  typedef AudioStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sample_rate(uint32_t sample_rate) {
    fbb_.AddElement<uint32_t>(AudioStatus::VT_SAMPLE_RATE, sample_rate, 25000);
  }
  void add_buffer_size(uint16_t buffer_size) {
    fbb_.AddElement<uint16_t>(AudioStatus::VT_BUFFER_SIZE, buffer_size, 1024);
  }
  void add_channels(uint8_t channels) {
    fbb_.AddElement<uint8_t>(AudioStatus::VT_CHANNELS, channels, 1);
  }
  void add_is_calibrated(bool is_calibrated) {
    fbb_.AddElement<uint8_t>(AudioStatus::VT_IS_CALIBRATED, static_cast<uint8_t>(is_calibrated), 0);
  }
  void add_last_calibration(uint64_t last_calibration) {
    fbb_.AddElement<uint64_t>(AudioStatus::VT_LAST_CALIBRATION, last_calibration, 0);
  }
  void add_noise_floor_db(float noise_floor_db) {
    fbb_.AddElement<float>(AudioStatus::VT_NOISE_FLOOR_DB, noise_floor_db, -60.0f);
  }
  explicit AudioStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AudioStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<AudioStatus> CreateAudioStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t sample_rate = 25000,
    uint16_t buffer_size = 1024,
    uint8_t channels = 1,
    bool is_calibrated = false,
    uint64_t last_calibration = 0,
    float noise_floor_db = -60.0f) {
  AudioStatusBuilder builder_(_fbb);
  builder_.add_last_calibration(last_calibration);
  builder_.add_noise_floor_db(noise_floor_db);
  builder_.add_sample_rate(sample_rate);
  builder_.add_buffer_size(buffer_size);
  builder_.add_is_calibrated(is_calibrated);
  builder_.add_channels(channels);
  return builder_.Finish();
}

struct AudioCalibrationData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AudioCalibrationDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REFERENCE_FREQUENCY = 4,
    VT_MEASURED_FREQUENCY = 6,
    VT_CALIBRATION_OFFSET = 8,
    VT_SNR_IMPROVEMENT_DB = 10,
    VT_TIMESTAMP = 12
  };
  float reference_frequency() const {
    return GetField<float>(VT_REFERENCE_FREQUENCY, 440.0f);
  }
  float measured_frequency() const {
    return GetField<float>(VT_MEASURED_FREQUENCY, 0.0f);
  }
  float calibration_offset() const {
    return GetField<float>(VT_CALIBRATION_OFFSET, 0.0f);
  }
  float snr_improvement_db() const {
    return GetField<float>(VT_SNR_IMPROVEMENT_DB, 0.0f);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_REFERENCE_FREQUENCY, 4) &&
           VerifyField<float>(verifier, VT_MEASURED_FREQUENCY, 4) &&
           VerifyField<float>(verifier, VT_CALIBRATION_OFFSET, 4) &&
           VerifyField<float>(verifier, VT_SNR_IMPROVEMENT_DB, 4) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct AudioCalibrationDataBuilder {
  typedef AudioCalibrationData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reference_frequency(float reference_frequency) {
    fbb_.AddElement<float>(AudioCalibrationData::VT_REFERENCE_FREQUENCY, reference_frequency, 440.0f);
  }
  void add_measured_frequency(float measured_frequency) {
    fbb_.AddElement<float>(AudioCalibrationData::VT_MEASURED_FREQUENCY, measured_frequency, 0.0f);
  }
  void add_calibration_offset(float calibration_offset) {
    fbb_.AddElement<float>(AudioCalibrationData::VT_CALIBRATION_OFFSET, calibration_offset, 0.0f);
  }
  void add_snr_improvement_db(float snr_improvement_db) {
    fbb_.AddElement<float>(AudioCalibrationData::VT_SNR_IMPROVEMENT_DB, snr_improvement_db, 0.0f);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(AudioCalibrationData::VT_TIMESTAMP, timestamp, 0);
  }
  explicit AudioCalibrationDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AudioCalibrationData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioCalibrationData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AudioCalibrationData> CreateAudioCalibrationData(
    flatbuffers::FlatBufferBuilder &_fbb,
    float reference_frequency = 440.0f,
    float measured_frequency = 0.0f,
    float calibration_offset = 0.0f,
    float snr_improvement_db = 0.0f,
    uint64_t timestamp = 0) {
  AudioCalibrationDataBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_snr_improvement_db(snr_improvement_db);
  builder_.add_calibration_offset(calibration_offset);
  builder_.add_measured_frequency(measured_frequency);
  builder_.add_reference_frequency(reference_frequency);
  return builder_.Finish();
}

struct StatusUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatusUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPTIME_SECONDS = 4,
    VT_FREE_HEAP_BYTES = 6,
    VT_MIN_FREE_HEAP_BYTES = 8,
    VT_CPU_USAGE_PERCENT = 10,
    VT_WIFI_RSSI = 12,
    VT_AUDIO_STATUS = 14,
    VT_TEMPERATURE_CELSIUS = 16,
    VT_BATTERY_LEVEL_PERCENT = 18
  };
  uint64_t uptime_seconds() const {
    return GetField<uint64_t>(VT_UPTIME_SECONDS, 0);
  }
  uint32_t free_heap_bytes() const {
    return GetField<uint32_t>(VT_FREE_HEAP_BYTES, 0);
  }
  uint32_t min_free_heap_bytes() const {
    return GetField<uint32_t>(VT_MIN_FREE_HEAP_BYTES, 0);
  }
  uint8_t cpu_usage_percent() const {
    return GetField<uint8_t>(VT_CPU_USAGE_PERCENT, 0);
  }
  int8_t wifi_rssi() const {
    return GetField<int8_t>(VT_WIFI_RSSI, 0);
  }
  const sparetools::bpm::AudioStatus *audio_status() const {
    return GetPointer<const sparetools::bpm::AudioStatus *>(VT_AUDIO_STATUS);
  }
  float temperature_celsius() const {
    return GetField<float>(VT_TEMPERATURE_CELSIUS, 0.0f);
  }
  uint8_t battery_level_percent() const {
    return GetField<uint8_t>(VT_BATTERY_LEVEL_PERCENT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_UPTIME_SECONDS, 8) &&
           VerifyField<uint32_t>(verifier, VT_FREE_HEAP_BYTES, 4) &&
           VerifyField<uint32_t>(verifier, VT_MIN_FREE_HEAP_BYTES, 4) &&
           VerifyField<uint8_t>(verifier, VT_CPU_USAGE_PERCENT, 1) &&
           VerifyField<int8_t>(verifier, VT_WIFI_RSSI, 1) &&
           VerifyOffset(verifier, VT_AUDIO_STATUS) &&
           verifier.VerifyTable(audio_status()) &&
           VerifyField<float>(verifier, VT_TEMPERATURE_CELSIUS, 4) &&
           VerifyField<uint8_t>(verifier, VT_BATTERY_LEVEL_PERCENT, 1) &&
           verifier.EndTable();
  }
};

struct StatusUpdateBuilder {
  typedef StatusUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uptime_seconds(uint64_t uptime_seconds) {
    fbb_.AddElement<uint64_t>(StatusUpdate::VT_UPTIME_SECONDS, uptime_seconds, 0);
  }
  void add_free_heap_bytes(uint32_t free_heap_bytes) {
    fbb_.AddElement<uint32_t>(StatusUpdate::VT_FREE_HEAP_BYTES, free_heap_bytes, 0);
  }
  void add_min_free_heap_bytes(uint32_t min_free_heap_bytes) {
    fbb_.AddElement<uint32_t>(StatusUpdate::VT_MIN_FREE_HEAP_BYTES, min_free_heap_bytes, 0);
  }
  void add_cpu_usage_percent(uint8_t cpu_usage_percent) {
    fbb_.AddElement<uint8_t>(StatusUpdate::VT_CPU_USAGE_PERCENT, cpu_usage_percent, 0);
  }
  void add_wifi_rssi(int8_t wifi_rssi) {
    fbb_.AddElement<int8_t>(StatusUpdate::VT_WIFI_RSSI, wifi_rssi, 0);
  }
  void add_audio_status(flatbuffers::Offset<sparetools::bpm::AudioStatus> audio_status) {
    fbb_.AddOffset(StatusUpdate::VT_AUDIO_STATUS, audio_status);
  }
  void add_temperature_celsius(float temperature_celsius) {
    fbb_.AddElement<float>(StatusUpdate::VT_TEMPERATURE_CELSIUS, temperature_celsius, 0.0f);
  }
  void add_battery_level_percent(uint8_t battery_level_percent) {
    fbb_.AddElement<uint8_t>(StatusUpdate::VT_BATTERY_LEVEL_PERCENT, battery_level_percent, 0);
  }
  explicit StatusUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StatusUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatusUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatusUpdate> CreateStatusUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t uptime_seconds = 0,
    uint32_t free_heap_bytes = 0,
    uint32_t min_free_heap_bytes = 0,
    uint8_t cpu_usage_percent = 0,
    int8_t wifi_rssi = 0,
    flatbuffers::Offset<sparetools::bpm::AudioStatus> audio_status = 0,
    float temperature_celsius = 0.0f,
    uint8_t battery_level_percent = 0) {
  StatusUpdateBuilder builder_(_fbb);
  builder_.add_uptime_seconds(uptime_seconds);
  builder_.add_temperature_celsius(temperature_celsius);
  builder_.add_audio_status(audio_status);
  builder_.add_min_free_heap_bytes(min_free_heap_bytes);
  builder_.add_free_heap_bytes(free_heap_bytes);
  builder_.add_battery_level_percent(battery_level_percent);
  builder_.add_wifi_rssi(wifi_rssi);
  builder_.add_cpu_usage_percent(cpu_usage_percent);
  return builder_.Finish();
}

struct ConfigUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConfigUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BPM_CONFIG = 4,
    VT_AUDIO_CONFIG = 6,
    VT_NETWORK_CONFIG = 8,
    VT_DISPLAY_CONFIG = 10
  };
  const sparetools::bpm::BPMConfig *bpm_config() const {
    return GetPointer<const sparetools::bpm::BPMConfig *>(VT_BPM_CONFIG);
  }
  const sparetools::bpm::AudioConfig *audio_config() const {
    return GetPointer<const sparetools::bpm::AudioConfig *>(VT_AUDIO_CONFIG);
  }
  const sparetools::bpm::NetworkConfig *network_config() const {
    return GetPointer<const sparetools::bpm::NetworkConfig *>(VT_NETWORK_CONFIG);
  }
  const sparetools::bpm::DisplayConfig *display_config() const {
    return GetPointer<const sparetools::bpm::DisplayConfig *>(VT_DISPLAY_CONFIG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BPM_CONFIG) &&
           verifier.VerifyTable(bpm_config()) &&
           VerifyOffset(verifier, VT_AUDIO_CONFIG) &&
           verifier.VerifyTable(audio_config()) &&
           VerifyOffset(verifier, VT_NETWORK_CONFIG) &&
           verifier.VerifyTable(network_config()) &&
           VerifyOffset(verifier, VT_DISPLAY_CONFIG) &&
           verifier.VerifyTable(display_config()) &&
           verifier.EndTable();
  }
};

struct ConfigUpdateBuilder {
  typedef ConfigUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bpm_config(flatbuffers::Offset<sparetools::bpm::BPMConfig> bpm_config) {
    fbb_.AddOffset(ConfigUpdate::VT_BPM_CONFIG, bpm_config);
  }
  void add_audio_config(flatbuffers::Offset<sparetools::bpm::AudioConfig> audio_config) {
    fbb_.AddOffset(ConfigUpdate::VT_AUDIO_CONFIG, audio_config);
  }
  void add_network_config(flatbuffers::Offset<sparetools::bpm::NetworkConfig> network_config) {
    fbb_.AddOffset(ConfigUpdate::VT_NETWORK_CONFIG, network_config);
  }
  void add_display_config(flatbuffers::Offset<sparetools::bpm::DisplayConfig> display_config) {
    fbb_.AddOffset(ConfigUpdate::VT_DISPLAY_CONFIG, display_config);
  }
  explicit ConfigUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConfigUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConfigUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConfigUpdate> CreateConfigUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<sparetools::bpm::BPMConfig> bpm_config = 0,
    flatbuffers::Offset<sparetools::bpm::AudioConfig> audio_config = 0,
    flatbuffers::Offset<sparetools::bpm::NetworkConfig> network_config = 0,
    flatbuffers::Offset<sparetools::bpm::DisplayConfig> display_config = 0) {
  ConfigUpdateBuilder builder_(_fbb);
  builder_.add_display_config(display_config);
  builder_.add_network_config(network_config);
  builder_.add_audio_config(audio_config);
  builder_.add_bpm_config(bpm_config);
  return builder_.Finish();
}

struct BPMConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BPMConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_BPM = 4,
    VT_MAX_BPM = 6,
    VT_CONFIDENCE_THRESHOLD = 8,
    VT_STABILITY_WEIGHT = 10,
    VT_REGULARITY_WEIGHT = 12,
    VT_QUALITY_WEIGHT = 14
  };
  uint8_t min_bpm() const {
    return GetField<uint8_t>(VT_MIN_BPM, 60);
  }
  uint8_t max_bpm() const {
    return GetField<uint8_t>(VT_MAX_BPM, 180);
  }
  float confidence_threshold() const {
    return GetField<float>(VT_CONFIDENCE_THRESHOLD, 0.7f);
  }
  float stability_weight() const {
    return GetField<float>(VT_STABILITY_WEIGHT, 0.3f);
  }
  float regularity_weight() const {
    return GetField<float>(VT_REGULARITY_WEIGHT, 0.4f);
  }
  float quality_weight() const {
    return GetField<float>(VT_QUALITY_WEIGHT, 0.3f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MIN_BPM, 1) &&
           VerifyField<uint8_t>(verifier, VT_MAX_BPM, 1) &&
           VerifyField<float>(verifier, VT_CONFIDENCE_THRESHOLD, 4) &&
           VerifyField<float>(verifier, VT_STABILITY_WEIGHT, 4) &&
           VerifyField<float>(verifier, VT_REGULARITY_WEIGHT, 4) &&
           VerifyField<float>(verifier, VT_QUALITY_WEIGHT, 4) &&
           verifier.EndTable();
  }
};

struct BPMConfigBuilder {
  typedef BPMConfig Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min_bpm(uint8_t min_bpm) {
    fbb_.AddElement<uint8_t>(BPMConfig::VT_MIN_BPM, min_bpm, 60);
  }
  void add_max_bpm(uint8_t max_bpm) {
    fbb_.AddElement<uint8_t>(BPMConfig::VT_MAX_BPM, max_bpm, 180);
  }
  void add_confidence_threshold(float confidence_threshold) {
    fbb_.AddElement<float>(BPMConfig::VT_CONFIDENCE_THRESHOLD, confidence_threshold, 0.7f);
  }
  void add_stability_weight(float stability_weight) {
    fbb_.AddElement<float>(BPMConfig::VT_STABILITY_WEIGHT, stability_weight, 0.3f);
  }
  void add_regularity_weight(float regularity_weight) {
    fbb_.AddElement<float>(BPMConfig::VT_REGULARITY_WEIGHT, regularity_weight, 0.4f);
  }
  void add_quality_weight(float quality_weight) {
    fbb_.AddElement<float>(BPMConfig::VT_QUALITY_WEIGHT, quality_weight, 0.3f);
  }
  explicit BPMConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BPMConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BPMConfig>(end);
    return o;
  }
};

inline flatbuffers::Offset<BPMConfig> CreateBPMConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t min_bpm = 60,
    uint8_t max_bpm = 180,
    float confidence_threshold = 0.7f,
    float stability_weight = 0.3f,
    float regularity_weight = 0.4f,
    float quality_weight = 0.3f) {
  BPMConfigBuilder builder_(_fbb);
  builder_.add_quality_weight(quality_weight);
  builder_.add_regularity_weight(regularity_weight);
  builder_.add_stability_weight(stability_weight);
  builder_.add_confidence_threshold(confidence_threshold);
  builder_.add_max_bpm(max_bpm);
  builder_.add_min_bpm(min_bpm);
  return builder_.Finish();
}

struct AudioConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AudioConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SAMPLE_RATE = 4,
    VT_BUFFER_SIZE = 6,
    VT_GAIN_DB = 8,
    VT_HIGH_PASS_CUTOFF = 10,
    VT_LOW_PASS_CUTOFF = 12,
    VT_ENABLE_NOISE_GATE = 14,
    VT_NOISE_GATE_THRESHOLD_DB = 16
  };
  uint32_t sample_rate() const {
    return GetField<uint32_t>(VT_SAMPLE_RATE, 25000);
  }
  uint16_t buffer_size() const {
    return GetField<uint16_t>(VT_BUFFER_SIZE, 1024);
  }
  float gain_db() const {
    return GetField<float>(VT_GAIN_DB, 0.0f);
  }
  float high_pass_cutoff() const {
    return GetField<float>(VT_HIGH_PASS_CUTOFF, 20.0f);
  }
  float low_pass_cutoff() const {
    return GetField<float>(VT_LOW_PASS_CUTOFF, 8000.0f);
  }
  bool enable_noise_gate() const {
    return GetField<uint8_t>(VT_ENABLE_NOISE_GATE, 1) != 0;
  }
  float noise_gate_threshold_db() const {
    return GetField<float>(VT_NOISE_GATE_THRESHOLD_DB, -40.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SAMPLE_RATE, 4) &&
           VerifyField<uint16_t>(verifier, VT_BUFFER_SIZE, 2) &&
           VerifyField<float>(verifier, VT_GAIN_DB, 4) &&
           VerifyField<float>(verifier, VT_HIGH_PASS_CUTOFF, 4) &&
           VerifyField<float>(verifier, VT_LOW_PASS_CUTOFF, 4) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE_NOISE_GATE, 1) &&
           VerifyField<float>(verifier, VT_NOISE_GATE_THRESHOLD_DB, 4) &&
           verifier.EndTable();
  }
};

struct AudioConfigBuilder {
  typedef AudioConfig Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sample_rate(uint32_t sample_rate) {
    fbb_.AddElement<uint32_t>(AudioConfig::VT_SAMPLE_RATE, sample_rate, 25000);
  }
  void add_buffer_size(uint16_t buffer_size) {
    fbb_.AddElement<uint16_t>(AudioConfig::VT_BUFFER_SIZE, buffer_size, 1024);
  }
  void add_gain_db(float gain_db) {
    fbb_.AddElement<float>(AudioConfig::VT_GAIN_DB, gain_db, 0.0f);
  }
  void add_high_pass_cutoff(float high_pass_cutoff) {
    fbb_.AddElement<float>(AudioConfig::VT_HIGH_PASS_CUTOFF, high_pass_cutoff, 20.0f);
  }
  void add_low_pass_cutoff(float low_pass_cutoff) {
    fbb_.AddElement<float>(AudioConfig::VT_LOW_PASS_CUTOFF, low_pass_cutoff, 8000.0f);
  }
  void add_enable_noise_gate(bool enable_noise_gate) {
    fbb_.AddElement<uint8_t>(AudioConfig::VT_ENABLE_NOISE_GATE, static_cast<uint8_t>(enable_noise_gate), 1);
  }
  void add_noise_gate_threshold_db(float noise_gate_threshold_db) {
    fbb_.AddElement<float>(AudioConfig::VT_NOISE_GATE_THRESHOLD_DB, noise_gate_threshold_db, -40.0f);
  }
  explicit AudioConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AudioConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioConfig>(end);
    return o;
  }
};

inline flatbuffers::Offset<AudioConfig> CreateAudioConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t sample_rate = 25000,
    uint16_t buffer_size = 1024,
    float gain_db = 0.0f,
    float high_pass_cutoff = 20.0f,
    float low_pass_cutoff = 8000.0f,
    bool enable_noise_gate = true,
    float noise_gate_threshold_db = -40.0f) {
  AudioConfigBuilder builder_(_fbb);
  builder_.add_noise_gate_threshold_db(noise_gate_threshold_db);
  builder_.add_low_pass_cutoff(low_pass_cutoff);
  builder_.add_high_pass_cutoff(high_pass_cutoff);
  builder_.add_gain_db(gain_db);
  builder_.add_sample_rate(sample_rate);
  builder_.add_buffer_size(buffer_size);
  builder_.add_enable_noise_gate(enable_noise_gate);
  return builder_.Finish();
}

struct NetworkConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NetworkConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIFI_SSID = 4,
    VT_WIFI_PASSWORD = 6,
    VT_ENABLE_MDNS = 8,
    VT_MDNS_HOSTNAME = 10,
    VT_WEB_PORT = 12,
    VT_WEBSOCKET_PORT = 14
  };
  const flatbuffers::String *wifi_ssid() const {
    return GetPointer<const flatbuffers::String *>(VT_WIFI_SSID);
  }
  const flatbuffers::String *wifi_password() const {
    return GetPointer<const flatbuffers::String *>(VT_WIFI_PASSWORD);
  }
  bool enable_mdns() const {
    return GetField<uint8_t>(VT_ENABLE_MDNS, 1) != 0;
  }
  const flatbuffers::String *mdns_hostname() const {
    return GetPointer<const flatbuffers::String *>(VT_MDNS_HOSTNAME);
  }
  uint16_t web_port() const {
    return GetField<uint16_t>(VT_WEB_PORT, 80);
  }
  uint16_t websocket_port() const {
    return GetField<uint16_t>(VT_WEBSOCKET_PORT, 81);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WIFI_SSID) &&
           verifier.VerifyString(wifi_ssid()) &&
           VerifyOffset(verifier, VT_WIFI_PASSWORD) &&
           verifier.VerifyString(wifi_password()) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE_MDNS, 1) &&
           VerifyOffset(verifier, VT_MDNS_HOSTNAME) &&
           verifier.VerifyString(mdns_hostname()) &&
           VerifyField<uint16_t>(verifier, VT_WEB_PORT, 2) &&
           VerifyField<uint16_t>(verifier, VT_WEBSOCKET_PORT, 2) &&
           verifier.EndTable();
  }
};

struct NetworkConfigBuilder {
  typedef NetworkConfig Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_wifi_ssid(flatbuffers::Offset<flatbuffers::String> wifi_ssid) {
    fbb_.AddOffset(NetworkConfig::VT_WIFI_SSID, wifi_ssid);
  }
  void add_wifi_password(flatbuffers::Offset<flatbuffers::String> wifi_password) {
    fbb_.AddOffset(NetworkConfig::VT_WIFI_PASSWORD, wifi_password);
  }
  void add_enable_mdns(bool enable_mdns) {
    fbb_.AddElement<uint8_t>(NetworkConfig::VT_ENABLE_MDNS, static_cast<uint8_t>(enable_mdns), 1);
  }
  void add_mdns_hostname(flatbuffers::Offset<flatbuffers::String> mdns_hostname) {
    fbb_.AddOffset(NetworkConfig::VT_MDNS_HOSTNAME, mdns_hostname);
  }
  void add_web_port(uint16_t web_port) {
    fbb_.AddElement<uint16_t>(NetworkConfig::VT_WEB_PORT, web_port, 80);
  }
  void add_websocket_port(uint16_t websocket_port) {
    fbb_.AddElement<uint16_t>(NetworkConfig::VT_WEBSOCKET_PORT, websocket_port, 81);
  }
  explicit NetworkConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NetworkConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NetworkConfig>(end);
    return o;
  }
};

inline flatbuffers::Offset<NetworkConfig> CreateNetworkConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> wifi_ssid = 0,
    flatbuffers::Offset<flatbuffers::String> wifi_password = 0,
    bool enable_mdns = true,
    flatbuffers::Offset<flatbuffers::String> mdns_hostname = 0,
    uint16_t web_port = 80,
    uint16_t websocket_port = 81) {
  NetworkConfigBuilder builder_(_fbb);
  builder_.add_mdns_hostname(mdns_hostname);
  builder_.add_wifi_password(wifi_password);
  builder_.add_wifi_ssid(wifi_ssid);
  builder_.add_websocket_port(websocket_port);
  builder_.add_web_port(web_port);
  builder_.add_enable_mdns(enable_mdns);
  return builder_.Finish();
}

inline flatbuffers::Offset<NetworkConfig> CreateNetworkConfigDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *wifi_ssid = nullptr,
    const char *wifi_password = nullptr,
    bool enable_mdns = true,
    const char *mdns_hostname = nullptr,
    uint16_t web_port = 80,
    uint16_t websocket_port = 81) {
  auto wifi_ssid__ = wifi_ssid ? _fbb.CreateString(wifi_ssid) : 0;
  auto wifi_password__ = wifi_password ? _fbb.CreateString(wifi_password) : 0;
  auto mdns_hostname__ = mdns_hostname ? _fbb.CreateString(mdns_hostname) : 0;
  return sparetools::bpm::CreateNetworkConfig(
      _fbb,
      wifi_ssid__,
      wifi_password__,
      enable_mdns,
      mdns_hostname__,
      web_port,
      websocket_port);
}

struct DisplayConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DisplayConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLE_DISPLAY = 4,
    VT_BRIGHTNESS_PERCENT = 6,
    VT_TIMEOUT_SECONDS = 8,
    VT_SHOW_BPM = 10,
    VT_SHOW_CONFIDENCE = 12,
    VT_SHOW_STATUS = 14
  };
  bool enable_display() const {
    return GetField<uint8_t>(VT_ENABLE_DISPLAY, 1) != 0;
  }
  uint8_t brightness_percent() const {
    return GetField<uint8_t>(VT_BRIGHTNESS_PERCENT, 100);
  }
  uint16_t timeout_seconds() const {
    return GetField<uint16_t>(VT_TIMEOUT_SECONDS, 30);
  }
  bool show_bpm() const {
    return GetField<uint8_t>(VT_SHOW_BPM, 1) != 0;
  }
  bool show_confidence() const {
    return GetField<uint8_t>(VT_SHOW_CONFIDENCE, 1) != 0;
  }
  bool show_status() const {
    return GetField<uint8_t>(VT_SHOW_STATUS, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE_DISPLAY, 1) &&
           VerifyField<uint8_t>(verifier, VT_BRIGHTNESS_PERCENT, 1) &&
           VerifyField<uint16_t>(verifier, VT_TIMEOUT_SECONDS, 2) &&
           VerifyField<uint8_t>(verifier, VT_SHOW_BPM, 1) &&
           VerifyField<uint8_t>(verifier, VT_SHOW_CONFIDENCE, 1) &&
           VerifyField<uint8_t>(verifier, VT_SHOW_STATUS, 1) &&
           verifier.EndTable();
  }
};

struct DisplayConfigBuilder {
  typedef DisplayConfig Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable_display(bool enable_display) {
    fbb_.AddElement<uint8_t>(DisplayConfig::VT_ENABLE_DISPLAY, static_cast<uint8_t>(enable_display), 1);
  }
  void add_brightness_percent(uint8_t brightness_percent) {
    fbb_.AddElement<uint8_t>(DisplayConfig::VT_BRIGHTNESS_PERCENT, brightness_percent, 100);
  }
  void add_timeout_seconds(uint16_t timeout_seconds) {
    fbb_.AddElement<uint16_t>(DisplayConfig::VT_TIMEOUT_SECONDS, timeout_seconds, 30);
  }
  void add_show_bpm(bool show_bpm) {
    fbb_.AddElement<uint8_t>(DisplayConfig::VT_SHOW_BPM, static_cast<uint8_t>(show_bpm), 1);
  }
  void add_show_confidence(bool show_confidence) {
    fbb_.AddElement<uint8_t>(DisplayConfig::VT_SHOW_CONFIDENCE, static_cast<uint8_t>(show_confidence), 1);
  }
  void add_show_status(bool show_status) {
    fbb_.AddElement<uint8_t>(DisplayConfig::VT_SHOW_STATUS, static_cast<uint8_t>(show_status), 1);
  }
  explicit DisplayConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DisplayConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DisplayConfig>(end);
    return o;
  }
};

inline flatbuffers::Offset<DisplayConfig> CreateDisplayConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable_display = true,
    uint8_t brightness_percent = 100,
    uint16_t timeout_seconds = 30,
    bool show_bpm = true,
    bool show_confidence = true,
    bool show_status = true) {
  DisplayConfigBuilder builder_(_fbb);
  builder_.add_timeout_seconds(timeout_seconds);
  builder_.add_show_status(show_status);
  builder_.add_show_confidence(show_confidence);
  builder_.add_show_bpm(show_bpm);
  builder_.add_brightness_percent(brightness_percent);
  builder_.add_enable_display(enable_display);
  return builder_.Finish();
}

struct ErrorReport FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ErrorReportBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_ERROR_MESSAGE = 6,
    VT_TIMESTAMP = 8,
    VT_CONTEXT = 10
  };
  int32_t error_code() const {
    return GetField<int32_t>(VT_ERROR_CODE, 0);
  }
  const flatbuffers::String *error_message() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  const flatbuffers::String *context() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTEXT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE, 4) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyOffset(verifier, VT_CONTEXT) &&
           verifier.VerifyString(context()) &&
           verifier.EndTable();
  }
};

struct ErrorReportBuilder {
  typedef ErrorReport Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(int32_t error_code) {
    fbb_.AddElement<int32_t>(ErrorReport::VT_ERROR_CODE, error_code, 0);
  }
  void add_error_message(flatbuffers::Offset<flatbuffers::String> error_message) {
    fbb_.AddOffset(ErrorReport::VT_ERROR_MESSAGE, error_message);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(ErrorReport::VT_TIMESTAMP, timestamp, 0);
  }
  void add_context(flatbuffers::Offset<flatbuffers::String> context) {
    fbb_.AddOffset(ErrorReport::VT_CONTEXT, context);
  }
  explicit ErrorReportBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ErrorReport> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ErrorReport>(end);
    return o;
  }
};

inline flatbuffers::Offset<ErrorReport> CreateErrorReport(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t error_code = 0,
    flatbuffers::Offset<flatbuffers::String> error_message = 0,
    uint64_t timestamp = 0,
    flatbuffers::Offset<flatbuffers::String> context = 0) {
  ErrorReportBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_context(context);
  builder_.add_error_message(error_message);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<ErrorReport> CreateErrorReportDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t error_code = 0,
    const char *error_message = nullptr,
    uint64_t timestamp = 0,
    const char *context = nullptr) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  auto context__ = context ? _fbb.CreateString(context) : 0;
  return sparetools::bpm::CreateErrorReport(
      _fbb,
      error_code,
      error_message__,
      timestamp,
      context__);
}

struct SystemInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SystemInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIRMWARE_VERSION = 4,
    VT_HARDWARE_VERSION = 6,
    VT_ESP_IDF_VERSION = 8,
    VT_BUILD_DATE = 10,
    VT_FLASH_SIZE_BYTES = 12,
    VT_PSRAM_SIZE_BYTES = 14
  };
  const flatbuffers::String *firmware_version() const {
    return GetPointer<const flatbuffers::String *>(VT_FIRMWARE_VERSION);
  }
  const flatbuffers::String *hardware_version() const {
    return GetPointer<const flatbuffers::String *>(VT_HARDWARE_VERSION);
  }
  const flatbuffers::String *esp_idf_version() const {
    return GetPointer<const flatbuffers::String *>(VT_ESP_IDF_VERSION);
  }
  const flatbuffers::String *build_date() const {
    return GetPointer<const flatbuffers::String *>(VT_BUILD_DATE);
  }
  uint32_t flash_size_bytes() const {
    return GetField<uint32_t>(VT_FLASH_SIZE_BYTES, 0);
  }
  uint32_t psram_size_bytes() const {
    return GetField<uint32_t>(VT_PSRAM_SIZE_BYTES, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIRMWARE_VERSION) &&
           verifier.VerifyString(firmware_version()) &&
           VerifyOffset(verifier, VT_HARDWARE_VERSION) &&
           verifier.VerifyString(hardware_version()) &&
           VerifyOffset(verifier, VT_ESP_IDF_VERSION) &&
           verifier.VerifyString(esp_idf_version()) &&
           VerifyOffset(verifier, VT_BUILD_DATE) &&
           verifier.VerifyString(build_date()) &&
           VerifyField<uint32_t>(verifier, VT_FLASH_SIZE_BYTES, 4) &&
           VerifyField<uint32_t>(verifier, VT_PSRAM_SIZE_BYTES, 4) &&
           verifier.EndTable();
  }
};

struct SystemInfoBuilder {
  typedef SystemInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_firmware_version(flatbuffers::Offset<flatbuffers::String> firmware_version) {
    fbb_.AddOffset(SystemInfo::VT_FIRMWARE_VERSION, firmware_version);
  }
  void add_hardware_version(flatbuffers::Offset<flatbuffers::String> hardware_version) {
    fbb_.AddOffset(SystemInfo::VT_HARDWARE_VERSION, hardware_version);
  }
  void add_esp_idf_version(flatbuffers::Offset<flatbuffers::String> esp_idf_version) {
    fbb_.AddOffset(SystemInfo::VT_ESP_IDF_VERSION, esp_idf_version);
  }
  void add_build_date(flatbuffers::Offset<flatbuffers::String> build_date) {
    fbb_.AddOffset(SystemInfo::VT_BUILD_DATE, build_date);
  }
  void add_flash_size_bytes(uint32_t flash_size_bytes) {
    fbb_.AddElement<uint32_t>(SystemInfo::VT_FLASH_SIZE_BYTES, flash_size_bytes, 0);
  }
  void add_psram_size_bytes(uint32_t psram_size_bytes) {
    fbb_.AddElement<uint32_t>(SystemInfo::VT_PSRAM_SIZE_BYTES, psram_size_bytes, 0);
  }
  explicit SystemInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SystemInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SystemInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<SystemInfo> CreateSystemInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> firmware_version = 0,
    flatbuffers::Offset<flatbuffers::String> hardware_version = 0,
    flatbuffers::Offset<flatbuffers::String> esp_idf_version = 0,
    flatbuffers::Offset<flatbuffers::String> build_date = 0,
    uint32_t flash_size_bytes = 0,
    uint32_t psram_size_bytes = 0) {
  SystemInfoBuilder builder_(_fbb);
  builder_.add_psram_size_bytes(psram_size_bytes);
  builder_.add_flash_size_bytes(flash_size_bytes);
  builder_.add_build_date(build_date);
  builder_.add_esp_idf_version(esp_idf_version);
  builder_.add_hardware_version(hardware_version);
  builder_.add_firmware_version(firmware_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<SystemInfo> CreateSystemInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *firmware_version = nullptr,
    const char *hardware_version = nullptr,
    const char *esp_idf_version = nullptr,
    const char *build_date = nullptr,
    uint32_t flash_size_bytes = 0,
    uint32_t psram_size_bytes = 0) {
  auto firmware_version__ = firmware_version ? _fbb.CreateString(firmware_version) : 0;
  auto hardware_version__ = hardware_version ? _fbb.CreateString(hardware_version) : 0;
  auto esp_idf_version__ = esp_idf_version ? _fbb.CreateString(esp_idf_version) : 0;
  auto build_date__ = build_date ? _fbb.CreateString(build_date) : 0;
  return sparetools::bpm::CreateSystemInfo(
      _fbb,
      firmware_version__,
      hardware_version__,
      esp_idf_version__,
      build_date__,
      flash_size_bytes,
      psram_size_bytes);
}

struct AudioDiagnostics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AudioDiagnosticsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PEAK_LEVEL_DB = 4,
    VT_RMS_LEVEL_DB = 6,
    VT_CLIPPING_COUNT = 8,
    VT_UNDERRUN_COUNT = 10,
    VT_SAMPLE_RATE_ACTUAL = 12,
    VT_BUFFER_UTILIZATION_PERCENT = 14,
    VT_FFT_COMPUTATION_TIME_US = 16
  };
  float peak_level_db() const {
    return GetField<float>(VT_PEAK_LEVEL_DB, 0.0f);
  }
  float rms_level_db() const {
    return GetField<float>(VT_RMS_LEVEL_DB, 0.0f);
  }
  uint32_t clipping_count() const {
    return GetField<uint32_t>(VT_CLIPPING_COUNT, 0);
  }
  uint32_t underrun_count() const {
    return GetField<uint32_t>(VT_UNDERRUN_COUNT, 0);
  }
  uint32_t sample_rate_actual() const {
    return GetField<uint32_t>(VT_SAMPLE_RATE_ACTUAL, 0);
  }
  uint8_t buffer_utilization_percent() const {
    return GetField<uint8_t>(VT_BUFFER_UTILIZATION_PERCENT, 0);
  }
  uint32_t fft_computation_time_us() const {
    return GetField<uint32_t>(VT_FFT_COMPUTATION_TIME_US, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_PEAK_LEVEL_DB, 4) &&
           VerifyField<float>(verifier, VT_RMS_LEVEL_DB, 4) &&
           VerifyField<uint32_t>(verifier, VT_CLIPPING_COUNT, 4) &&
           VerifyField<uint32_t>(verifier, VT_UNDERRUN_COUNT, 4) &&
           VerifyField<uint32_t>(verifier, VT_SAMPLE_RATE_ACTUAL, 4) &&
           VerifyField<uint8_t>(verifier, VT_BUFFER_UTILIZATION_PERCENT, 1) &&
           VerifyField<uint32_t>(verifier, VT_FFT_COMPUTATION_TIME_US, 4) &&
           verifier.EndTable();
  }
};

struct AudioDiagnosticsBuilder {
  typedef AudioDiagnostics Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peak_level_db(float peak_level_db) {
    fbb_.AddElement<float>(AudioDiagnostics::VT_PEAK_LEVEL_DB, peak_level_db, 0.0f);
  }
  void add_rms_level_db(float rms_level_db) {
    fbb_.AddElement<float>(AudioDiagnostics::VT_RMS_LEVEL_DB, rms_level_db, 0.0f);
  }
  void add_clipping_count(uint32_t clipping_count) {
    fbb_.AddElement<uint32_t>(AudioDiagnostics::VT_CLIPPING_COUNT, clipping_count, 0);
  }
  void add_underrun_count(uint32_t underrun_count) {
    fbb_.AddElement<uint32_t>(AudioDiagnostics::VT_UNDERRUN_COUNT, underrun_count, 0);
  }
  void add_sample_rate_actual(uint32_t sample_rate_actual) {
    fbb_.AddElement<uint32_t>(AudioDiagnostics::VT_SAMPLE_RATE_ACTUAL, sample_rate_actual, 0);
  }
  void add_buffer_utilization_percent(uint8_t buffer_utilization_percent) {
    fbb_.AddElement<uint8_t>(AudioDiagnostics::VT_BUFFER_UTILIZATION_PERCENT, buffer_utilization_percent, 0);
  }
  void add_fft_computation_time_us(uint32_t fft_computation_time_us) {
    fbb_.AddElement<uint32_t>(AudioDiagnostics::VT_FFT_COMPUTATION_TIME_US, fft_computation_time_us, 0);
  }
  explicit AudioDiagnosticsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AudioDiagnostics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioDiagnostics>(end);
    return o;
  }
};

inline flatbuffers::Offset<AudioDiagnostics> CreateAudioDiagnostics(
    flatbuffers::FlatBufferBuilder &_fbb,
    float peak_level_db = 0.0f,
    float rms_level_db = 0.0f,
    uint32_t clipping_count = 0,
    uint32_t underrun_count = 0,
    uint32_t sample_rate_actual = 0,
    uint8_t buffer_utilization_percent = 0,
    uint32_t fft_computation_time_us = 0) {
  AudioDiagnosticsBuilder builder_(_fbb);
  builder_.add_fft_computation_time_us(fft_computation_time_us);
  builder_.add_sample_rate_actual(sample_rate_actual);
  builder_.add_underrun_count(underrun_count);
  builder_.add_clipping_count(clipping_count);
  builder_.add_rms_level_db(rms_level_db);
  builder_.add_peak_level_db(peak_level_db);
  builder_.add_buffer_utilization_percent(buffer_utilization_percent);
  return builder_.Finish();
}

struct NetworkDiagnostics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NetworkDiagnosticsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIFI_CONNECTED = 4,
    VT_IP_ADDRESS = 6,
    VT_GATEWAY = 8,
    VT_SUBNET = 10,
    VT_DNS_SERVER = 12,
    VT_RSSI = 14,
    VT_CHANNEL = 16,
    VT_TX_POWER = 18,
    VT_CONNECTION_TIME_SECONDS = 20,
    VT_RECONNECT_COUNT = 22
  };
  bool wifi_connected() const {
    return GetField<uint8_t>(VT_WIFI_CONNECTED, 0) != 0;
  }
  const flatbuffers::String *ip_address() const {
    return GetPointer<const flatbuffers::String *>(VT_IP_ADDRESS);
  }
  const flatbuffers::String *gateway() const {
    return GetPointer<const flatbuffers::String *>(VT_GATEWAY);
  }
  const flatbuffers::String *subnet() const {
    return GetPointer<const flatbuffers::String *>(VT_SUBNET);
  }
  const flatbuffers::String *dns_server() const {
    return GetPointer<const flatbuffers::String *>(VT_DNS_SERVER);
  }
  int8_t rssi() const {
    return GetField<int8_t>(VT_RSSI, 0);
  }
  uint8_t channel() const {
    return GetField<uint8_t>(VT_CHANNEL, 0);
  }
  int8_t tx_power() const {
    return GetField<int8_t>(VT_TX_POWER, 0);
  }
  uint64_t connection_time_seconds() const {
    return GetField<uint64_t>(VT_CONNECTION_TIME_SECONDS, 0);
  }
  uint32_t reconnect_count() const {
    return GetField<uint32_t>(VT_RECONNECT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_WIFI_CONNECTED, 1) &&
           VerifyOffset(verifier, VT_IP_ADDRESS) &&
           verifier.VerifyString(ip_address()) &&
           VerifyOffset(verifier, VT_GATEWAY) &&
           verifier.VerifyString(gateway()) &&
           VerifyOffset(verifier, VT_SUBNET) &&
           verifier.VerifyString(subnet()) &&
           VerifyOffset(verifier, VT_DNS_SERVER) &&
           verifier.VerifyString(dns_server()) &&
           VerifyField<int8_t>(verifier, VT_RSSI, 1) &&
           VerifyField<uint8_t>(verifier, VT_CHANNEL, 1) &&
           VerifyField<int8_t>(verifier, VT_TX_POWER, 1) &&
           VerifyField<uint64_t>(verifier, VT_CONNECTION_TIME_SECONDS, 8) &&
           VerifyField<uint32_t>(verifier, VT_RECONNECT_COUNT, 4) &&
           verifier.EndTable();
  }
};

struct NetworkDiagnosticsBuilder {
  typedef NetworkDiagnostics Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_wifi_connected(bool wifi_connected) {
    fbb_.AddElement<uint8_t>(NetworkDiagnostics::VT_WIFI_CONNECTED, static_cast<uint8_t>(wifi_connected), 0);
  }
  void add_ip_address(flatbuffers::Offset<flatbuffers::String> ip_address) {
    fbb_.AddOffset(NetworkDiagnostics::VT_IP_ADDRESS, ip_address);
  }
  void add_gateway(flatbuffers::Offset<flatbuffers::String> gateway) {
    fbb_.AddOffset(NetworkDiagnostics::VT_GATEWAY, gateway);
  }
  void add_subnet(flatbuffers::Offset<flatbuffers::String> subnet) {
    fbb_.AddOffset(NetworkDiagnostics::VT_SUBNET, subnet);
  }
  void add_dns_server(flatbuffers::Offset<flatbuffers::String> dns_server) {
    fbb_.AddOffset(NetworkDiagnostics::VT_DNS_SERVER, dns_server);
  }
  void add_rssi(int8_t rssi) {
    fbb_.AddElement<int8_t>(NetworkDiagnostics::VT_RSSI, rssi, 0);
  }
  void add_channel(uint8_t channel) {
    fbb_.AddElement<uint8_t>(NetworkDiagnostics::VT_CHANNEL, channel, 0);
  }
  void add_tx_power(int8_t tx_power) {
    fbb_.AddElement<int8_t>(NetworkDiagnostics::VT_TX_POWER, tx_power, 0);
  }
  void add_connection_time_seconds(uint64_t connection_time_seconds) {
    fbb_.AddElement<uint64_t>(NetworkDiagnostics::VT_CONNECTION_TIME_SECONDS, connection_time_seconds, 0);
  }
  void add_reconnect_count(uint32_t reconnect_count) {
    fbb_.AddElement<uint32_t>(NetworkDiagnostics::VT_RECONNECT_COUNT, reconnect_count, 0);
  }
  explicit NetworkDiagnosticsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NetworkDiagnostics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NetworkDiagnostics>(end);
    return o;
  }
};

inline flatbuffers::Offset<NetworkDiagnostics> CreateNetworkDiagnostics(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool wifi_connected = false,
    flatbuffers::Offset<flatbuffers::String> ip_address = 0,
    flatbuffers::Offset<flatbuffers::String> gateway = 0,
    flatbuffers::Offset<flatbuffers::String> subnet = 0,
    flatbuffers::Offset<flatbuffers::String> dns_server = 0,
    int8_t rssi = 0,
    uint8_t channel = 0,
    int8_t tx_power = 0,
    uint64_t connection_time_seconds = 0,
    uint32_t reconnect_count = 0) {
  NetworkDiagnosticsBuilder builder_(_fbb);
  builder_.add_connection_time_seconds(connection_time_seconds);
  builder_.add_reconnect_count(reconnect_count);
  builder_.add_dns_server(dns_server);
  builder_.add_subnet(subnet);
  builder_.add_gateway(gateway);
  builder_.add_ip_address(ip_address);
  builder_.add_tx_power(tx_power);
  builder_.add_channel(channel);
  builder_.add_rssi(rssi);
  builder_.add_wifi_connected(wifi_connected);
  return builder_.Finish();
}

inline flatbuffers::Offset<NetworkDiagnostics> CreateNetworkDiagnosticsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool wifi_connected = false,
    const char *ip_address = nullptr,
    const char *gateway = nullptr,
    const char *subnet = nullptr,
    const char *dns_server = nullptr,
    int8_t rssi = 0,
    uint8_t channel = 0,
    int8_t tx_power = 0,
    uint64_t connection_time_seconds = 0,
    uint32_t reconnect_count = 0) {
  auto ip_address__ = ip_address ? _fbb.CreateString(ip_address) : 0;
  auto gateway__ = gateway ? _fbb.CreateString(gateway) : 0;
  auto subnet__ = subnet ? _fbb.CreateString(subnet) : 0;
  auto dns_server__ = dns_server ? _fbb.CreateString(dns_server) : 0;
  return sparetools::bpm::CreateNetworkDiagnostics(
      _fbb,
      wifi_connected,
      ip_address__,
      gateway__,
      subnet__,
      dns_server__,
      rssi,
      channel,
      tx_power,
      connection_time_seconds,
      reconnect_count);
}

struct PerformanceMetrics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PerformanceMetricsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FREE_HEAP_BYTES = 4,
    VT_MIN_FREE_HEAP_BYTES = 6,
    VT_LARGEST_FREE_BLOCK_BYTES = 8,
    VT_CPU_USAGE_PERCENT = 10,
    VT_TASK_COUNT = 12,
    VT_UPTIME_SECONDS = 14,
    VT_RESET_REASON = 16
  };
  uint32_t free_heap_bytes() const {
    return GetField<uint32_t>(VT_FREE_HEAP_BYTES, 0);
  }
  uint32_t min_free_heap_bytes() const {
    return GetField<uint32_t>(VT_MIN_FREE_HEAP_BYTES, 0);
  }
  uint32_t largest_free_block_bytes() const {
    return GetField<uint32_t>(VT_LARGEST_FREE_BLOCK_BYTES, 0);
  }
  uint8_t cpu_usage_percent() const {
    return GetField<uint8_t>(VT_CPU_USAGE_PERCENT, 0);
  }
  uint8_t task_count() const {
    return GetField<uint8_t>(VT_TASK_COUNT, 0);
  }
  uint64_t uptime_seconds() const {
    return GetField<uint64_t>(VT_UPTIME_SECONDS, 0);
  }
  const flatbuffers::String *reset_reason() const {
    return GetPointer<const flatbuffers::String *>(VT_RESET_REASON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FREE_HEAP_BYTES, 4) &&
           VerifyField<uint32_t>(verifier, VT_MIN_FREE_HEAP_BYTES, 4) &&
           VerifyField<uint32_t>(verifier, VT_LARGEST_FREE_BLOCK_BYTES, 4) &&
           VerifyField<uint8_t>(verifier, VT_CPU_USAGE_PERCENT, 1) &&
           VerifyField<uint8_t>(verifier, VT_TASK_COUNT, 1) &&
           VerifyField<uint64_t>(verifier, VT_UPTIME_SECONDS, 8) &&
           VerifyOffset(verifier, VT_RESET_REASON) &&
           verifier.VerifyString(reset_reason()) &&
           verifier.EndTable();
  }
};

struct PerformanceMetricsBuilder {
  typedef PerformanceMetrics Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_free_heap_bytes(uint32_t free_heap_bytes) {
    fbb_.AddElement<uint32_t>(PerformanceMetrics::VT_FREE_HEAP_BYTES, free_heap_bytes, 0);
  }
  void add_min_free_heap_bytes(uint32_t min_free_heap_bytes) {
    fbb_.AddElement<uint32_t>(PerformanceMetrics::VT_MIN_FREE_HEAP_BYTES, min_free_heap_bytes, 0);
  }
  void add_largest_free_block_bytes(uint32_t largest_free_block_bytes) {
    fbb_.AddElement<uint32_t>(PerformanceMetrics::VT_LARGEST_FREE_BLOCK_BYTES, largest_free_block_bytes, 0);
  }
  void add_cpu_usage_percent(uint8_t cpu_usage_percent) {
    fbb_.AddElement<uint8_t>(PerformanceMetrics::VT_CPU_USAGE_PERCENT, cpu_usage_percent, 0);
  }
  void add_task_count(uint8_t task_count) {
    fbb_.AddElement<uint8_t>(PerformanceMetrics::VT_TASK_COUNT, task_count, 0);
  }
  void add_uptime_seconds(uint64_t uptime_seconds) {
    fbb_.AddElement<uint64_t>(PerformanceMetrics::VT_UPTIME_SECONDS, uptime_seconds, 0);
  }
  void add_reset_reason(flatbuffers::Offset<flatbuffers::String> reset_reason) {
    fbb_.AddOffset(PerformanceMetrics::VT_RESET_REASON, reset_reason);
  }
  explicit PerformanceMetricsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PerformanceMetrics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PerformanceMetrics>(end);
    return o;
  }
};

inline flatbuffers::Offset<PerformanceMetrics> CreatePerformanceMetrics(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t free_heap_bytes = 0,
    uint32_t min_free_heap_bytes = 0,
    uint32_t largest_free_block_bytes = 0,
    uint8_t cpu_usage_percent = 0,
    uint8_t task_count = 0,
    uint64_t uptime_seconds = 0,
    flatbuffers::Offset<flatbuffers::String> reset_reason = 0) {
  PerformanceMetricsBuilder builder_(_fbb);
  builder_.add_uptime_seconds(uptime_seconds);
  builder_.add_reset_reason(reset_reason);
  builder_.add_largest_free_block_bytes(largest_free_block_bytes);
  builder_.add_min_free_heap_bytes(min_free_heap_bytes);
  builder_.add_free_heap_bytes(free_heap_bytes);
  builder_.add_task_count(task_count);
  builder_.add_cpu_usage_percent(cpu_usage_percent);
  return builder_.Finish();
}

inline flatbuffers::Offset<PerformanceMetrics> CreatePerformanceMetricsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t free_heap_bytes = 0,
    uint32_t min_free_heap_bytes = 0,
    uint32_t largest_free_block_bytes = 0,
    uint8_t cpu_usage_percent = 0,
    uint8_t task_count = 0,
    uint64_t uptime_seconds = 0,
    const char *reset_reason = nullptr) {
  auto reset_reason__ = reset_reason ? _fbb.CreateString(reset_reason) : 0;
  return sparetools::bpm::CreatePerformanceMetrics(
      _fbb,
      free_heap_bytes,
      min_free_heap_bytes,
      largest_free_block_bytes,
      cpu_usage_percent,
      task_count,
      uptime_seconds,
      reset_reason__);
}

struct DiagnosticsData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DiagnosticsDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SYSTEM_INFO = 4,
    VT_AUDIO_DIAGNOSTICS = 6,
    VT_NETWORK_DIAGNOSTICS = 8,
    VT_PERFORMANCE_METRICS = 10,
    VT_TIMESTAMP = 12
  };
  const sparetools::bpm::SystemInfo *system_info() const {
    return GetPointer<const sparetools::bpm::SystemInfo *>(VT_SYSTEM_INFO);
  }
  const sparetools::bpm::AudioDiagnostics *audio_diagnostics() const {
    return GetPointer<const sparetools::bpm::AudioDiagnostics *>(VT_AUDIO_DIAGNOSTICS);
  }
  const sparetools::bpm::NetworkDiagnostics *network_diagnostics() const {
    return GetPointer<const sparetools::bpm::NetworkDiagnostics *>(VT_NETWORK_DIAGNOSTICS);
  }
  const sparetools::bpm::PerformanceMetrics *performance_metrics() const {
    return GetPointer<const sparetools::bpm::PerformanceMetrics *>(VT_PERFORMANCE_METRICS);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SYSTEM_INFO) &&
           verifier.VerifyTable(system_info()) &&
           VerifyOffset(verifier, VT_AUDIO_DIAGNOSTICS) &&
           verifier.VerifyTable(audio_diagnostics()) &&
           VerifyOffset(verifier, VT_NETWORK_DIAGNOSTICS) &&
           verifier.VerifyTable(network_diagnostics()) &&
           VerifyOffset(verifier, VT_PERFORMANCE_METRICS) &&
           verifier.VerifyTable(performance_metrics()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct DiagnosticsDataBuilder {
  typedef DiagnosticsData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_system_info(flatbuffers::Offset<sparetools::bpm::SystemInfo> system_info) {
    fbb_.AddOffset(DiagnosticsData::VT_SYSTEM_INFO, system_info);
  }
  void add_audio_diagnostics(flatbuffers::Offset<sparetools::bpm::AudioDiagnostics> audio_diagnostics) {
    fbb_.AddOffset(DiagnosticsData::VT_AUDIO_DIAGNOSTICS, audio_diagnostics);
  }
  void add_network_diagnostics(flatbuffers::Offset<sparetools::bpm::NetworkDiagnostics> network_diagnostics) {
    fbb_.AddOffset(DiagnosticsData::VT_NETWORK_DIAGNOSTICS, network_diagnostics);
  }
  void add_performance_metrics(flatbuffers::Offset<sparetools::bpm::PerformanceMetrics> performance_metrics) {
    fbb_.AddOffset(DiagnosticsData::VT_PERFORMANCE_METRICS, performance_metrics);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(DiagnosticsData::VT_TIMESTAMP, timestamp, 0);
  }
  explicit DiagnosticsDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DiagnosticsData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DiagnosticsData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DiagnosticsData> CreateDiagnosticsData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<sparetools::bpm::SystemInfo> system_info = 0,
    flatbuffers::Offset<sparetools::bpm::AudioDiagnostics> audio_diagnostics = 0,
    flatbuffers::Offset<sparetools::bpm::NetworkDiagnostics> network_diagnostics = 0,
    flatbuffers::Offset<sparetools::bpm::PerformanceMetrics> performance_metrics = 0,
    uint64_t timestamp = 0) {
  DiagnosticsDataBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_performance_metrics(performance_metrics);
  builder_.add_network_diagnostics(network_diagnostics);
  builder_.add_audio_diagnostics(audio_diagnostics);
  builder_.add_system_info(system_info);
  return builder_.Finish();
}

struct GetStatusResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetStatusResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4
  };
  const sparetools::bpm::StatusUpdate *status() const {
    return GetPointer<const sparetools::bpm::StatusUpdate *>(VT_STATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           verifier.EndTable();
  }
};

struct GetStatusResponseBuilder {
  typedef GetStatusResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(flatbuffers::Offset<sparetools::bpm::StatusUpdate> status) {
    fbb_.AddOffset(GetStatusResponse::VT_STATUS, status);
  }
  explicit GetStatusResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GetStatusResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetStatusResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetStatusResponse> CreateGetStatusResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<sparetools::bpm::StatusUpdate> status = 0) {
  GetStatusResponseBuilder builder_(_fbb);
  builder_.add_status(status);
  return builder_.Finish();
}

struct GetConfigResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetConfigResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONFIG = 4
  };
  const sparetools::bpm::ConfigUpdate *config() const {
    return GetPointer<const sparetools::bpm::ConfigUpdate *>(VT_CONFIG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           verifier.VerifyTable(config()) &&
           verifier.EndTable();
  }
};

struct GetConfigResponseBuilder {
  typedef GetConfigResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_config(flatbuffers::Offset<sparetools::bpm::ConfigUpdate> config) {
    fbb_.AddOffset(GetConfigResponse::VT_CONFIG, config);
  }
  explicit GetConfigResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GetConfigResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetConfigResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetConfigResponse> CreateGetConfigResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<sparetools::bpm::ConfigUpdate> config = 0) {
  GetConfigResponseBuilder builder_(_fbb);
  builder_.add_config(config);
  return builder_.Finish();
}

struct SetConfigResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SetConfigResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4,
    VT_MESSAGE = 6
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct SetConfigResponseBuilder {
  typedef SetConfigResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(SetConfigResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(SetConfigResponse::VT_MESSAGE, message);
  }
  explicit SetConfigResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SetConfigResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetConfigResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetConfigResponse> CreateSetConfigResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  SetConfigResponseBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_success(success);
  return builder_.Finish();
}

inline flatbuffers::Offset<SetConfigResponse> CreateSetConfigResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return sparetools::bpm::CreateSetConfigResponse(
      _fbb,
      success,
      message__);
}

struct ResetDeviceResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResetDeviceResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACKNOWLEDGED = 4
  };
  bool acknowledged() const {
    return GetField<uint8_t>(VT_ACKNOWLEDGED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ACKNOWLEDGED, 1) &&
           verifier.EndTable();
  }
};

struct ResetDeviceResponseBuilder {
  typedef ResetDeviceResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acknowledged(bool acknowledged) {
    fbb_.AddElement<uint8_t>(ResetDeviceResponse::VT_ACKNOWLEDGED, static_cast<uint8_t>(acknowledged), 0);
  }
  explicit ResetDeviceResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ResetDeviceResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResetDeviceResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResetDeviceResponse> CreateResetDeviceResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool acknowledged = false) {
  ResetDeviceResponseBuilder builder_(_fbb);
  builder_.add_acknowledged(acknowledged);
  return builder_.Finish();
}

struct CalibrateAudioResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CalibrateAudioResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4,
    VT_CALIBRATION_DATA = 6,
    VT_MESSAGE = 8
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const sparetools::bpm::AudioCalibrationData *calibration_data() const {
    return GetPointer<const sparetools::bpm::AudioCalibrationData *>(VT_CALIBRATION_DATA);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffset(verifier, VT_CALIBRATION_DATA) &&
           verifier.VerifyTable(calibration_data()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct CalibrateAudioResponseBuilder {
  typedef CalibrateAudioResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(CalibrateAudioResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_calibration_data(flatbuffers::Offset<sparetools::bpm::AudioCalibrationData> calibration_data) {
    fbb_.AddOffset(CalibrateAudioResponse::VT_CALIBRATION_DATA, calibration_data);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(CalibrateAudioResponse::VT_MESSAGE, message);
  }
  explicit CalibrateAudioResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CalibrateAudioResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CalibrateAudioResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<CalibrateAudioResponse> CreateCalibrateAudioResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    flatbuffers::Offset<sparetools::bpm::AudioCalibrationData> calibration_data = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  CalibrateAudioResponseBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_calibration_data(calibration_data);
  builder_.add_success(success);
  return builder_.Finish();
}

inline flatbuffers::Offset<CalibrateAudioResponse> CreateCalibrateAudioResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    flatbuffers::Offset<sparetools::bpm::AudioCalibrationData> calibration_data = 0,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return sparetools::bpm::CreateCalibrateAudioResponse(
      _fbb,
      success,
      calibration_data,
      message__);
}

struct StartStreamingResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StartStreamingResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4,
    VT_STREAM_ID = 6,
    VT_MESSAGE = 8
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const flatbuffers::String *stream_id() const {
    return GetPointer<const flatbuffers::String *>(VT_STREAM_ID);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffset(verifier, VT_STREAM_ID) &&
           verifier.VerifyString(stream_id()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct StartStreamingResponseBuilder {
  typedef StartStreamingResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(StartStreamingResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_stream_id(flatbuffers::Offset<flatbuffers::String> stream_id) {
    fbb_.AddOffset(StartStreamingResponse::VT_STREAM_ID, stream_id);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(StartStreamingResponse::VT_MESSAGE, message);
  }
  explicit StartStreamingResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StartStreamingResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StartStreamingResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<StartStreamingResponse> CreateStartStreamingResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    flatbuffers::Offset<flatbuffers::String> stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  StartStreamingResponseBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_stream_id(stream_id);
  builder_.add_success(success);
  return builder_.Finish();
}

inline flatbuffers::Offset<StartStreamingResponse> CreateStartStreamingResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    const char *stream_id = nullptr,
    const char *message = nullptr) {
  auto stream_id__ = stream_id ? _fbb.CreateString(stream_id) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return sparetools::bpm::CreateStartStreamingResponse(
      _fbb,
      success,
      stream_id__,
      message__);
}

struct StopStreamingResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StopStreamingResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4,
    VT_MESSAGE = 6
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct StopStreamingResponseBuilder {
  typedef StopStreamingResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(StopStreamingResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(StopStreamingResponse::VT_MESSAGE, message);
  }
  explicit StopStreamingResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StopStreamingResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StopStreamingResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<StopStreamingResponse> CreateStopStreamingResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  StopStreamingResponseBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_success(success);
  return builder_.Finish();
}

inline flatbuffers::Offset<StopStreamingResponse> CreateStopStreamingResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return sparetools::bpm::CreateStopStreamingResponse(
      _fbb,
      success,
      message__);
}

struct GetDiagnosticsResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetDiagnosticsResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIAGNOSTICS = 4
  };
  const sparetools::bpm::DiagnosticsData *diagnostics() const {
    return GetPointer<const sparetools::bpm::DiagnosticsData *>(VT_DIAGNOSTICS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIAGNOSTICS) &&
           verifier.VerifyTable(diagnostics()) &&
           verifier.EndTable();
  }
};

struct GetDiagnosticsResponseBuilder {
  typedef GetDiagnosticsResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_diagnostics(flatbuffers::Offset<sparetools::bpm::DiagnosticsData> diagnostics) {
    fbb_.AddOffset(GetDiagnosticsResponse::VT_DIAGNOSTICS, diagnostics);
  }
  explicit GetDiagnosticsResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GetDiagnosticsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetDiagnosticsResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetDiagnosticsResponse> CreateGetDiagnosticsResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<sparetools::bpm::DiagnosticsData> diagnostics = 0) {
  GetDiagnosticsResponseBuilder builder_(_fbb);
  builder_.add_diagnostics(diagnostics);
  return builder_.Finish();
}

struct Status FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_MESSAGE = 6
  };
  sparetools::bpm::StatusEnum status() const {
    return static_cast<sparetools::bpm::StatusEnum>(GetField<int32_t>(VT_STATUS, 0));
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STATUS, 4) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct StatusBuilder {
  typedef Status Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(sparetools::bpm::StatusEnum status) {
    fbb_.AddElement<int32_t>(Status::VT_STATUS, static_cast<int32_t>(status), 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Status::VT_MESSAGE, message);
  }
  explicit StatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Status> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Status>(end);
    return o;
  }
};

inline flatbuffers::Offset<Status> CreateStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    sparetools::bpm::StatusEnum status = sparetools::bpm::StatusEnum_Success,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  StatusBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<Status> CreateStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    sparetools::bpm::StatusEnum status = sparetools::bpm::StatusEnum_Success,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return sparetools::bpm::CreateStatus(
      _fbb,
      status,
      message__);
}

struct Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_STATUS = 6,
    VT_DATA_TYPE = 8,
    VT_DATA = 10
  };
  const sparetools::bpm::Header *header() const {
    return GetPointer<const sparetools::bpm::Header *>(VT_HEADER);
  }
  const sparetools::bpm::Status *status() const {
    return GetPointer<const sparetools::bpm::Status *>(VT_STATUS);
  }
  sparetools::bpm::ResponsePayload data_type() const {
    return static_cast<sparetools::bpm::ResponsePayload>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct ResponseBuilder {
  typedef Response Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_header(flatbuffers::Offset<sparetools::bpm::Header> header) {
    fbb_.AddOffset(Response::VT_HEADER, header);
  }
  void add_status(flatbuffers::Offset<sparetools::bpm::Status> status) {
    fbb_.AddOffset(Response::VT_STATUS, status);
  }
  void add_data_type(sparetools::bpm::ResponsePayload data_type) {
    fbb_.AddElement<uint8_t>(Response::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Response::VT_DATA, data);
  }
  explicit ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response> CreateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<sparetools::bpm::Header> header = 0,
    flatbuffers::Offset<sparetools::bpm::Status> status = 0,
    sparetools::bpm::ResponsePayload data_type = sparetools::bpm::ResponsePayload_NONE,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_status(status);
  builder_.add_header(header);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response> CreateResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<sparetools::bpm::Header> header = 0,
    flatbuffers::Offset<sparetools::bpm::Status> status = 0,
    sparetools::bpm::ResponsePayload data_type = sparetools::bpm::ResponsePayload_NONE,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return sparetools::bpm::CreateResponse(
      _fbb,
      header,
      status,
      data_type,
      data__);
}

inline const sparetools::bpm::Response *GetResponse(const void *buf) {
  return flatbuffers::GetRoot<sparetools::bpm::Response>(buf);
}

inline const sparetools::bpm::Response *GetSizePrefixedResponse(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<sparetools::bpm::Response>(buf);
}

inline bool VerifyResponseBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<sparetools::bpm::Response>(nullptr);
}

inline bool VerifySizePrefixedResponseBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<sparetools::bpm::Response>(nullptr);
}

inline void FinishResponseBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<sparetools::bpm::Response> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedResponseBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<sparetools::bpm::Response> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace bpm
}  // namespace sparetools

#endif  // FLATBUFFERS_GENERATED_BPMPROTOCOL_SPARETOOLS_BPM_H_
