// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BPMAUDIO_SPARETOOLS_BPM_H_
#define FLATBUFFERS_GENERATED_BPMAUDIO_SPARETOOLS_BPM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

namespace sparetools {
namespace bpm {

struct AudioStatus;
struct AudioStatusBuilder;

struct AudioCalibrationData;
struct AudioCalibrationDataBuilder;

struct AudioDiagnostics;
struct AudioDiagnosticsBuilder;

struct AudioStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AudioStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SAMPLE_RATE = 4,
    VT_BUFFER_SIZE = 6,
    VT_CHANNELS = 8,
    VT_IS_CALIBRATED = 10,
    VT_LAST_CALIBRATION = 12,
    VT_NOISE_FLOOR_DB = 14
  };
  uint32_t sample_rate() const {
    return GetField<uint32_t>(VT_SAMPLE_RATE, 25000);
  }
  uint16_t buffer_size() const {
    return GetField<uint16_t>(VT_BUFFER_SIZE, 1024);
  }
  uint8_t channels() const {
    return GetField<uint8_t>(VT_CHANNELS, 1);
  }
  bool is_calibrated() const {
    return GetField<uint8_t>(VT_IS_CALIBRATED, 0) != 0;
  }
  uint64_t last_calibration() const {
    return GetField<uint64_t>(VT_LAST_CALIBRATION, 0);
  }
  float noise_floor_db() const {
    return GetField<float>(VT_NOISE_FLOOR_DB, -60.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SAMPLE_RATE, 4) &&
           VerifyField<uint16_t>(verifier, VT_BUFFER_SIZE, 2) &&
           VerifyField<uint8_t>(verifier, VT_CHANNELS, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_CALIBRATED, 1) &&
           VerifyField<uint64_t>(verifier, VT_LAST_CALIBRATION, 8) &&
           VerifyField<float>(verifier, VT_NOISE_FLOOR_DB, 4) &&
           verifier.EndTable();
  }
};

struct AudioStatusBuilder {
  typedef AudioStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sample_rate(uint32_t sample_rate) {
    fbb_.AddElement<uint32_t>(AudioStatus::VT_SAMPLE_RATE, sample_rate, 25000);
  }
  void add_buffer_size(uint16_t buffer_size) {
    fbb_.AddElement<uint16_t>(AudioStatus::VT_BUFFER_SIZE, buffer_size, 1024);
  }
  void add_channels(uint8_t channels) {
    fbb_.AddElement<uint8_t>(AudioStatus::VT_CHANNELS, channels, 1);
  }
  void add_is_calibrated(bool is_calibrated) {
    fbb_.AddElement<uint8_t>(AudioStatus::VT_IS_CALIBRATED, static_cast<uint8_t>(is_calibrated), 0);
  }
  void add_last_calibration(uint64_t last_calibration) {
    fbb_.AddElement<uint64_t>(AudioStatus::VT_LAST_CALIBRATION, last_calibration, 0);
  }
  void add_noise_floor_db(float noise_floor_db) {
    fbb_.AddElement<float>(AudioStatus::VT_NOISE_FLOOR_DB, noise_floor_db, -60.0f);
  }
  explicit AudioStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AudioStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<AudioStatus> CreateAudioStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t sample_rate = 25000,
    uint16_t buffer_size = 1024,
    uint8_t channels = 1,
    bool is_calibrated = false,
    uint64_t last_calibration = 0,
    float noise_floor_db = -60.0f) {
  AudioStatusBuilder builder_(_fbb);
  builder_.add_last_calibration(last_calibration);
  builder_.add_noise_floor_db(noise_floor_db);
  builder_.add_sample_rate(sample_rate);
  builder_.add_buffer_size(buffer_size);
  builder_.add_is_calibrated(is_calibrated);
  builder_.add_channels(channels);
  return builder_.Finish();
}

struct AudioCalibrationData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AudioCalibrationDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REFERENCE_FREQUENCY = 4,
    VT_MEASURED_FREQUENCY = 6,
    VT_CALIBRATION_OFFSET = 8,
    VT_SNR_IMPROVEMENT_DB = 10,
    VT_TIMESTAMP = 12
  };
  float reference_frequency() const {
    return GetField<float>(VT_REFERENCE_FREQUENCY, 440.0f);
  }
  float measured_frequency() const {
    return GetField<float>(VT_MEASURED_FREQUENCY, 0.0f);
  }
  float calibration_offset() const {
    return GetField<float>(VT_CALIBRATION_OFFSET, 0.0f);
  }
  float snr_improvement_db() const {
    return GetField<float>(VT_SNR_IMPROVEMENT_DB, 0.0f);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_REFERENCE_FREQUENCY, 4) &&
           VerifyField<float>(verifier, VT_MEASURED_FREQUENCY, 4) &&
           VerifyField<float>(verifier, VT_CALIBRATION_OFFSET, 4) &&
           VerifyField<float>(verifier, VT_SNR_IMPROVEMENT_DB, 4) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct AudioCalibrationDataBuilder {
  typedef AudioCalibrationData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reference_frequency(float reference_frequency) {
    fbb_.AddElement<float>(AudioCalibrationData::VT_REFERENCE_FREQUENCY, reference_frequency, 440.0f);
  }
  void add_measured_frequency(float measured_frequency) {
    fbb_.AddElement<float>(AudioCalibrationData::VT_MEASURED_FREQUENCY, measured_frequency, 0.0f);
  }
  void add_calibration_offset(float calibration_offset) {
    fbb_.AddElement<float>(AudioCalibrationData::VT_CALIBRATION_OFFSET, calibration_offset, 0.0f);
  }
  void add_snr_improvement_db(float snr_improvement_db) {
    fbb_.AddElement<float>(AudioCalibrationData::VT_SNR_IMPROVEMENT_DB, snr_improvement_db, 0.0f);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(AudioCalibrationData::VT_TIMESTAMP, timestamp, 0);
  }
  explicit AudioCalibrationDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AudioCalibrationData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioCalibrationData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AudioCalibrationData> CreateAudioCalibrationData(
    flatbuffers::FlatBufferBuilder &_fbb,
    float reference_frequency = 440.0f,
    float measured_frequency = 0.0f,
    float calibration_offset = 0.0f,
    float snr_improvement_db = 0.0f,
    uint64_t timestamp = 0) {
  AudioCalibrationDataBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_snr_improvement_db(snr_improvement_db);
  builder_.add_calibration_offset(calibration_offset);
  builder_.add_measured_frequency(measured_frequency);
  builder_.add_reference_frequency(reference_frequency);
  return builder_.Finish();
}

struct AudioDiagnostics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AudioDiagnosticsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PEAK_LEVEL_DB = 4,
    VT_RMS_LEVEL_DB = 6,
    VT_CLIPPING_COUNT = 8,
    VT_UNDERRUN_COUNT = 10,
    VT_SAMPLE_RATE_ACTUAL = 12,
    VT_BUFFER_UTILIZATION_PERCENT = 14,
    VT_FFT_COMPUTATION_TIME_US = 16
  };
  float peak_level_db() const {
    return GetField<float>(VT_PEAK_LEVEL_DB, 0.0f);
  }
  float rms_level_db() const {
    return GetField<float>(VT_RMS_LEVEL_DB, 0.0f);
  }
  uint32_t clipping_count() const {
    return GetField<uint32_t>(VT_CLIPPING_COUNT, 0);
  }
  uint32_t underrun_count() const {
    return GetField<uint32_t>(VT_UNDERRUN_COUNT, 0);
  }
  uint32_t sample_rate_actual() const {
    return GetField<uint32_t>(VT_SAMPLE_RATE_ACTUAL, 0);
  }
  uint8_t buffer_utilization_percent() const {
    return GetField<uint8_t>(VT_BUFFER_UTILIZATION_PERCENT, 0);
  }
  uint32_t fft_computation_time_us() const {
    return GetField<uint32_t>(VT_FFT_COMPUTATION_TIME_US, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_PEAK_LEVEL_DB, 4) &&
           VerifyField<float>(verifier, VT_RMS_LEVEL_DB, 4) &&
           VerifyField<uint32_t>(verifier, VT_CLIPPING_COUNT, 4) &&
           VerifyField<uint32_t>(verifier, VT_UNDERRUN_COUNT, 4) &&
           VerifyField<uint32_t>(verifier, VT_SAMPLE_RATE_ACTUAL, 4) &&
           VerifyField<uint8_t>(verifier, VT_BUFFER_UTILIZATION_PERCENT, 1) &&
           VerifyField<uint32_t>(verifier, VT_FFT_COMPUTATION_TIME_US, 4) &&
           verifier.EndTable();
  }
};

struct AudioDiagnosticsBuilder {
  typedef AudioDiagnostics Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peak_level_db(float peak_level_db) {
    fbb_.AddElement<float>(AudioDiagnostics::VT_PEAK_LEVEL_DB, peak_level_db, 0.0f);
  }
  void add_rms_level_db(float rms_level_db) {
    fbb_.AddElement<float>(AudioDiagnostics::VT_RMS_LEVEL_DB, rms_level_db, 0.0f);
  }
  void add_clipping_count(uint32_t clipping_count) {
    fbb_.AddElement<uint32_t>(AudioDiagnostics::VT_CLIPPING_COUNT, clipping_count, 0);
  }
  void add_underrun_count(uint32_t underrun_count) {
    fbb_.AddElement<uint32_t>(AudioDiagnostics::VT_UNDERRUN_COUNT, underrun_count, 0);
  }
  void add_sample_rate_actual(uint32_t sample_rate_actual) {
    fbb_.AddElement<uint32_t>(AudioDiagnostics::VT_SAMPLE_RATE_ACTUAL, sample_rate_actual, 0);
  }
  void add_buffer_utilization_percent(uint8_t buffer_utilization_percent) {
    fbb_.AddElement<uint8_t>(AudioDiagnostics::VT_BUFFER_UTILIZATION_PERCENT, buffer_utilization_percent, 0);
  }
  void add_fft_computation_time_us(uint32_t fft_computation_time_us) {
    fbb_.AddElement<uint32_t>(AudioDiagnostics::VT_FFT_COMPUTATION_TIME_US, fft_computation_time_us, 0);
  }
  explicit AudioDiagnosticsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AudioDiagnostics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioDiagnostics>(end);
    return o;
  }
};

inline flatbuffers::Offset<AudioDiagnostics> CreateAudioDiagnostics(
    flatbuffers::FlatBufferBuilder &_fbb,
    float peak_level_db = 0.0f,
    float rms_level_db = 0.0f,
    uint32_t clipping_count = 0,
    uint32_t underrun_count = 0,
    uint32_t sample_rate_actual = 0,
    uint8_t buffer_utilization_percent = 0,
    uint32_t fft_computation_time_us = 0) {
  AudioDiagnosticsBuilder builder_(_fbb);
  builder_.add_fft_computation_time_us(fft_computation_time_us);
  builder_.add_sample_rate_actual(sample_rate_actual);
  builder_.add_underrun_count(underrun_count);
  builder_.add_clipping_count(clipping_count);
  builder_.add_rms_level_db(rms_level_db);
  builder_.add_peak_level_db(peak_level_db);
  builder_.add_buffer_utilization_percent(buffer_utilization_percent);
  return builder_.Finish();
}

}  // namespace bpm
}  // namespace sparetools

#endif  // FLATBUFFERS_GENERATED_BPMAUDIO_SPARETOOLS_BPM_H_
