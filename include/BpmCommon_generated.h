// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BPMCOMMON_SPARETOOLS_BPM_H_
#define FLATBUFFERS_GENERATED_BPMCOMMON_SPARETOOLS_BPM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

namespace sparetools {
namespace bpm {

struct Header;
struct HeaderBuilder;

struct Status;
struct StatusBuilder;

enum DetectionStatus : int8_t {
  DetectionStatus_INITIALIZING = 0,
  DetectionStatus_DETECTING = 1,
  DetectionStatus_LOW_SIGNAL = 2,
  DetectionStatus_NO_SIGNAL = 3,
  DetectionStatus_ERROR = 4,
  DetectionStatus_CALIBRATING = 5,
  DetectionStatus_MIN = DetectionStatus_INITIALIZING,
  DetectionStatus_MAX = DetectionStatus_CALIBRATING
};

inline const DetectionStatus (&EnumValuesDetectionStatus())[6] {
  static const DetectionStatus values[] = {
    DetectionStatus_INITIALIZING,
    DetectionStatus_DETECTING,
    DetectionStatus_LOW_SIGNAL,
    DetectionStatus_NO_SIGNAL,
    DetectionStatus_ERROR,
    DetectionStatus_CALIBRATING
  };
  return values;
}

inline const char * const *EnumNamesDetectionStatus() {
  static const char * const names[7] = {
    "INITIALIZING",
    "DETECTING",
    "LOW_SIGNAL",
    "NO_SIGNAL",
    "ERROR",
    "CALIBRATING",
    nullptr
  };
  return names;
}

inline const char *EnumNameDetectionStatus(DetectionStatus e) {
  if (flatbuffers::IsOutRange(e, DetectionStatus_INITIALIZING, DetectionStatus_CALIBRATING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDetectionStatus()[index];
}

enum StatusEnum : int32_t {
  StatusEnum_Success = 0,
  StatusEnum_Error = 1,
  StatusEnum_Warning = 2,
  StatusEnum_Info = 3,
  StatusEnum_MIN = StatusEnum_Success,
  StatusEnum_MAX = StatusEnum_Info
};

inline const StatusEnum (&EnumValuesStatusEnum())[4] {
  static const StatusEnum values[] = {
    StatusEnum_Success,
    StatusEnum_Error,
    StatusEnum_Warning,
    StatusEnum_Info
  };
  return values;
}

inline const char * const *EnumNamesStatusEnum() {
  static const char * const names[5] = {
    "Success",
    "Error",
    "Warning",
    "Info",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatusEnum(StatusEnum e) {
  if (flatbuffers::IsOutRange(e, StatusEnum_Success, StatusEnum_Info)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatusEnum()[index];
}

enum RequestType : int8_t {
  RequestType_GET_STATUS = 0,
  RequestType_GET_CONFIG = 1,
  RequestType_SET_CONFIG = 2,
  RequestType_RESET_DEVICE = 3,
  RequestType_CALIBRATE_AUDIO = 4,
  RequestType_START_STREAMING = 5,
  RequestType_STOP_STREAMING = 6,
  RequestType_GET_DIAGNOSTICS = 7,
  RequestType_MIN = RequestType_GET_STATUS,
  RequestType_MAX = RequestType_GET_DIAGNOSTICS
};

inline const RequestType (&EnumValuesRequestType())[8] {
  static const RequestType values[] = {
    RequestType_GET_STATUS,
    RequestType_GET_CONFIG,
    RequestType_SET_CONFIG,
    RequestType_RESET_DEVICE,
    RequestType_CALIBRATE_AUDIO,
    RequestType_START_STREAMING,
    RequestType_STOP_STREAMING,
    RequestType_GET_DIAGNOSTICS
  };
  return values;
}

inline const char * const *EnumNamesRequestType() {
  static const char * const names[9] = {
    "GET_STATUS",
    "GET_CONFIG",
    "SET_CONFIG",
    "RESET_DEVICE",
    "CALIBRATE_AUDIO",
    "START_STREAMING",
    "STOP_STREAMING",
    "GET_DIAGNOSTICS",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestType(RequestType e) {
  if (flatbuffers::IsOutRange(e, RequestType_GET_STATUS, RequestType_GET_DIAGNOSTICS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestType()[index];
}

enum StreamType : int8_t {
  StreamType_WEBSOCKET = 0,
  StreamType_HTTP = 1,
  StreamType_MQTT = 2,
  StreamType_MIN = StreamType_WEBSOCKET,
  StreamType_MAX = StreamType_MQTT
};

inline const StreamType (&EnumValuesStreamType())[3] {
  static const StreamType values[] = {
    StreamType_WEBSOCKET,
    StreamType_HTTP,
    StreamType_MQTT
  };
  return values;
}

inline const char * const *EnumNamesStreamType() {
  static const char * const names[4] = {
    "WEBSOCKET",
    "HTTP",
    "MQTT",
    nullptr
  };
  return names;
}

inline const char *EnumNameStreamType(StreamType e) {
  if (flatbuffers::IsOutRange(e, StreamType_WEBSOCKET, StreamType_MQTT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStreamType()[index];
}

struct Header FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_TIMESTAMP = 6,
    VT_SEQUENCE_ID = 8
  };
  uint16_t version() const {
    return GetField<uint16_t>(VT_VERSION, 1);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  uint32_t sequence_id() const {
    return GetField<uint32_t>(VT_SEQUENCE_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_VERSION, 2) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyField<uint32_t>(verifier, VT_SEQUENCE_ID, 4) &&
           verifier.EndTable();
  }
};

struct HeaderBuilder {
  typedef Header Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint16_t version) {
    fbb_.AddElement<uint16_t>(Header::VT_VERSION, version, 1);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(Header::VT_TIMESTAMP, timestamp, 0);
  }
  void add_sequence_id(uint32_t sequence_id) {
    fbb_.AddElement<uint32_t>(Header::VT_SEQUENCE_ID, sequence_id, 0);
  }
  explicit HeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Header> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Header>(end);
    return o;
  }
};

inline flatbuffers::Offset<Header> CreateHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t version = 1,
    uint64_t timestamp = 0,
    uint32_t sequence_id = 0) {
  HeaderBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_sequence_id(sequence_id);
  builder_.add_version(version);
  return builder_.Finish();
}

struct Status FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_MESSAGE = 6
  };
  sparetools::bpm::StatusEnum status() const {
    return static_cast<sparetools::bpm::StatusEnum>(GetField<int32_t>(VT_STATUS, 0));
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STATUS, 4) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct StatusBuilder {
  typedef Status Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(sparetools::bpm::StatusEnum status) {
    fbb_.AddElement<int32_t>(Status::VT_STATUS, static_cast<int32_t>(status), 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Status::VT_MESSAGE, message);
  }
  explicit StatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Status> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Status>(end);
    return o;
  }
};

inline flatbuffers::Offset<Status> CreateStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    sparetools::bpm::StatusEnum status = sparetools::bpm::StatusEnum_Success,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  StatusBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<Status> CreateStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    sparetools::bpm::StatusEnum status = sparetools::bpm::StatusEnum_Success,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return sparetools::bpm::CreateStatus(
      _fbb,
      status,
      message__);
}

}  // namespace bpm
}  // namespace sparetools

#endif  // FLATBUFFERS_GENERATED_BPMCOMMON_SPARETOOLS_BPM_H_
