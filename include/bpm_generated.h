// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BPM_SPARETOOLS_BPM_H_
#define FLATBUFFERS_GENERATED_BPM_SPARETOOLS_BPM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace sparetools {
namespace bpm {

struct BPMData;
struct BPMDataBuilder;
struct BPMDataT;

struct BPMSettings;
struct BPMSettingsBuilder;
struct BPMSettingsT;

struct BPMHealth;
struct BPMHealthBuilder;
struct BPMHealthT;

struct BPMEnvelope;
struct BPMEnvelopeBuilder;
struct BPMEnvelopeT;

enum class BPMStatus : int8_t {
  DETECTING = 0,
  LOW_SIGNAL = 1,
  LOW_CONFIDENCE = 2,
  ERROR = 3,
  INITIALIZING = 4,
  BUFFERING = 5,
  MIN = DETECTING,
  MAX = BUFFERING
};

inline const BPMStatus (&EnumValuesBPMStatus())[6] {
  static const BPMStatus values[] = {
    BPMStatus::DETECTING,
    BPMStatus::LOW_SIGNAL,
    BPMStatus::LOW_CONFIDENCE,
    BPMStatus::ERROR,
    BPMStatus::INITIALIZING,
    BPMStatus::BUFFERING
  };
  return values;
}

inline const char * const *EnumNamesBPMStatus() {
  static const char * const names[7] = {
    "DETECTING",
    "LOW_SIGNAL",
    "LOW_CONFIDENCE",
    "ERROR",
    "INITIALIZING",
    "BUFFERING",
    nullptr
  };
  return names;
}

inline const char *EnumNameBPMStatus(BPMStatus e) {
  if (::flatbuffers::IsOutRange(e, BPMStatus::DETECTING, BPMStatus::BUFFERING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBPMStatus()[index];
}

enum class BPMMessage : uint8_t {
  NONE = 0,
  BPMData = 1,
  BPMSettings = 2,
  BPMHealth = 3,
  MIN = NONE,
  MAX = BPMHealth
};

inline const BPMMessage (&EnumValuesBPMMessage())[4] {
  static const BPMMessage values[] = {
    BPMMessage::NONE,
    BPMMessage::BPMData,
    BPMMessage::BPMSettings,
    BPMMessage::BPMHealth
  };
  return values;
}

inline const char * const *EnumNamesBPMMessage() {
  static const char * const names[5] = {
    "NONE",
    "BPMData",
    "BPMSettings",
    "BPMHealth",
    nullptr
  };
  return names;
}

inline const char *EnumNameBPMMessage(BPMMessage e) {
  if (::flatbuffers::IsOutRange(e, BPMMessage::NONE, BPMMessage::BPMHealth)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBPMMessage()[index];
}

template<typename T> struct BPMMessageTraits {
  static const BPMMessage enum_value = BPMMessage::NONE;
};

template<> struct BPMMessageTraits<sparetools::bpm::BPMData> {
  static const BPMMessage enum_value = BPMMessage::BPMData;
};

template<> struct BPMMessageTraits<sparetools::bpm::BPMSettings> {
  static const BPMMessage enum_value = BPMMessage::BPMSettings;
};

template<> struct BPMMessageTraits<sparetools::bpm::BPMHealth> {
  static const BPMMessage enum_value = BPMMessage::BPMHealth;
};

template<typename T> struct BPMMessageUnionTraits {
  static const BPMMessage enum_value = BPMMessage::NONE;
};

template<> struct BPMMessageUnionTraits<sparetools::bpm::BPMDataT> {
  static const BPMMessage enum_value = BPMMessage::BPMData;
};

template<> struct BPMMessageUnionTraits<sparetools::bpm::BPMSettingsT> {
  static const BPMMessage enum_value = BPMMessage::BPMSettings;
};

template<> struct BPMMessageUnionTraits<sparetools::bpm::BPMHealthT> {
  static const BPMMessage enum_value = BPMMessage::BPMHealth;
};

struct BPMMessageUnion {
  BPMMessage type;
  void *value;

  BPMMessageUnion() : type(BPMMessage::NONE), value(nullptr) {}
  BPMMessageUnion(BPMMessageUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(BPMMessage::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  BPMMessageUnion(const BPMMessageUnion &);
  BPMMessageUnion &operator=(const BPMMessageUnion &u)
    { BPMMessageUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  BPMMessageUnion &operator=(BPMMessageUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~BPMMessageUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = BPMMessageUnionTraits<RT>::enum_value;
    if (type != BPMMessage::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, BPMMessage type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  sparetools::bpm::BPMDataT *AsBPMData() {
    return type == BPMMessage::BPMData ?
      reinterpret_cast<sparetools::bpm::BPMDataT *>(value) : nullptr;
  }
  const sparetools::bpm::BPMDataT *AsBPMData() const {
    return type == BPMMessage::BPMData ?
      reinterpret_cast<const sparetools::bpm::BPMDataT *>(value) : nullptr;
  }
  sparetools::bpm::BPMSettingsT *AsBPMSettings() {
    return type == BPMMessage::BPMSettings ?
      reinterpret_cast<sparetools::bpm::BPMSettingsT *>(value) : nullptr;
  }
  const sparetools::bpm::BPMSettingsT *AsBPMSettings() const {
    return type == BPMMessage::BPMSettings ?
      reinterpret_cast<const sparetools::bpm::BPMSettingsT *>(value) : nullptr;
  }
  sparetools::bpm::BPMHealthT *AsBPMHealth() {
    return type == BPMMessage::BPMHealth ?
      reinterpret_cast<sparetools::bpm::BPMHealthT *>(value) : nullptr;
  }
  const sparetools::bpm::BPMHealthT *AsBPMHealth() const {
    return type == BPMMessage::BPMHealth ?
      reinterpret_cast<const sparetools::bpm::BPMHealthT *>(value) : nullptr;
  }
};

bool VerifyBPMMessage(::flatbuffers::Verifier &verifier, const void *obj, BPMMessage type);
bool VerifyBPMMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<BPMMessage> *types);

struct BPMDataT : public ::flatbuffers::NativeTable {
  typedef BPMData TableType;
  float bpm = 0.0f;
  float confidence = 0.0f;
  float signal_level = 0.0f;
  std::string status{};
  uint64_t timestamp = 0;
};

struct BPMData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BPMDataT NativeTableType;
  typedef BPMDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BPM = 4,
    VT_CONFIDENCE = 6,
    VT_SIGNAL_LEVEL = 8,
    VT_STATUS = 10,
    VT_TIMESTAMP = 12
  };
  float bpm() const {
    return GetField<float>(VT_BPM, 0.0f);
  }
  bool mutate_bpm(float _bpm = 0.0f) {
    return SetField<float>(VT_BPM, _bpm, 0.0f);
  }
  float confidence() const {
    return GetField<float>(VT_CONFIDENCE, 0.0f);
  }
  bool mutate_confidence(float _confidence = 0.0f) {
    return SetField<float>(VT_CONFIDENCE, _confidence, 0.0f);
  }
  float signal_level() const {
    return GetField<float>(VT_SIGNAL_LEVEL, 0.0f);
  }
  bool mutate_signal_level(float _signal_level = 0.0f) {
    return SetField<float>(VT_SIGNAL_LEVEL, _signal_level, 0.0f);
  }
  const ::flatbuffers::String *status() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATUS);
  }
  ::flatbuffers::String *mutable_status() {
    return GetPointer<::flatbuffers::String *>(VT_STATUS);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(uint64_t _timestamp = 0) {
    return SetField<uint64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BPM, 4) &&
           VerifyField<float>(verifier, VT_CONFIDENCE, 4) &&
           VerifyField<float>(verifier, VT_SIGNAL_LEVEL, 4) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyString(status()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
  BPMDataT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BPMDataT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BPMData> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BPMDataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BPMDataBuilder {
  typedef BPMData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_bpm(float bpm) {
    fbb_.AddElement<float>(BPMData::VT_BPM, bpm, 0.0f);
  }
  void add_confidence(float confidence) {
    fbb_.AddElement<float>(BPMData::VT_CONFIDENCE, confidence, 0.0f);
  }
  void add_signal_level(float signal_level) {
    fbb_.AddElement<float>(BPMData::VT_SIGNAL_LEVEL, signal_level, 0.0f);
  }
  void add_status(::flatbuffers::Offset<::flatbuffers::String> status) {
    fbb_.AddOffset(BPMData::VT_STATUS, status);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(BPMData::VT_TIMESTAMP, timestamp, 0);
  }
  explicit BPMDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BPMData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BPMData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BPMData> CreateBPMData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float bpm = 0.0f,
    float confidence = 0.0f,
    float signal_level = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> status = 0,
    uint64_t timestamp = 0) {
  BPMDataBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_status(status);
  builder_.add_signal_level(signal_level);
  builder_.add_confidence(confidence);
  builder_.add_bpm(bpm);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BPMData> CreateBPMDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float bpm = 0.0f,
    float confidence = 0.0f,
    float signal_level = 0.0f,
    const char *status = nullptr,
    uint64_t timestamp = 0) {
  auto status__ = status ? _fbb.CreateString(status) : 0;
  return sparetools::bpm::CreateBPMData(
      _fbb,
      bpm,
      confidence,
      signal_level,
      status__,
      timestamp);
}

::flatbuffers::Offset<BPMData> CreateBPMData(::flatbuffers::FlatBufferBuilder &_fbb, const BPMDataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BPMSettingsT : public ::flatbuffers::NativeTable {
  typedef BPMSettings TableType;
  int32_t min_bpm = 0;
  int32_t max_bpm = 0;
  int32_t sample_rate = 0;
  int32_t fft_size = 0;
  std::string version{};
};

struct BPMSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BPMSettingsT NativeTableType;
  typedef BPMSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_BPM = 4,
    VT_MAX_BPM = 6,
    VT_SAMPLE_RATE = 8,
    VT_FFT_SIZE = 10,
    VT_VERSION = 12
  };
  int32_t min_bpm() const {
    return GetField<int32_t>(VT_MIN_BPM, 0);
  }
  bool mutate_min_bpm(int32_t _min_bpm = 0) {
    return SetField<int32_t>(VT_MIN_BPM, _min_bpm, 0);
  }
  int32_t max_bpm() const {
    return GetField<int32_t>(VT_MAX_BPM, 0);
  }
  bool mutate_max_bpm(int32_t _max_bpm = 0) {
    return SetField<int32_t>(VT_MAX_BPM, _max_bpm, 0);
  }
  int32_t sample_rate() const {
    return GetField<int32_t>(VT_SAMPLE_RATE, 0);
  }
  bool mutate_sample_rate(int32_t _sample_rate = 0) {
    return SetField<int32_t>(VT_SAMPLE_RATE, _sample_rate, 0);
  }
  int32_t fft_size() const {
    return GetField<int32_t>(VT_FFT_SIZE, 0);
  }
  bool mutate_fft_size(int32_t _fft_size = 0) {
    return SetField<int32_t>(VT_FFT_SIZE, _fft_size, 0);
  }
  const ::flatbuffers::String *version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  ::flatbuffers::String *mutable_version() {
    return GetPointer<::flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MIN_BPM, 4) &&
           VerifyField<int32_t>(verifier, VT_MAX_BPM, 4) &&
           VerifyField<int32_t>(verifier, VT_SAMPLE_RATE, 4) &&
           VerifyField<int32_t>(verifier, VT_FFT_SIZE, 4) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           verifier.EndTable();
  }
  BPMSettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BPMSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BPMSettings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BPMSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BPMSettingsBuilder {
  typedef BPMSettings Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min_bpm(int32_t min_bpm) {
    fbb_.AddElement<int32_t>(BPMSettings::VT_MIN_BPM, min_bpm, 0);
  }
  void add_max_bpm(int32_t max_bpm) {
    fbb_.AddElement<int32_t>(BPMSettings::VT_MAX_BPM, max_bpm, 0);
  }
  void add_sample_rate(int32_t sample_rate) {
    fbb_.AddElement<int32_t>(BPMSettings::VT_SAMPLE_RATE, sample_rate, 0);
  }
  void add_fft_size(int32_t fft_size) {
    fbb_.AddElement<int32_t>(BPMSettings::VT_FFT_SIZE, fft_size, 0);
  }
  void add_version(::flatbuffers::Offset<::flatbuffers::String> version) {
    fbb_.AddOffset(BPMSettings::VT_VERSION, version);
  }
  explicit BPMSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BPMSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BPMSettings>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BPMSettings> CreateBPMSettings(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t min_bpm = 0,
    int32_t max_bpm = 0,
    int32_t sample_rate = 0,
    int32_t fft_size = 0,
    ::flatbuffers::Offset<::flatbuffers::String> version = 0) {
  BPMSettingsBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_fft_size(fft_size);
  builder_.add_sample_rate(sample_rate);
  builder_.add_max_bpm(max_bpm);
  builder_.add_min_bpm(min_bpm);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BPMSettings> CreateBPMSettingsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t min_bpm = 0,
    int32_t max_bpm = 0,
    int32_t sample_rate = 0,
    int32_t fft_size = 0,
    const char *version = nullptr) {
  auto version__ = version ? _fbb.CreateString(version) : 0;
  return sparetools::bpm::CreateBPMSettings(
      _fbb,
      min_bpm,
      max_bpm,
      sample_rate,
      fft_size,
      version__);
}

::flatbuffers::Offset<BPMSettings> CreateBPMSettings(::flatbuffers::FlatBufferBuilder &_fbb, const BPMSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BPMHealthT : public ::flatbuffers::NativeTable {
  typedef BPMHealth TableType;
  std::string status{};
  uint64_t uptime = 0;
  uint64_t heap_free = 0;
};

struct BPMHealth FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BPMHealthT NativeTableType;
  typedef BPMHealthBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_UPTIME = 6,
    VT_HEAP_FREE = 8
  };
  const ::flatbuffers::String *status() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATUS);
  }
  ::flatbuffers::String *mutable_status() {
    return GetPointer<::flatbuffers::String *>(VT_STATUS);
  }
  uint64_t uptime() const {
    return GetField<uint64_t>(VT_UPTIME, 0);
  }
  bool mutate_uptime(uint64_t _uptime = 0) {
    return SetField<uint64_t>(VT_UPTIME, _uptime, 0);
  }
  uint64_t heap_free() const {
    return GetField<uint64_t>(VT_HEAP_FREE, 0);
  }
  bool mutate_heap_free(uint64_t _heap_free = 0) {
    return SetField<uint64_t>(VT_HEAP_FREE, _heap_free, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyString(status()) &&
           VerifyField<uint64_t>(verifier, VT_UPTIME, 8) &&
           VerifyField<uint64_t>(verifier, VT_HEAP_FREE, 8) &&
           verifier.EndTable();
  }
  BPMHealthT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BPMHealthT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BPMHealth> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BPMHealthT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BPMHealthBuilder {
  typedef BPMHealth Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_status(::flatbuffers::Offset<::flatbuffers::String> status) {
    fbb_.AddOffset(BPMHealth::VT_STATUS, status);
  }
  void add_uptime(uint64_t uptime) {
    fbb_.AddElement<uint64_t>(BPMHealth::VT_UPTIME, uptime, 0);
  }
  void add_heap_free(uint64_t heap_free) {
    fbb_.AddElement<uint64_t>(BPMHealth::VT_HEAP_FREE, heap_free, 0);
  }
  explicit BPMHealthBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BPMHealth> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BPMHealth>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BPMHealth> CreateBPMHealth(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> status = 0,
    uint64_t uptime = 0,
    uint64_t heap_free = 0) {
  BPMHealthBuilder builder_(_fbb);
  builder_.add_heap_free(heap_free);
  builder_.add_uptime(uptime);
  builder_.add_status(status);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BPMHealth> CreateBPMHealthDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *status = nullptr,
    uint64_t uptime = 0,
    uint64_t heap_free = 0) {
  auto status__ = status ? _fbb.CreateString(status) : 0;
  return sparetools::bpm::CreateBPMHealth(
      _fbb,
      status__,
      uptime,
      heap_free);
}

::flatbuffers::Offset<BPMHealth> CreateBPMHealth(::flatbuffers::FlatBufferBuilder &_fbb, const BPMHealthT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BPMEnvelopeT : public ::flatbuffers::NativeTable {
  typedef BPMEnvelope TableType;
  sparetools::bpm::BPMMessageUnion message_type{};
  uint64_t message_id = 0;
  std::string source{};
};

struct BPMEnvelope FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BPMEnvelopeT NativeTableType;
  typedef BPMEnvelopeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE_TYPE = 4,
    VT_MESSAGE_TYPE = 6,
    VT_MESSAGE_ID = 8,
    VT_SOURCE = 10
  };
  sparetools::bpm::BPMMessage message_type_type() const {
    return static_cast<sparetools::bpm::BPMMessage>(GetField<uint8_t>(VT_MESSAGE_TYPE_TYPE, 0));
  }
  const void *message_type() const {
    return GetPointer<const void *>(VT_MESSAGE_TYPE);
  }
  template<typename T> const T *message_type_as() const;
  const sparetools::bpm::BPMData *message_type_as_BPMData() const {
    return message_type_type() == sparetools::bpm::BPMMessage::BPMData ? static_cast<const sparetools::bpm::BPMData *>(message_type()) : nullptr;
  }
  const sparetools::bpm::BPMSettings *message_type_as_BPMSettings() const {
    return message_type_type() == sparetools::bpm::BPMMessage::BPMSettings ? static_cast<const sparetools::bpm::BPMSettings *>(message_type()) : nullptr;
  }
  const sparetools::bpm::BPMHealth *message_type_as_BPMHealth() const {
    return message_type_type() == sparetools::bpm::BPMMessage::BPMHealth ? static_cast<const sparetools::bpm::BPMHealth *>(message_type()) : nullptr;
  }
  void *mutable_message_type() {
    return GetPointer<void *>(VT_MESSAGE_TYPE);
  }
  uint64_t message_id() const {
    return GetField<uint64_t>(VT_MESSAGE_ID, 0);
  }
  bool mutate_message_id(uint64_t _message_id = 0) {
    return SetField<uint64_t>(VT_MESSAGE_ID, _message_id, 0);
  }
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  ::flatbuffers::String *mutable_source() {
    return GetPointer<::flatbuffers::String *>(VT_SOURCE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MESSAGE_TYPE) &&
           VerifyBPMMessage(verifier, message_type(), message_type_type()) &&
           VerifyField<uint64_t>(verifier, VT_MESSAGE_ID, 8) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           verifier.EndTable();
  }
  BPMEnvelopeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BPMEnvelopeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BPMEnvelope> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BPMEnvelopeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const sparetools::bpm::BPMData *BPMEnvelope::message_type_as<sparetools::bpm::BPMData>() const {
  return message_type_as_BPMData();
}

template<> inline const sparetools::bpm::BPMSettings *BPMEnvelope::message_type_as<sparetools::bpm::BPMSettings>() const {
  return message_type_as_BPMSettings();
}

template<> inline const sparetools::bpm::BPMHealth *BPMEnvelope::message_type_as<sparetools::bpm::BPMHealth>() const {
  return message_type_as_BPMHealth();
}

struct BPMEnvelopeBuilder {
  typedef BPMEnvelope Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message_type_type(sparetools::bpm::BPMMessage message_type_type) {
    fbb_.AddElement<uint8_t>(BPMEnvelope::VT_MESSAGE_TYPE_TYPE, static_cast<uint8_t>(message_type_type), 0);
  }
  void add_message_type(::flatbuffers::Offset<void> message_type) {
    fbb_.AddOffset(BPMEnvelope::VT_MESSAGE_TYPE, message_type);
  }
  void add_message_id(uint64_t message_id) {
    fbb_.AddElement<uint64_t>(BPMEnvelope::VT_MESSAGE_ID, message_id, 0);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(BPMEnvelope::VT_SOURCE, source);
  }
  explicit BPMEnvelopeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BPMEnvelope> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BPMEnvelope>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BPMEnvelope> CreateBPMEnvelope(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    sparetools::bpm::BPMMessage message_type_type = sparetools::bpm::BPMMessage::NONE,
    ::flatbuffers::Offset<void> message_type = 0,
    uint64_t message_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0) {
  BPMEnvelopeBuilder builder_(_fbb);
  builder_.add_message_id(message_id);
  builder_.add_source(source);
  builder_.add_message_type(message_type);
  builder_.add_message_type_type(message_type_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BPMEnvelope> CreateBPMEnvelopeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    sparetools::bpm::BPMMessage message_type_type = sparetools::bpm::BPMMessage::NONE,
    ::flatbuffers::Offset<void> message_type = 0,
    uint64_t message_id = 0,
    const char *source = nullptr) {
  auto source__ = source ? _fbb.CreateString(source) : 0;
  return sparetools::bpm::CreateBPMEnvelope(
      _fbb,
      message_type_type,
      message_type,
      message_id,
      source__);
}

::flatbuffers::Offset<BPMEnvelope> CreateBPMEnvelope(::flatbuffers::FlatBufferBuilder &_fbb, const BPMEnvelopeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline BPMDataT *BPMData::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BPMDataT>(new BPMDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BPMData::UnPackTo(BPMDataT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = bpm(); _o->bpm = _e; }
  { auto _e = confidence(); _o->confidence = _e; }
  { auto _e = signal_level(); _o->signal_level = _e; }
  { auto _e = status(); if (_e) _o->status = _e->str(); }
  { auto _e = timestamp(); _o->timestamp = _e; }
}

inline ::flatbuffers::Offset<BPMData> BPMData::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BPMDataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBPMData(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BPMData> CreateBPMData(::flatbuffers::FlatBufferBuilder &_fbb, const BPMDataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BPMDataT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _bpm = _o->bpm;
  auto _confidence = _o->confidence;
  auto _signal_level = _o->signal_level;
  auto _status = _o->status.empty() ? 0 : _fbb.CreateString(_o->status);
  auto _timestamp = _o->timestamp;
  return sparetools::bpm::CreateBPMData(
      _fbb,
      _bpm,
      _confidence,
      _signal_level,
      _status,
      _timestamp);
}

inline BPMSettingsT *BPMSettings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BPMSettingsT>(new BPMSettingsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BPMSettings::UnPackTo(BPMSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = min_bpm(); _o->min_bpm = _e; }
  { auto _e = max_bpm(); _o->max_bpm = _e; }
  { auto _e = sample_rate(); _o->sample_rate = _e; }
  { auto _e = fft_size(); _o->fft_size = _e; }
  { auto _e = version(); if (_e) _o->version = _e->str(); }
}

inline ::flatbuffers::Offset<BPMSettings> BPMSettings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BPMSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBPMSettings(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BPMSettings> CreateBPMSettings(::flatbuffers::FlatBufferBuilder &_fbb, const BPMSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BPMSettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _min_bpm = _o->min_bpm;
  auto _max_bpm = _o->max_bpm;
  auto _sample_rate = _o->sample_rate;
  auto _fft_size = _o->fft_size;
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return sparetools::bpm::CreateBPMSettings(
      _fbb,
      _min_bpm,
      _max_bpm,
      _sample_rate,
      _fft_size,
      _version);
}

inline BPMHealthT *BPMHealth::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BPMHealthT>(new BPMHealthT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BPMHealth::UnPackTo(BPMHealthT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = status(); if (_e) _o->status = _e->str(); }
  { auto _e = uptime(); _o->uptime = _e; }
  { auto _e = heap_free(); _o->heap_free = _e; }
}

inline ::flatbuffers::Offset<BPMHealth> BPMHealth::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BPMHealthT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBPMHealth(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BPMHealth> CreateBPMHealth(::flatbuffers::FlatBufferBuilder &_fbb, const BPMHealthT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BPMHealthT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _status = _o->status.empty() ? 0 : _fbb.CreateString(_o->status);
  auto _uptime = _o->uptime;
  auto _heap_free = _o->heap_free;
  return sparetools::bpm::CreateBPMHealth(
      _fbb,
      _status,
      _uptime,
      _heap_free);
}

inline BPMEnvelopeT *BPMEnvelope::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BPMEnvelopeT>(new BPMEnvelopeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BPMEnvelope::UnPackTo(BPMEnvelopeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = message_type_type(); _o->message_type.type = _e; }
  { auto _e = message_type(); if (_e) _o->message_type.value = sparetools::bpm::BPMMessageUnion::UnPack(_e, message_type_type(), _resolver); }
  { auto _e = message_id(); _o->message_id = _e; }
  { auto _e = source(); if (_e) _o->source = _e->str(); }
}

inline ::flatbuffers::Offset<BPMEnvelope> BPMEnvelope::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BPMEnvelopeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBPMEnvelope(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BPMEnvelope> CreateBPMEnvelope(::flatbuffers::FlatBufferBuilder &_fbb, const BPMEnvelopeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BPMEnvelopeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _message_type_type = _o->message_type.type;
  auto _message_type = _o->message_type.Pack(_fbb);
  auto _message_id = _o->message_id;
  auto _source = _o->source.empty() ? 0 : _fbb.CreateString(_o->source);
  return sparetools::bpm::CreateBPMEnvelope(
      _fbb,
      _message_type_type,
      _message_type,
      _message_id,
      _source);
}

inline bool VerifyBPMMessage(::flatbuffers::Verifier &verifier, const void *obj, BPMMessage type) {
  switch (type) {
    case BPMMessage::NONE: {
      return true;
    }
    case BPMMessage::BPMData: {
      auto ptr = reinterpret_cast<const sparetools::bpm::BPMData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BPMMessage::BPMSettings: {
      auto ptr = reinterpret_cast<const sparetools::bpm::BPMSettings *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BPMMessage::BPMHealth: {
      auto ptr = reinterpret_cast<const sparetools::bpm::BPMHealth *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyBPMMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<BPMMessage> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBPMMessage(
        verifier,  values->Get(i), types->GetEnum<BPMMessage>(i))) {
      return false;
    }
  }
  return true;
}

inline void *BPMMessageUnion::UnPack(const void *obj, BPMMessage type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case BPMMessage::BPMData: {
      auto ptr = reinterpret_cast<const sparetools::bpm::BPMData *>(obj);
      return ptr->UnPack(resolver);
    }
    case BPMMessage::BPMSettings: {
      auto ptr = reinterpret_cast<const sparetools::bpm::BPMSettings *>(obj);
      return ptr->UnPack(resolver);
    }
    case BPMMessage::BPMHealth: {
      auto ptr = reinterpret_cast<const sparetools::bpm::BPMHealth *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> BPMMessageUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case BPMMessage::BPMData: {
      auto ptr = reinterpret_cast<const sparetools::bpm::BPMDataT *>(value);
      return CreateBPMData(_fbb, ptr, _rehasher).Union();
    }
    case BPMMessage::BPMSettings: {
      auto ptr = reinterpret_cast<const sparetools::bpm::BPMSettingsT *>(value);
      return CreateBPMSettings(_fbb, ptr, _rehasher).Union();
    }
    case BPMMessage::BPMHealth: {
      auto ptr = reinterpret_cast<const sparetools::bpm::BPMHealthT *>(value);
      return CreateBPMHealth(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline BPMMessageUnion::BPMMessageUnion(const BPMMessageUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case BPMMessage::BPMData: {
      value = new sparetools::bpm::BPMDataT(*reinterpret_cast<sparetools::bpm::BPMDataT *>(u.value));
      break;
    }
    case BPMMessage::BPMSettings: {
      value = new sparetools::bpm::BPMSettingsT(*reinterpret_cast<sparetools::bpm::BPMSettingsT *>(u.value));
      break;
    }
    case BPMMessage::BPMHealth: {
      value = new sparetools::bpm::BPMHealthT(*reinterpret_cast<sparetools::bpm::BPMHealthT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void BPMMessageUnion::Reset() {
  switch (type) {
    case BPMMessage::BPMData: {
      auto ptr = reinterpret_cast<sparetools::bpm::BPMDataT *>(value);
      delete ptr;
      break;
    }
    case BPMMessage::BPMSettings: {
      auto ptr = reinterpret_cast<sparetools::bpm::BPMSettingsT *>(value);
      delete ptr;
      break;
    }
    case BPMMessage::BPMHealth: {
      auto ptr = reinterpret_cast<sparetools::bpm::BPMHealthT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = BPMMessage::NONE;
}

inline const sparetools::bpm::BPMEnvelope *GetBPMEnvelope(const void *buf) {
  return ::flatbuffers::GetRoot<sparetools::bpm::BPMEnvelope>(buf);
}

inline const sparetools::bpm::BPMEnvelope *GetSizePrefixedBPMEnvelope(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<sparetools::bpm::BPMEnvelope>(buf);
}

inline BPMEnvelope *GetMutableBPMEnvelope(void *buf) {
  return ::flatbuffers::GetMutableRoot<BPMEnvelope>(buf);
}

inline sparetools::bpm::BPMEnvelope *GetMutableSizePrefixedBPMEnvelope(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<sparetools::bpm::BPMEnvelope>(buf);
}

inline bool VerifyBPMEnvelopeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<sparetools::bpm::BPMEnvelope>(nullptr);
}

inline bool VerifySizePrefixedBPMEnvelopeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<sparetools::bpm::BPMEnvelope>(nullptr);
}

inline void FinishBPMEnvelopeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<sparetools::bpm::BPMEnvelope> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBPMEnvelopeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<sparetools::bpm::BPMEnvelope> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<sparetools::bpm::BPMEnvelopeT> UnPackBPMEnvelope(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<sparetools::bpm::BPMEnvelopeT>(GetBPMEnvelope(buf)->UnPack(res));
}

inline std::unique_ptr<sparetools::bpm::BPMEnvelopeT> UnPackSizePrefixedBPMEnvelope(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<sparetools::bpm::BPMEnvelopeT>(GetSizePrefixedBPMEnvelope(buf)->UnPack(res));
}

}  // namespace bpm
}  // namespace sparetools

#endif  // FLATBUFFERS_GENERATED_BPM_SPARETOOLS_BPM_H_
