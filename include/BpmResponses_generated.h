// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BPMRESPONSES_SPARETOOLS_BPM_H_
#define FLATBUFFERS_GENERATED_BPMRESPONSES_SPARETOOLS_BPM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

#include "BpmAudio_generated.h"
#include "BpmCommon_generated.h"
#include "BpmConfig_generated.h"
#include "BpmCore_generated.h"
#include "BpmSystem_generated.h"

namespace sparetools {
namespace bpm {

struct GetStatusResponse;
struct GetStatusResponseBuilder;

struct GetConfigResponse;
struct GetConfigResponseBuilder;

struct SetConfigResponse;
struct SetConfigResponseBuilder;

struct ResetDeviceResponse;
struct ResetDeviceResponseBuilder;

struct CalibrateAudioResponse;
struct CalibrateAudioResponseBuilder;

struct StartStreamingResponse;
struct StartStreamingResponseBuilder;

struct StopStreamingResponse;
struct StopStreamingResponseBuilder;

struct GetDiagnosticsResponse;
struct GetDiagnosticsResponseBuilder;

struct Response;
struct ResponseBuilder;

enum ResponsePayload : uint8_t {
  ResponsePayload_NONE = 0,
  ResponsePayload_GetStatusResponse = 1,
  ResponsePayload_GetConfigResponse = 2,
  ResponsePayload_SetConfigResponse = 3,
  ResponsePayload_ResetDeviceResponse = 4,
  ResponsePayload_CalibrateAudioResponse = 5,
  ResponsePayload_StartStreamingResponse = 6,
  ResponsePayload_StopStreamingResponse = 7,
  ResponsePayload_GetDiagnosticsResponse = 8,
  ResponsePayload_MIN = ResponsePayload_NONE,
  ResponsePayload_MAX = ResponsePayload_GetDiagnosticsResponse
};

inline const ResponsePayload (&EnumValuesResponsePayload())[9] {
  static const ResponsePayload values[] = {
    ResponsePayload_NONE,
    ResponsePayload_GetStatusResponse,
    ResponsePayload_GetConfigResponse,
    ResponsePayload_SetConfigResponse,
    ResponsePayload_ResetDeviceResponse,
    ResponsePayload_CalibrateAudioResponse,
    ResponsePayload_StartStreamingResponse,
    ResponsePayload_StopStreamingResponse,
    ResponsePayload_GetDiagnosticsResponse
  };
  return values;
}

inline const char * const *EnumNamesResponsePayload() {
  static const char * const names[10] = {
    "NONE",
    "GetStatusResponse",
    "GetConfigResponse",
    "SetConfigResponse",
    "ResetDeviceResponse",
    "CalibrateAudioResponse",
    "StartStreamingResponse",
    "StopStreamingResponse",
    "GetDiagnosticsResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameResponsePayload(ResponsePayload e) {
  if (flatbuffers::IsOutRange(e, ResponsePayload_NONE, ResponsePayload_GetDiagnosticsResponse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResponsePayload()[index];
}

template<typename T> struct ResponsePayloadTraits {
  static const ResponsePayload enum_value = ResponsePayload_NONE;
};

template<> struct ResponsePayloadTraits<sparetools::bpm::GetStatusResponse> {
  static const ResponsePayload enum_value = ResponsePayload_GetStatusResponse;
};

template<> struct ResponsePayloadTraits<sparetools::bpm::GetConfigResponse> {
  static const ResponsePayload enum_value = ResponsePayload_GetConfigResponse;
};

template<> struct ResponsePayloadTraits<sparetools::bpm::SetConfigResponse> {
  static const ResponsePayload enum_value = ResponsePayload_SetConfigResponse;
};

template<> struct ResponsePayloadTraits<sparetools::bpm::ResetDeviceResponse> {
  static const ResponsePayload enum_value = ResponsePayload_ResetDeviceResponse;
};

template<> struct ResponsePayloadTraits<sparetools::bpm::CalibrateAudioResponse> {
  static const ResponsePayload enum_value = ResponsePayload_CalibrateAudioResponse;
};

template<> struct ResponsePayloadTraits<sparetools::bpm::StartStreamingResponse> {
  static const ResponsePayload enum_value = ResponsePayload_StartStreamingResponse;
};

template<> struct ResponsePayloadTraits<sparetools::bpm::StopStreamingResponse> {
  static const ResponsePayload enum_value = ResponsePayload_StopStreamingResponse;
};

template<> struct ResponsePayloadTraits<sparetools::bpm::GetDiagnosticsResponse> {
  static const ResponsePayload enum_value = ResponsePayload_GetDiagnosticsResponse;
};

bool VerifyResponsePayload(flatbuffers::Verifier &verifier, const void *obj, ResponsePayload type);
bool VerifyResponsePayloadVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct GetStatusResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetStatusResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4
  };
  const sparetools::bpm::StatusUpdate *status() const {
    return GetPointer<const sparetools::bpm::StatusUpdate *>(VT_STATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           verifier.EndTable();
  }
};

struct GetStatusResponseBuilder {
  typedef GetStatusResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(flatbuffers::Offset<sparetools::bpm::StatusUpdate> status) {
    fbb_.AddOffset(GetStatusResponse::VT_STATUS, status);
  }
  explicit GetStatusResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GetStatusResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetStatusResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetStatusResponse> CreateGetStatusResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<sparetools::bpm::StatusUpdate> status = 0) {
  GetStatusResponseBuilder builder_(_fbb);
  builder_.add_status(status);
  return builder_.Finish();
}

struct GetConfigResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetConfigResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONFIG = 4
  };
  const sparetools::bpm::ConfigUpdate *config() const {
    return GetPointer<const sparetools::bpm::ConfigUpdate *>(VT_CONFIG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           verifier.VerifyTable(config()) &&
           verifier.EndTable();
  }
};

struct GetConfigResponseBuilder {
  typedef GetConfigResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_config(flatbuffers::Offset<sparetools::bpm::ConfigUpdate> config) {
    fbb_.AddOffset(GetConfigResponse::VT_CONFIG, config);
  }
  explicit GetConfigResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GetConfigResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetConfigResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetConfigResponse> CreateGetConfigResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<sparetools::bpm::ConfigUpdate> config = 0) {
  GetConfigResponseBuilder builder_(_fbb);
  builder_.add_config(config);
  return builder_.Finish();
}

struct SetConfigResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SetConfigResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4,
    VT_MESSAGE = 6
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct SetConfigResponseBuilder {
  typedef SetConfigResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(SetConfigResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(SetConfigResponse::VT_MESSAGE, message);
  }
  explicit SetConfigResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SetConfigResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetConfigResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetConfigResponse> CreateSetConfigResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  SetConfigResponseBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_success(success);
  return builder_.Finish();
}

inline flatbuffers::Offset<SetConfigResponse> CreateSetConfigResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return sparetools::bpm::CreateSetConfigResponse(
      _fbb,
      success,
      message__);
}

struct ResetDeviceResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResetDeviceResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACKNOWLEDGED = 4
  };
  bool acknowledged() const {
    return GetField<uint8_t>(VT_ACKNOWLEDGED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ACKNOWLEDGED, 1) &&
           verifier.EndTable();
  }
};

struct ResetDeviceResponseBuilder {
  typedef ResetDeviceResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acknowledged(bool acknowledged) {
    fbb_.AddElement<uint8_t>(ResetDeviceResponse::VT_ACKNOWLEDGED, static_cast<uint8_t>(acknowledged), 0);
  }
  explicit ResetDeviceResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ResetDeviceResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResetDeviceResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResetDeviceResponse> CreateResetDeviceResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool acknowledged = false) {
  ResetDeviceResponseBuilder builder_(_fbb);
  builder_.add_acknowledged(acknowledged);
  return builder_.Finish();
}

struct CalibrateAudioResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CalibrateAudioResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4,
    VT_CALIBRATION_DATA = 6,
    VT_MESSAGE = 8
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const sparetools::bpm::AudioCalibrationData *calibration_data() const {
    return GetPointer<const sparetools::bpm::AudioCalibrationData *>(VT_CALIBRATION_DATA);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffset(verifier, VT_CALIBRATION_DATA) &&
           verifier.VerifyTable(calibration_data()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct CalibrateAudioResponseBuilder {
  typedef CalibrateAudioResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(CalibrateAudioResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_calibration_data(flatbuffers::Offset<sparetools::bpm::AudioCalibrationData> calibration_data) {
    fbb_.AddOffset(CalibrateAudioResponse::VT_CALIBRATION_DATA, calibration_data);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(CalibrateAudioResponse::VT_MESSAGE, message);
  }
  explicit CalibrateAudioResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CalibrateAudioResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CalibrateAudioResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<CalibrateAudioResponse> CreateCalibrateAudioResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    flatbuffers::Offset<sparetools::bpm::AudioCalibrationData> calibration_data = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  CalibrateAudioResponseBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_calibration_data(calibration_data);
  builder_.add_success(success);
  return builder_.Finish();
}

inline flatbuffers::Offset<CalibrateAudioResponse> CreateCalibrateAudioResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    flatbuffers::Offset<sparetools::bpm::AudioCalibrationData> calibration_data = 0,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return sparetools::bpm::CreateCalibrateAudioResponse(
      _fbb,
      success,
      calibration_data,
      message__);
}

struct StartStreamingResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StartStreamingResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4,
    VT_STREAM_ID = 6,
    VT_MESSAGE = 8
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const flatbuffers::String *stream_id() const {
    return GetPointer<const flatbuffers::String *>(VT_STREAM_ID);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffset(verifier, VT_STREAM_ID) &&
           verifier.VerifyString(stream_id()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct StartStreamingResponseBuilder {
  typedef StartStreamingResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(StartStreamingResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_stream_id(flatbuffers::Offset<flatbuffers::String> stream_id) {
    fbb_.AddOffset(StartStreamingResponse::VT_STREAM_ID, stream_id);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(StartStreamingResponse::VT_MESSAGE, message);
  }
  explicit StartStreamingResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StartStreamingResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StartStreamingResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<StartStreamingResponse> CreateStartStreamingResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    flatbuffers::Offset<flatbuffers::String> stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  StartStreamingResponseBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_stream_id(stream_id);
  builder_.add_success(success);
  return builder_.Finish();
}

inline flatbuffers::Offset<StartStreamingResponse> CreateStartStreamingResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    const char *stream_id = nullptr,
    const char *message = nullptr) {
  auto stream_id__ = stream_id ? _fbb.CreateString(stream_id) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return sparetools::bpm::CreateStartStreamingResponse(
      _fbb,
      success,
      stream_id__,
      message__);
}

struct StopStreamingResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StopStreamingResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4,
    VT_MESSAGE = 6
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct StopStreamingResponseBuilder {
  typedef StopStreamingResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(StopStreamingResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(StopStreamingResponse::VT_MESSAGE, message);
  }
  explicit StopStreamingResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StopStreamingResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StopStreamingResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<StopStreamingResponse> CreateStopStreamingResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  StopStreamingResponseBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_success(success);
  return builder_.Finish();
}

inline flatbuffers::Offset<StopStreamingResponse> CreateStopStreamingResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return sparetools::bpm::CreateStopStreamingResponse(
      _fbb,
      success,
      message__);
}

struct GetDiagnosticsResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetDiagnosticsResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIAGNOSTICS = 4
  };
  const sparetools::bpm::DiagnosticsData *diagnostics() const {
    return GetPointer<const sparetools::bpm::DiagnosticsData *>(VT_DIAGNOSTICS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIAGNOSTICS) &&
           verifier.VerifyTable(diagnostics()) &&
           verifier.EndTable();
  }
};

struct GetDiagnosticsResponseBuilder {
  typedef GetDiagnosticsResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_diagnostics(flatbuffers::Offset<sparetools::bpm::DiagnosticsData> diagnostics) {
    fbb_.AddOffset(GetDiagnosticsResponse::VT_DIAGNOSTICS, diagnostics);
  }
  explicit GetDiagnosticsResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GetDiagnosticsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetDiagnosticsResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetDiagnosticsResponse> CreateGetDiagnosticsResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<sparetools::bpm::DiagnosticsData> diagnostics = 0) {
  GetDiagnosticsResponseBuilder builder_(_fbb);
  builder_.add_diagnostics(diagnostics);
  return builder_.Finish();
}

struct Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_STATUS = 6,
    VT_DATA_TYPE_TYPE = 8,
    VT_DATA_TYPE = 10,
    VT_DATA = 12
  };
  const sparetools::bpm::Header *header() const {
    return GetPointer<const sparetools::bpm::Header *>(VT_HEADER);
  }
  const sparetools::bpm::Status *status() const {
    return GetPointer<const sparetools::bpm::Status *>(VT_STATUS);
  }
  sparetools::bpm::ResponsePayload data_type_type() const {
    return static_cast<sparetools::bpm::ResponsePayload>(GetField<uint8_t>(VT_DATA_TYPE_TYPE, 0));
  }
  const void *data_type() const {
    return GetPointer<const void *>(VT_DATA_TYPE);
  }
  template<typename T> const T *data_type_as() const;
  const sparetools::bpm::GetStatusResponse *data_type_as_GetStatusResponse() const {
    return data_type_type() == sparetools::bpm::ResponsePayload_GetStatusResponse ? static_cast<const sparetools::bpm::GetStatusResponse *>(data_type()) : nullptr;
  }
  const sparetools::bpm::GetConfigResponse *data_type_as_GetConfigResponse() const {
    return data_type_type() == sparetools::bpm::ResponsePayload_GetConfigResponse ? static_cast<const sparetools::bpm::GetConfigResponse *>(data_type()) : nullptr;
  }
  const sparetools::bpm::SetConfigResponse *data_type_as_SetConfigResponse() const {
    return data_type_type() == sparetools::bpm::ResponsePayload_SetConfigResponse ? static_cast<const sparetools::bpm::SetConfigResponse *>(data_type()) : nullptr;
  }
  const sparetools::bpm::ResetDeviceResponse *data_type_as_ResetDeviceResponse() const {
    return data_type_type() == sparetools::bpm::ResponsePayload_ResetDeviceResponse ? static_cast<const sparetools::bpm::ResetDeviceResponse *>(data_type()) : nullptr;
  }
  const sparetools::bpm::CalibrateAudioResponse *data_type_as_CalibrateAudioResponse() const {
    return data_type_type() == sparetools::bpm::ResponsePayload_CalibrateAudioResponse ? static_cast<const sparetools::bpm::CalibrateAudioResponse *>(data_type()) : nullptr;
  }
  const sparetools::bpm::StartStreamingResponse *data_type_as_StartStreamingResponse() const {
    return data_type_type() == sparetools::bpm::ResponsePayload_StartStreamingResponse ? static_cast<const sparetools::bpm::StartStreamingResponse *>(data_type()) : nullptr;
  }
  const sparetools::bpm::StopStreamingResponse *data_type_as_StopStreamingResponse() const {
    return data_type_type() == sparetools::bpm::ResponsePayload_StopStreamingResponse ? static_cast<const sparetools::bpm::StopStreamingResponse *>(data_type()) : nullptr;
  }
  const sparetools::bpm::GetDiagnosticsResponse *data_type_as_GetDiagnosticsResponse() const {
    return data_type_type() == sparetools::bpm::ResponsePayload_GetDiagnosticsResponse ? static_cast<const sparetools::bpm::GetDiagnosticsResponse *>(data_type()) : nullptr;
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA_TYPE) &&
           VerifyResponsePayload(verifier, data_type(), data_type_type()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

template<> inline const sparetools::bpm::GetStatusResponse *Response::data_type_as<sparetools::bpm::GetStatusResponse>() const {
  return data_type_as_GetStatusResponse();
}

template<> inline const sparetools::bpm::GetConfigResponse *Response::data_type_as<sparetools::bpm::GetConfigResponse>() const {
  return data_type_as_GetConfigResponse();
}

template<> inline const sparetools::bpm::SetConfigResponse *Response::data_type_as<sparetools::bpm::SetConfigResponse>() const {
  return data_type_as_SetConfigResponse();
}

template<> inline const sparetools::bpm::ResetDeviceResponse *Response::data_type_as<sparetools::bpm::ResetDeviceResponse>() const {
  return data_type_as_ResetDeviceResponse();
}

template<> inline const sparetools::bpm::CalibrateAudioResponse *Response::data_type_as<sparetools::bpm::CalibrateAudioResponse>() const {
  return data_type_as_CalibrateAudioResponse();
}

template<> inline const sparetools::bpm::StartStreamingResponse *Response::data_type_as<sparetools::bpm::StartStreamingResponse>() const {
  return data_type_as_StartStreamingResponse();
}

template<> inline const sparetools::bpm::StopStreamingResponse *Response::data_type_as<sparetools::bpm::StopStreamingResponse>() const {
  return data_type_as_StopStreamingResponse();
}

template<> inline const sparetools::bpm::GetDiagnosticsResponse *Response::data_type_as<sparetools::bpm::GetDiagnosticsResponse>() const {
  return data_type_as_GetDiagnosticsResponse();
}

struct ResponseBuilder {
  typedef Response Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_header(flatbuffers::Offset<sparetools::bpm::Header> header) {
    fbb_.AddOffset(Response::VT_HEADER, header);
  }
  void add_status(flatbuffers::Offset<sparetools::bpm::Status> status) {
    fbb_.AddOffset(Response::VT_STATUS, status);
  }
  void add_data_type_type(sparetools::bpm::ResponsePayload data_type_type) {
    fbb_.AddElement<uint8_t>(Response::VT_DATA_TYPE_TYPE, static_cast<uint8_t>(data_type_type), 0);
  }
  void add_data_type(flatbuffers::Offset<void> data_type) {
    fbb_.AddOffset(Response::VT_DATA_TYPE, data_type);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Response::VT_DATA, data);
  }
  explicit ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response> CreateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<sparetools::bpm::Header> header = 0,
    flatbuffers::Offset<sparetools::bpm::Status> status = 0,
    sparetools::bpm::ResponsePayload data_type_type = sparetools::bpm::ResponsePayload_NONE,
    flatbuffers::Offset<void> data_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  builder_.add_status(status);
  builder_.add_header(header);
  builder_.add_data_type_type(data_type_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response> CreateResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<sparetools::bpm::Header> header = 0,
    flatbuffers::Offset<sparetools::bpm::Status> status = 0,
    sparetools::bpm::ResponsePayload data_type_type = sparetools::bpm::ResponsePayload_NONE,
    flatbuffers::Offset<void> data_type = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return sparetools::bpm::CreateResponse(
      _fbb,
      header,
      status,
      data_type_type,
      data_type,
      data__);
}

inline bool VerifyResponsePayload(flatbuffers::Verifier &verifier, const void *obj, ResponsePayload type) {
  switch (type) {
    case ResponsePayload_NONE: {
      return true;
    }
    case ResponsePayload_GetStatusResponse: {
      auto ptr = reinterpret_cast<const sparetools::bpm::GetStatusResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePayload_GetConfigResponse: {
      auto ptr = reinterpret_cast<const sparetools::bpm::GetConfigResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePayload_SetConfigResponse: {
      auto ptr = reinterpret_cast<const sparetools::bpm::SetConfigResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePayload_ResetDeviceResponse: {
      auto ptr = reinterpret_cast<const sparetools::bpm::ResetDeviceResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePayload_CalibrateAudioResponse: {
      auto ptr = reinterpret_cast<const sparetools::bpm::CalibrateAudioResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePayload_StartStreamingResponse: {
      auto ptr = reinterpret_cast<const sparetools::bpm::StartStreamingResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePayload_StopStreamingResponse: {
      auto ptr = reinterpret_cast<const sparetools::bpm::StopStreamingResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePayload_GetDiagnosticsResponse: {
      auto ptr = reinterpret_cast<const sparetools::bpm::GetDiagnosticsResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyResponsePayloadVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResponsePayload(
        verifier,  values->Get(i), types->GetEnum<ResponsePayload>(i))) {
      return false;
    }
  }
  return true;
}

inline const sparetools::bpm::Response *GetResponse(const void *buf) {
  return flatbuffers::GetRoot<sparetools::bpm::Response>(buf);
}

inline const sparetools::bpm::Response *GetSizePrefixedResponse(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<sparetools::bpm::Response>(buf);
}

inline bool VerifyResponseBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<sparetools::bpm::Response>(nullptr);
}

inline bool VerifySizePrefixedResponseBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<sparetools::bpm::Response>(nullptr);
}

inline void FinishResponseBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<sparetools::bpm::Response> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedResponseBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<sparetools::bpm::Response> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace bpm
}  // namespace sparetools

#endif  // FLATBUFFERS_GENERATED_BPMRESPONSES_SPARETOOLS_BPM_H_
