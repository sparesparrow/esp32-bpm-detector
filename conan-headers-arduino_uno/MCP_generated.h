// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MCP_SPARESPARROW_MCP_H_
#define FLATBUFFERS_GENERATED_MCP_SPARESPARROW_MCP_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "common_generated.h"

namespace sparesparrow {
namespace mcp {

struct GPIOCommand;
struct GPIOCommandBuilder;

struct GPIOResponse;
struct GPIOResponseBuilder;

struct SerialTelemetry;
struct SerialTelemetryBuilder;

struct SerialCommand;
struct SerialCommandBuilder;

struct SerialResponse;
struct SerialResponseBuilder;

struct SystemStatus;
struct SystemStatusBuilder;

struct NetworkStatus;
struct NetworkStatusBuilder;

struct SystemCommand;
struct SystemCommandBuilder;

struct SystemResponse;
struct SystemResponseBuilder;

struct MCEnvelope;
struct MCEnvelopeBuilder;

enum class GPIOMode : int8_t {
  INPUT = 0,
  OUTPUT = 1,
  INPUT_PULLUP = 2,
  INPUT_PULLDOWN = 3,
  MIN = INPUT,
  MAX = INPUT_PULLDOWN
};

inline const GPIOMode (&EnumValuesGPIOMode())[4] {
  static const GPIOMode values[] = {
    GPIOMode::INPUT,
    GPIOMode::OUTPUT,
    GPIOMode::INPUT_PULLUP,
    GPIOMode::INPUT_PULLDOWN
  };
  return values;
}

inline const char * const *EnumNamesGPIOMode() {
  static const char * const names[5] = {
    "INPUT",
    "OUTPUT",
    "INPUT_PULLUP",
    "INPUT_PULLDOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameGPIOMode(GPIOMode e) {
  if (::flatbuffers::IsOutRange(e, GPIOMode::INPUT, GPIOMode::INPUT_PULLDOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGPIOMode()[index];
}

enum class MCPMessage : uint8_t {
  NONE = 0,
  GPIOCommand = 1,
  GPIOResponse = 2,
  SerialTelemetry = 3,
  SerialCommand = 4,
  SerialResponse = 5,
  SystemStatus = 6,
  NetworkStatus = 7,
  SystemCommand = 8,
  SystemResponse = 9,
  MIN = NONE,
  MAX = SystemResponse
};

inline const MCPMessage (&EnumValuesMCPMessage())[10] {
  static const MCPMessage values[] = {
    MCPMessage::NONE,
    MCPMessage::GPIOCommand,
    MCPMessage::GPIOResponse,
    MCPMessage::SerialTelemetry,
    MCPMessage::SerialCommand,
    MCPMessage::SerialResponse,
    MCPMessage::SystemStatus,
    MCPMessage::NetworkStatus,
    MCPMessage::SystemCommand,
    MCPMessage::SystemResponse
  };
  return values;
}

inline const char * const *EnumNamesMCPMessage() {
  static const char * const names[11] = {
    "NONE",
    "GPIOCommand",
    "GPIOResponse",
    "SerialTelemetry",
    "SerialCommand",
    "SerialResponse",
    "SystemStatus",
    "NetworkStatus",
    "SystemCommand",
    "SystemResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameMCPMessage(MCPMessage e) {
  if (::flatbuffers::IsOutRange(e, MCPMessage::NONE, MCPMessage::SystemResponse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMCPMessage()[index];
}

template<typename T> struct MCPMessageTraits {
  static const MCPMessage enum_value = MCPMessage::NONE;
};

template<> struct MCPMessageTraits<sparesparrow::mcp::GPIOCommand> {
  static const MCPMessage enum_value = MCPMessage::GPIOCommand;
};

template<> struct MCPMessageTraits<sparesparrow::mcp::GPIOResponse> {
  static const MCPMessage enum_value = MCPMessage::GPIOResponse;
};

template<> struct MCPMessageTraits<sparesparrow::mcp::SerialTelemetry> {
  static const MCPMessage enum_value = MCPMessage::SerialTelemetry;
};

template<> struct MCPMessageTraits<sparesparrow::mcp::SerialCommand> {
  static const MCPMessage enum_value = MCPMessage::SerialCommand;
};

template<> struct MCPMessageTraits<sparesparrow::mcp::SerialResponse> {
  static const MCPMessage enum_value = MCPMessage::SerialResponse;
};

template<> struct MCPMessageTraits<sparesparrow::mcp::SystemStatus> {
  static const MCPMessage enum_value = MCPMessage::SystemStatus;
};

template<> struct MCPMessageTraits<sparesparrow::mcp::NetworkStatus> {
  static const MCPMessage enum_value = MCPMessage::NetworkStatus;
};

template<> struct MCPMessageTraits<sparesparrow::mcp::SystemCommand> {
  static const MCPMessage enum_value = MCPMessage::SystemCommand;
};

template<> struct MCPMessageTraits<sparesparrow::mcp::SystemResponse> {
  static const MCPMessage enum_value = MCPMessage::SystemResponse;
};

bool VerifyMCPMessage(::flatbuffers::Verifier &verifier, const void *obj, MCPMessage type);
bool VerifyMCPMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<MCPMessage> *types);

struct GPIOCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GPIOCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PIN = 4,
    VT_STATE = 6,
    VT_MODE = 8,
    VT_TIMESTAMP = 10
  };
  int32_t pin() const {
    return GetField<int32_t>(VT_PIN, 0);
  }
  bool state() const {
    return GetField<uint8_t>(VT_STATE, 0) != 0;
  }
  sparesparrow::mcp::GPIOMode mode() const {
    return static_cast<sparesparrow::mcp::GPIOMode>(GetField<int8_t>(VT_MODE, 0));
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PIN, 4) &&
           VerifyField<uint8_t>(verifier, VT_STATE, 1) &&
           VerifyField<int8_t>(verifier, VT_MODE, 1) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct GPIOCommandBuilder {
  typedef GPIOCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pin(int32_t pin) {
    fbb_.AddElement<int32_t>(GPIOCommand::VT_PIN, pin, 0);
  }
  void add_state(bool state) {
    fbb_.AddElement<uint8_t>(GPIOCommand::VT_STATE, static_cast<uint8_t>(state), 0);
  }
  void add_mode(sparesparrow::mcp::GPIOMode mode) {
    fbb_.AddElement<int8_t>(GPIOCommand::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(GPIOCommand::VT_TIMESTAMP, timestamp, 0);
  }
  explicit GPIOCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GPIOCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GPIOCommand>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GPIOCommand> CreateGPIOCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pin = 0,
    bool state = false,
    sparesparrow::mcp::GPIOMode mode = sparesparrow::mcp::GPIOMode::INPUT,
    uint64_t timestamp = 0) {
  GPIOCommandBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_pin(pin);
  builder_.add_mode(mode);
  builder_.add_state(state);
  return builder_.Finish();
}

struct GPIOResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GPIOResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PIN = 4,
    VT_STATE = 6,
    VT_SUCCESS = 8,
    VT_ERROR_MESSAGE = 10,
    VT_TIMESTAMP = 12
  };
  int32_t pin() const {
    return GetField<int32_t>(VT_PIN, 0);
  }
  bool state() const {
    return GetField<uint8_t>(VT_STATE, 0) != 0;
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const ::flatbuffers::String *error_message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PIN, 4) &&
           VerifyField<uint8_t>(verifier, VT_STATE, 1) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct GPIOResponseBuilder {
  typedef GPIOResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pin(int32_t pin) {
    fbb_.AddElement<int32_t>(GPIOResponse::VT_PIN, pin, 0);
  }
  void add_state(bool state) {
    fbb_.AddElement<uint8_t>(GPIOResponse::VT_STATE, static_cast<uint8_t>(state), 0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(GPIOResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_error_message(::flatbuffers::Offset<::flatbuffers::String> error_message) {
    fbb_.AddOffset(GPIOResponse::VT_ERROR_MESSAGE, error_message);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(GPIOResponse::VT_TIMESTAMP, timestamp, 0);
  }
  explicit GPIOResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GPIOResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GPIOResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GPIOResponse> CreateGPIOResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pin = 0,
    bool state = false,
    bool success = false,
    ::flatbuffers::Offset<::flatbuffers::String> error_message = 0,
    uint64_t timestamp = 0) {
  GPIOResponseBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_error_message(error_message);
  builder_.add_pin(pin);
  builder_.add_success(success);
  builder_.add_state(state);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GPIOResponse> CreateGPIOResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pin = 0,
    bool state = false,
    bool success = false,
    const char *error_message = nullptr,
    uint64_t timestamp = 0) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return sparesparrow::mcp::CreateGPIOResponse(
      _fbb,
      pin,
      state,
      success,
      error_message__,
      timestamp);
}

struct SerialTelemetry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SerialTelemetryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_SENSOR_ID = 6,
    VT_DATA_TYPE = 8,
    VT_VALUE = 10,
    VT_UNIT = 12,
    VT_RAW_DATA = 14
  };
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  const ::flatbuffers::String *sensor_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SENSOR_ID);
  }
  const ::flatbuffers::String *data_type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATA_TYPE);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  const ::flatbuffers::String *unit() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UNIT);
  }
  const ::flatbuffers::Vector<uint8_t> *raw_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_RAW_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyOffset(verifier, VT_SENSOR_ID) &&
           verifier.VerifyString(sensor_id()) &&
           VerifyOffset(verifier, VT_DATA_TYPE) &&
           verifier.VerifyString(data_type()) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           VerifyOffset(verifier, VT_UNIT) &&
           verifier.VerifyString(unit()) &&
           VerifyOffset(verifier, VT_RAW_DATA) &&
           verifier.VerifyVector(raw_data()) &&
           verifier.EndTable();
  }
};

struct SerialTelemetryBuilder {
  typedef SerialTelemetry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(SerialTelemetry::VT_TIMESTAMP, timestamp, 0);
  }
  void add_sensor_id(::flatbuffers::Offset<::flatbuffers::String> sensor_id) {
    fbb_.AddOffset(SerialTelemetry::VT_SENSOR_ID, sensor_id);
  }
  void add_data_type(::flatbuffers::Offset<::flatbuffers::String> data_type) {
    fbb_.AddOffset(SerialTelemetry::VT_DATA_TYPE, data_type);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(SerialTelemetry::VT_VALUE, value, 0.0f);
  }
  void add_unit(::flatbuffers::Offset<::flatbuffers::String> unit) {
    fbb_.AddOffset(SerialTelemetry::VT_UNIT, unit);
  }
  void add_raw_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> raw_data) {
    fbb_.AddOffset(SerialTelemetry::VT_RAW_DATA, raw_data);
  }
  explicit SerialTelemetryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SerialTelemetry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SerialTelemetry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SerialTelemetry> CreateSerialTelemetry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timestamp = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sensor_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> data_type = 0,
    float value = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> unit = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> raw_data = 0) {
  SerialTelemetryBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_raw_data(raw_data);
  builder_.add_unit(unit);
  builder_.add_value(value);
  builder_.add_data_type(data_type);
  builder_.add_sensor_id(sensor_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SerialTelemetry> CreateSerialTelemetryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timestamp = 0,
    const char *sensor_id = nullptr,
    const char *data_type = nullptr,
    float value = 0.0f,
    const char *unit = nullptr,
    const std::vector<uint8_t> *raw_data = nullptr) {
  auto sensor_id__ = sensor_id ? _fbb.CreateString(sensor_id) : 0;
  auto data_type__ = data_type ? _fbb.CreateString(data_type) : 0;
  auto unit__ = unit ? _fbb.CreateString(unit) : 0;
  auto raw_data__ = raw_data ? _fbb.CreateVector<uint8_t>(*raw_data) : 0;
  return sparesparrow::mcp::CreateSerialTelemetry(
      _fbb,
      timestamp,
      sensor_id__,
      data_type__,
      value,
      unit__,
      raw_data__);
}

struct SerialCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SerialCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND = 4,
    VT_PARAMETERS = 6,
    VT_TIMEOUT_MS = 8,
    VT_TIMESTAMP = 10
  };
  const ::flatbuffers::String *command() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMAND);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *parameters() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_PARAMETERS);
  }
  uint32_t timeout_ms() const {
    return GetField<uint32_t>(VT_TIMEOUT_MS, 0);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           verifier.VerifyString(command()) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           verifier.VerifyVectorOfStrings(parameters()) &&
           VerifyField<uint32_t>(verifier, VT_TIMEOUT_MS, 4) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct SerialCommandBuilder {
  typedef SerialCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_command(::flatbuffers::Offset<::flatbuffers::String> command) {
    fbb_.AddOffset(SerialCommand::VT_COMMAND, command);
  }
  void add_parameters(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> parameters) {
    fbb_.AddOffset(SerialCommand::VT_PARAMETERS, parameters);
  }
  void add_timeout_ms(uint32_t timeout_ms) {
    fbb_.AddElement<uint32_t>(SerialCommand::VT_TIMEOUT_MS, timeout_ms, 0);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(SerialCommand::VT_TIMESTAMP, timestamp, 0);
  }
  explicit SerialCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SerialCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SerialCommand>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SerialCommand> CreateSerialCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> command = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> parameters = 0,
    uint32_t timeout_ms = 0,
    uint64_t timestamp = 0) {
  SerialCommandBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_timeout_ms(timeout_ms);
  builder_.add_parameters(parameters);
  builder_.add_command(command);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SerialCommand> CreateSerialCommandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *command = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *parameters = nullptr,
    uint32_t timeout_ms = 0,
    uint64_t timestamp = 0) {
  auto command__ = command ? _fbb.CreateString(command) : 0;
  auto parameters__ = parameters ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*parameters) : 0;
  return sparesparrow::mcp::CreateSerialCommand(
      _fbb,
      command__,
      parameters__,
      timeout_ms,
      timestamp);
}

struct SerialResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SerialResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND = 4,
    VT_SUCCESS = 6,
    VT_RESPONSE_DATA = 8,
    VT_ERROR_MESSAGE = 10,
    VT_TIMESTAMP = 12
  };
  const ::flatbuffers::String *command() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMAND);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const ::flatbuffers::String *response_data() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESPONSE_DATA);
  }
  const ::flatbuffers::String *error_message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           verifier.VerifyString(command()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffset(verifier, VT_RESPONSE_DATA) &&
           verifier.VerifyString(response_data()) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct SerialResponseBuilder {
  typedef SerialResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_command(::flatbuffers::Offset<::flatbuffers::String> command) {
    fbb_.AddOffset(SerialResponse::VT_COMMAND, command);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(SerialResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_response_data(::flatbuffers::Offset<::flatbuffers::String> response_data) {
    fbb_.AddOffset(SerialResponse::VT_RESPONSE_DATA, response_data);
  }
  void add_error_message(::flatbuffers::Offset<::flatbuffers::String> error_message) {
    fbb_.AddOffset(SerialResponse::VT_ERROR_MESSAGE, error_message);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(SerialResponse::VT_TIMESTAMP, timestamp, 0);
  }
  explicit SerialResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SerialResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SerialResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SerialResponse> CreateSerialResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> command = 0,
    bool success = false,
    ::flatbuffers::Offset<::flatbuffers::String> response_data = 0,
    ::flatbuffers::Offset<::flatbuffers::String> error_message = 0,
    uint64_t timestamp = 0) {
  SerialResponseBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_error_message(error_message);
  builder_.add_response_data(response_data);
  builder_.add_command(command);
  builder_.add_success(success);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SerialResponse> CreateSerialResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *command = nullptr,
    bool success = false,
    const char *response_data = nullptr,
    const char *error_message = nullptr,
    uint64_t timestamp = 0) {
  auto command__ = command ? _fbb.CreateString(command) : 0;
  auto response_data__ = response_data ? _fbb.CreateString(response_data) : 0;
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return sparesparrow::mcp::CreateSerialResponse(
      _fbb,
      command__,
      success,
      response_data__,
      error_message__,
      timestamp);
}

struct SystemStatus FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SystemStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPTIME = 4,
    VT_CPU_USAGE = 6,
    VT_MEMORY_USAGE = 8,
    VT_TEMPERATURE = 10,
    VT_TIMESTAMP = 12
  };
  uint64_t uptime() const {
    return GetField<uint64_t>(VT_UPTIME, 0);
  }
  float cpu_usage() const {
    return GetField<float>(VT_CPU_USAGE, 0.0f);
  }
  float memory_usage() const {
    return GetField<float>(VT_MEMORY_USAGE, 0.0f);
  }
  float temperature() const {
    return GetField<float>(VT_TEMPERATURE, 0.0f);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_UPTIME, 8) &&
           VerifyField<float>(verifier, VT_CPU_USAGE, 4) &&
           VerifyField<float>(verifier, VT_MEMORY_USAGE, 4) &&
           VerifyField<float>(verifier, VT_TEMPERATURE, 4) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct SystemStatusBuilder {
  typedef SystemStatus Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uptime(uint64_t uptime) {
    fbb_.AddElement<uint64_t>(SystemStatus::VT_UPTIME, uptime, 0);
  }
  void add_cpu_usage(float cpu_usage) {
    fbb_.AddElement<float>(SystemStatus::VT_CPU_USAGE, cpu_usage, 0.0f);
  }
  void add_memory_usage(float memory_usage) {
    fbb_.AddElement<float>(SystemStatus::VT_MEMORY_USAGE, memory_usage, 0.0f);
  }
  void add_temperature(float temperature) {
    fbb_.AddElement<float>(SystemStatus::VT_TEMPERATURE, temperature, 0.0f);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(SystemStatus::VT_TIMESTAMP, timestamp, 0);
  }
  explicit SystemStatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SystemStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SystemStatus>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SystemStatus> CreateSystemStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t uptime = 0,
    float cpu_usage = 0.0f,
    float memory_usage = 0.0f,
    float temperature = 0.0f,
    uint64_t timestamp = 0) {
  SystemStatusBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_uptime(uptime);
  builder_.add_temperature(temperature);
  builder_.add_memory_usage(memory_usage);
  builder_.add_cpu_usage(cpu_usage);
  return builder_.Finish();
}

struct NetworkStatus FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetworkStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONNECTED = 4,
    VT_IP_ADDRESS = 6,
    VT_MAC_ADDRESS = 8,
    VT_SIGNAL_STRENGTH = 10,
    VT_TIMESTAMP = 12
  };
  bool connected() const {
    return GetField<uint8_t>(VT_CONNECTED, 0) != 0;
  }
  const ::flatbuffers::String *ip_address() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IP_ADDRESS);
  }
  const ::flatbuffers::String *mac_address() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAC_ADDRESS);
  }
  int32_t signal_strength() const {
    return GetField<int32_t>(VT_SIGNAL_STRENGTH, 0);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CONNECTED, 1) &&
           VerifyOffset(verifier, VT_IP_ADDRESS) &&
           verifier.VerifyString(ip_address()) &&
           VerifyOffset(verifier, VT_MAC_ADDRESS) &&
           verifier.VerifyString(mac_address()) &&
           VerifyField<int32_t>(verifier, VT_SIGNAL_STRENGTH, 4) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct NetworkStatusBuilder {
  typedef NetworkStatus Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_connected(bool connected) {
    fbb_.AddElement<uint8_t>(NetworkStatus::VT_CONNECTED, static_cast<uint8_t>(connected), 0);
  }
  void add_ip_address(::flatbuffers::Offset<::flatbuffers::String> ip_address) {
    fbb_.AddOffset(NetworkStatus::VT_IP_ADDRESS, ip_address);
  }
  void add_mac_address(::flatbuffers::Offset<::flatbuffers::String> mac_address) {
    fbb_.AddOffset(NetworkStatus::VT_MAC_ADDRESS, mac_address);
  }
  void add_signal_strength(int32_t signal_strength) {
    fbb_.AddElement<int32_t>(NetworkStatus::VT_SIGNAL_STRENGTH, signal_strength, 0);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(NetworkStatus::VT_TIMESTAMP, timestamp, 0);
  }
  explicit NetworkStatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetworkStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetworkStatus>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetworkStatus> CreateNetworkStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool connected = false,
    ::flatbuffers::Offset<::flatbuffers::String> ip_address = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mac_address = 0,
    int32_t signal_strength = 0,
    uint64_t timestamp = 0) {
  NetworkStatusBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_signal_strength(signal_strength);
  builder_.add_mac_address(mac_address);
  builder_.add_ip_address(ip_address);
  builder_.add_connected(connected);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetworkStatus> CreateNetworkStatusDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool connected = false,
    const char *ip_address = nullptr,
    const char *mac_address = nullptr,
    int32_t signal_strength = 0,
    uint64_t timestamp = 0) {
  auto ip_address__ = ip_address ? _fbb.CreateString(ip_address) : 0;
  auto mac_address__ = mac_address ? _fbb.CreateString(mac_address) : 0;
  return sparesparrow::mcp::CreateNetworkStatus(
      _fbb,
      connected,
      ip_address__,
      mac_address__,
      signal_strength,
      timestamp);
}

struct SystemCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SystemCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTION = 4,
    VT_PARAMETERS = 6,
    VT_TIMEOUT_MS = 8,
    VT_TIMESTAMP = 10
  };
  const ::flatbuffers::String *action() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACTION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *parameters() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_PARAMETERS);
  }
  uint32_t timeout_ms() const {
    return GetField<uint32_t>(VT_TIMEOUT_MS, 0);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACTION) &&
           verifier.VerifyString(action()) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           verifier.VerifyVectorOfStrings(parameters()) &&
           VerifyField<uint32_t>(verifier, VT_TIMEOUT_MS, 4) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct SystemCommandBuilder {
  typedef SystemCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_action(::flatbuffers::Offset<::flatbuffers::String> action) {
    fbb_.AddOffset(SystemCommand::VT_ACTION, action);
  }
  void add_parameters(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> parameters) {
    fbb_.AddOffset(SystemCommand::VT_PARAMETERS, parameters);
  }
  void add_timeout_ms(uint32_t timeout_ms) {
    fbb_.AddElement<uint32_t>(SystemCommand::VT_TIMEOUT_MS, timeout_ms, 0);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(SystemCommand::VT_TIMESTAMP, timestamp, 0);
  }
  explicit SystemCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SystemCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SystemCommand>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SystemCommand> CreateSystemCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> action = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> parameters = 0,
    uint32_t timeout_ms = 0,
    uint64_t timestamp = 0) {
  SystemCommandBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_timeout_ms(timeout_ms);
  builder_.add_parameters(parameters);
  builder_.add_action(action);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SystemCommand> CreateSystemCommandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *action = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *parameters = nullptr,
    uint32_t timeout_ms = 0,
    uint64_t timestamp = 0) {
  auto action__ = action ? _fbb.CreateString(action) : 0;
  auto parameters__ = parameters ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*parameters) : 0;
  return sparesparrow::mcp::CreateSystemCommand(
      _fbb,
      action__,
      parameters__,
      timeout_ms,
      timestamp);
}

struct SystemResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SystemResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTION = 4,
    VT_SUCCESS = 6,
    VT_RESULT = 8,
    VT_ERROR_MESSAGE = 10,
    VT_TIMESTAMP = 12
  };
  const ::flatbuffers::String *action() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACTION);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *error_message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACTION) &&
           verifier.VerifyString(action()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct SystemResponseBuilder {
  typedef SystemResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_action(::flatbuffers::Offset<::flatbuffers::String> action) {
    fbb_.AddOffset(SystemResponse::VT_ACTION, action);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(SystemResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(SystemResponse::VT_RESULT, result);
  }
  void add_error_message(::flatbuffers::Offset<::flatbuffers::String> error_message) {
    fbb_.AddOffset(SystemResponse::VT_ERROR_MESSAGE, error_message);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(SystemResponse::VT_TIMESTAMP, timestamp, 0);
  }
  explicit SystemResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SystemResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SystemResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SystemResponse> CreateSystemResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> action = 0,
    bool success = false,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> error_message = 0,
    uint64_t timestamp = 0) {
  SystemResponseBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_error_message(error_message);
  builder_.add_result(result);
  builder_.add_action(action);
  builder_.add_success(success);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SystemResponse> CreateSystemResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *action = nullptr,
    bool success = false,
    const char *result = nullptr,
    const char *error_message = nullptr,
    uint64_t timestamp = 0) {
  auto action__ = action ? _fbb.CreateString(action) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return sparesparrow::mcp::CreateSystemResponse(
      _fbb,
      action__,
      success,
      result__,
      error_message__,
      timestamp);
}

struct MCEnvelope FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MCEnvelopeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE_TYPE = 4,
    VT_MESSAGE_TYPE = 6,
    VT_MESSAGE_ID = 8,
    VT_DEVICE_ID = 10
  };
  sparesparrow::mcp::MCPMessage message_type_type() const {
    return static_cast<sparesparrow::mcp::MCPMessage>(GetField<uint8_t>(VT_MESSAGE_TYPE_TYPE, 0));
  }
  const void *message_type() const {
    return GetPointer<const void *>(VT_MESSAGE_TYPE);
  }
  template<typename T> const T *message_type_as() const;
  const sparesparrow::mcp::GPIOCommand *message_type_as_GPIOCommand() const {
    return message_type_type() == sparesparrow::mcp::MCPMessage::GPIOCommand ? static_cast<const sparesparrow::mcp::GPIOCommand *>(message_type()) : nullptr;
  }
  const sparesparrow::mcp::GPIOResponse *message_type_as_GPIOResponse() const {
    return message_type_type() == sparesparrow::mcp::MCPMessage::GPIOResponse ? static_cast<const sparesparrow::mcp::GPIOResponse *>(message_type()) : nullptr;
  }
  const sparesparrow::mcp::SerialTelemetry *message_type_as_SerialTelemetry() const {
    return message_type_type() == sparesparrow::mcp::MCPMessage::SerialTelemetry ? static_cast<const sparesparrow::mcp::SerialTelemetry *>(message_type()) : nullptr;
  }
  const sparesparrow::mcp::SerialCommand *message_type_as_SerialCommand() const {
    return message_type_type() == sparesparrow::mcp::MCPMessage::SerialCommand ? static_cast<const sparesparrow::mcp::SerialCommand *>(message_type()) : nullptr;
  }
  const sparesparrow::mcp::SerialResponse *message_type_as_SerialResponse() const {
    return message_type_type() == sparesparrow::mcp::MCPMessage::SerialResponse ? static_cast<const sparesparrow::mcp::SerialResponse *>(message_type()) : nullptr;
  }
  const sparesparrow::mcp::SystemStatus *message_type_as_SystemStatus() const {
    return message_type_type() == sparesparrow::mcp::MCPMessage::SystemStatus ? static_cast<const sparesparrow::mcp::SystemStatus *>(message_type()) : nullptr;
  }
  const sparesparrow::mcp::NetworkStatus *message_type_as_NetworkStatus() const {
    return message_type_type() == sparesparrow::mcp::MCPMessage::NetworkStatus ? static_cast<const sparesparrow::mcp::NetworkStatus *>(message_type()) : nullptr;
  }
  const sparesparrow::mcp::SystemCommand *message_type_as_SystemCommand() const {
    return message_type_type() == sparesparrow::mcp::MCPMessage::SystemCommand ? static_cast<const sparesparrow::mcp::SystemCommand *>(message_type()) : nullptr;
  }
  const sparesparrow::mcp::SystemResponse *message_type_as_SystemResponse() const {
    return message_type_type() == sparesparrow::mcp::MCPMessage::SystemResponse ? static_cast<const sparesparrow::mcp::SystemResponse *>(message_type()) : nullptr;
  }
  uint64_t message_id() const {
    return GetField<uint64_t>(VT_MESSAGE_ID, 0);
  }
  const sparetools::common::DeviceId *device_id() const {
    return GetPointer<const sparetools::common::DeviceId *>(VT_DEVICE_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MESSAGE_TYPE) &&
           VerifyMCPMessage(verifier, message_type(), message_type_type()) &&
           VerifyField<uint64_t>(verifier, VT_MESSAGE_ID, 8) &&
           VerifyOffset(verifier, VT_DEVICE_ID) &&
           verifier.VerifyTable(device_id()) &&
           verifier.EndTable();
  }
};

template<> inline const sparesparrow::mcp::GPIOCommand *MCEnvelope::message_type_as<sparesparrow::mcp::GPIOCommand>() const {
  return message_type_as_GPIOCommand();
}

template<> inline const sparesparrow::mcp::GPIOResponse *MCEnvelope::message_type_as<sparesparrow::mcp::GPIOResponse>() const {
  return message_type_as_GPIOResponse();
}

template<> inline const sparesparrow::mcp::SerialTelemetry *MCEnvelope::message_type_as<sparesparrow::mcp::SerialTelemetry>() const {
  return message_type_as_SerialTelemetry();
}

template<> inline const sparesparrow::mcp::SerialCommand *MCEnvelope::message_type_as<sparesparrow::mcp::SerialCommand>() const {
  return message_type_as_SerialCommand();
}

template<> inline const sparesparrow::mcp::SerialResponse *MCEnvelope::message_type_as<sparesparrow::mcp::SerialResponse>() const {
  return message_type_as_SerialResponse();
}

template<> inline const sparesparrow::mcp::SystemStatus *MCEnvelope::message_type_as<sparesparrow::mcp::SystemStatus>() const {
  return message_type_as_SystemStatus();
}

template<> inline const sparesparrow::mcp::NetworkStatus *MCEnvelope::message_type_as<sparesparrow::mcp::NetworkStatus>() const {
  return message_type_as_NetworkStatus();
}

template<> inline const sparesparrow::mcp::SystemCommand *MCEnvelope::message_type_as<sparesparrow::mcp::SystemCommand>() const {
  return message_type_as_SystemCommand();
}

template<> inline const sparesparrow::mcp::SystemResponse *MCEnvelope::message_type_as<sparesparrow::mcp::SystemResponse>() const {
  return message_type_as_SystemResponse();
}

struct MCEnvelopeBuilder {
  typedef MCEnvelope Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message_type_type(sparesparrow::mcp::MCPMessage message_type_type) {
    fbb_.AddElement<uint8_t>(MCEnvelope::VT_MESSAGE_TYPE_TYPE, static_cast<uint8_t>(message_type_type), 0);
  }
  void add_message_type(::flatbuffers::Offset<void> message_type) {
    fbb_.AddOffset(MCEnvelope::VT_MESSAGE_TYPE, message_type);
  }
  void add_message_id(uint64_t message_id) {
    fbb_.AddElement<uint64_t>(MCEnvelope::VT_MESSAGE_ID, message_id, 0);
  }
  void add_device_id(::flatbuffers::Offset<sparetools::common::DeviceId> device_id) {
    fbb_.AddOffset(MCEnvelope::VT_DEVICE_ID, device_id);
  }
  explicit MCEnvelopeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MCEnvelope> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MCEnvelope>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MCEnvelope> CreateMCEnvelope(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    sparesparrow::mcp::MCPMessage message_type_type = sparesparrow::mcp::MCPMessage::NONE,
    ::flatbuffers::Offset<void> message_type = 0,
    uint64_t message_id = 0,
    ::flatbuffers::Offset<sparetools::common::DeviceId> device_id = 0) {
  MCEnvelopeBuilder builder_(_fbb);
  builder_.add_message_id(message_id);
  builder_.add_device_id(device_id);
  builder_.add_message_type(message_type);
  builder_.add_message_type_type(message_type_type);
  return builder_.Finish();
}

inline bool VerifyMCPMessage(::flatbuffers::Verifier &verifier, const void *obj, MCPMessage type) {
  switch (type) {
    case MCPMessage::NONE: {
      return true;
    }
    case MCPMessage::GPIOCommand: {
      auto ptr = reinterpret_cast<const sparesparrow::mcp::GPIOCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MCPMessage::GPIOResponse: {
      auto ptr = reinterpret_cast<const sparesparrow::mcp::GPIOResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MCPMessage::SerialTelemetry: {
      auto ptr = reinterpret_cast<const sparesparrow::mcp::SerialTelemetry *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MCPMessage::SerialCommand: {
      auto ptr = reinterpret_cast<const sparesparrow::mcp::SerialCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MCPMessage::SerialResponse: {
      auto ptr = reinterpret_cast<const sparesparrow::mcp::SerialResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MCPMessage::SystemStatus: {
      auto ptr = reinterpret_cast<const sparesparrow::mcp::SystemStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MCPMessage::NetworkStatus: {
      auto ptr = reinterpret_cast<const sparesparrow::mcp::NetworkStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MCPMessage::SystemCommand: {
      auto ptr = reinterpret_cast<const sparesparrow::mcp::SystemCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MCPMessage::SystemResponse: {
      auto ptr = reinterpret_cast<const sparesparrow::mcp::SystemResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMCPMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<MCPMessage> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMCPMessage(
        verifier,  values->Get(i), types->GetEnum<MCPMessage>(i))) {
      return false;
    }
  }
  return true;
}

inline const sparesparrow::mcp::MCEnvelope *GetMCEnvelope(const void *buf) {
  return ::flatbuffers::GetRoot<sparesparrow::mcp::MCEnvelope>(buf);
}

inline const sparesparrow::mcp::MCEnvelope *GetSizePrefixedMCEnvelope(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<sparesparrow::mcp::MCEnvelope>(buf);
}

inline bool VerifyMCEnvelopeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<sparesparrow::mcp::MCEnvelope>(nullptr);
}

inline bool VerifySizePrefixedMCEnvelopeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<sparesparrow::mcp::MCEnvelope>(nullptr);
}

inline void FinishMCEnvelopeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<sparesparrow::mcp::MCEnvelope> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMCEnvelopeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<sparesparrow::mcp::MCEnvelope> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace mcp
}  // namespace sparesparrow

#endif  // FLATBUFFERS_GENERATED_MCP_SPARESPARROW_MCP_H_
